<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EditTrades - 4H Trading Strategy Scanner</title>
  
  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="EditTrades">
  <meta property="og:description" content="EditTrades">
  <meta property="og:image" content="/logos/og_img.jpg">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="EditTrades">
  <meta name="twitter:description" content="EditTrades">
  <meta name="twitter:image" content="/logos/og_img.jpg">
  
  <link rel="icon" type="image/svg+xml" href="/logos/logo.svg">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="/edittrax-styles.css">
  <style>
    /* Prevent horizontal overflow - iOS specific fixes */
    html {
      overflow-x: hidden;
      width: 100%;
      max-width: 100%;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;
    }
    
    body {
      overflow-x: hidden;
      width: 100%;
      max-width: 100%;
      margin: 0;
      padding: 0;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;
      position: relative;
    }
    
    /* Particle background */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: -1;
      background: linear-gradient(180deg, #000000 0%, #0a0a0a 100%);
    }
    
    *, *::before, *::after {
      -webkit-box-sizing: border-box;
      box-sizing: border-box;
    }
    
    /* Prevent iOS specific issues */
    input, button, select, textarea {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    
    /* Main container width control */
    main {
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;
    }
    
    /* Additional component-specific styles */
    .details-row {
      display: none;
      background-color: transparent;
    }
    
    .details-row.expanded {
      display: table-row;
    }
    
    .details-row td {
      padding: 0.75rem !important;
      box-sizing: border-box;
      overflow: hidden;
    }
    
    .details-content-wrapper {
      width: 100%;
      max-width: 100%;
      overflow: hidden;
      box-sizing: border-box;
      -webkit-box-sizing: border-box;
    }
    
    /* Force layout recalculation on mobile iOS after toggle */
    @media (max-width: 674px) {
      .details-content-wrapper {
        display: block;
        contain: layout;
      }
      
      .details-content-wrapper .tf-grid {
        display: grid !important;
        grid-template-columns: 1fr !important;
        -webkit-grid-template-columns: 1fr !important;
      }
      
      .details-content-wrapper .trade-info-grid {
        display: grid !important;
        grid-template-columns: 1fr !important;
        -webkit-grid-template-columns: 1fr !important;
      }
    }
    
    /* Mobile responsive table */
    /* Desktop: hide mobile entry price and entry label, show desktop column */
    .entry-price-mobile {
      display: none;
    }
    .entry-label-mobile {
      display: none;
    }
    .entry-price-desktop {
      display: table-cell;
      white-space: nowrap;
      overflow: visible;
    }
    
    /* Minimize gaps on desktop */
    @media (min-width: 675px) {
      .table-edittrax th,
      .table-edittrax td {
        padding: var(--spacing-2) var(--spacing-2);
      }
      
      /* Set explicit column widths for proper alignment */
      .table-edittrax thead th:nth-child(1),
      .table-edittrax tbody td:nth-child(1) { 
        width: 15%; 
        text-align: center;
      } /* COIN */
      
      .table-edittrax thead th:nth-child(2),
      .table-edittrax tbody td:nth-child(2) { 
        width: 8%; 
        overflow: visible;
        text-align: center;
      } /* PRICE */
      
      .table-edittrax thead th:nth-child(3),
      .table-edittrax tbody td:nth-child(3) { 
        width: 15%;
        text-align: center;
      } /* SIGNAL */
      
      .table-edittrax thead th:nth-child(4),
      .table-edittrax tbody td:nth-child(4) { 
        width: 30%;
        text-align: center;
      } /* STRATEGY */
      
      .table-edittrax thead th:nth-child(5),
      .table-edittrax tbody td:nth-child(5) { 
        width: 30%;
        text-align: center;
      } /* ACTIONS */
      
      /* Ensure flex containers respect column width and are centered */
      .table-edittrax tbody td:nth-child(4) .flex,
      .table-edittrax tbody td:nth-child(5) .flex {
        width: 100%;
        max-width: 100%;
        justify-content: center;
      }
      
      /* Reduce gap between action buttons */
      .flex.gap-1 {
        gap: 0.25rem;
      }
    }
    
    /* Medium screens: Hide entry column for more compact table */
    @media (min-width: 675px) and (max-width: 900px) {
      /* Hide entry price column and label on medium screens */
      .entry-cell,
      .table-edittrax thead th:nth-child(3) {
        display: none !important;
      }
      
      /* Make table expand to full width */
      .table-edittrax {
        width: 100% !important;
      }
      
      /* Adjust remaining column widths to fill space */
      .table-edittrax thead th:nth-child(1),
      .table-edittrax tbody td:nth-child(1) { 
        width: 18% !important;
      }
      
      .table-edittrax thead th:nth-child(2),
      .table-edittrax tbody td:nth-child(2) { 
        width: 18% !important;
      }
      
      .table-edittrax thead th:nth-child(4),
      .table-edittrax tbody td:nth-child(4) { 
        width: 28% !important;
      }
      
      .table-edittrax thead th:nth-child(5),
      .table-edittrax tbody td:nth-child(5) { 
        width: 36% !important;
      }
    }
    
    /* Mobile: Single breakpoint for all mobile/small screen styles */
    @media (max-width: 674px) {
      /* Mobile: add consistent padding to header and main content */
      .header-edittrax > div,
      main {
        padding-left: 5px !important;
        padding-right: 5px !important;
      }
      
      /* Mobile: results container padding */
      #resultsContainer {
        padding-left: 5px !important;
        padding-right: 5px !important;
      }
      
      /* Mobile: adjust trading indicators position and size */
      .header-edittrax > div > div[style*="position: absolute"][style*="top: 25px"][style*="left: 0"] {
        top: 18px !important;
        left: 5px !important;
        font-size: 0.6rem !important;
        gap: 8px !important;
      }
      
      #candle-timer-container,
      #4h-timer-container {
        gap: 4px !important;
      }
      
      #candle-timer-container > div,
      #4h-timer-container > div {
        width: 25px !important;
        height: 2px !important;
      }
      
      /* Mobile: adjust top-right actions */
      .header-edittrax > div > div[style*="top: 25px"][style*="right: 0"] {
        top: 18px !important;
        right: 5px !important;
        gap: 17px !important;
      }
      
      #refreshBtn,
      #dataCopyBtn,
      .header-edittrax a[href="/strategy.html"] {
        padding: 2px 4px !important;
        font-size: 0.6rem !important;
        gap: 4px !important;
      }
      
      #refreshBtn svg,
      #dataCopyBtn svg,
      .header-edittrax a[href="/strategy.html"] svg {
        width: 16px !important;
        height: 16px !important;
      }
      
      /* Mobile: adjust news marquee - full width, no padding */
      #newsMarquee {
        font-size: 0.75rem !important;
        padding: 0.4rem 0 !important;
        margin-left: -5px !important;
        margin-right: -5px !important;
        width: calc(100% + 10px) !important;
      }
      
      /* Mobile: make strategy buttons stretch full width */
      .strategy-buttons-container {
        width: 100% !important;
      }
      
      .strategy-buttons-container button {
        flex: 1 !important;
        min-width: 0 !important;
      }
      
      /* Mobile: show entry price under coin name, hide desktop column */
      .entry-price-mobile {
        display: block !important;
      }
      .entry-label-mobile {
        display: block !important;
        text-align: right !important;
      }
      .entry-value {
        text-align: right !important;
      }
      .entry-price-desktop {
        display: none !important;
      }
      
      /* Right-justify signal confidence on mobile */
      .signal-confidence {
        text-align: right !important;
      }
      
      /* Mobile: Adjust action buttons for better fit */
      .table-edittrax tbody td:nth-child(5) .flex {
        gap: 0.5rem !important;
      }
      
      .table-edittrax tbody td:nth-child(5) button {
        font-size: 0.65rem !important;
        padding: 0.4rem 0.6rem !important;
        min-width: auto !important;
      }
      
      .table-edittrax thead {
        display: none;
      }
      
      .coin-row {
        display: block !important;
        padding: 0 0.5rem 1rem 0.5rem;
        border-bottom: 2px solid var(--color-yellow-75);
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }
      
      /* Ensure table stays block layout on mobile */
      .table-edittrax tbody {
        display: block !important;
      }
      
      .table-edittrax tbody tr.coin-row {
        display: block !important;
      }
      
      /* Keep details row hidden unless expanded */
      .table-edittrax tbody tr.details-row {
        display: none !important;
      }
      
      .table-edittrax tbody tr.details-row.expanded {
        display: block !important;
      }
      
      .table-edittrax tbody tr.details-row.expanded td {
        display: block !important;
      }
      
      /* Create flex container for first row */
      .coin-row::after {
        content: "";
        display: table;
        clear: both;
      }
      
      .coin-row td {
        padding: 0.5rem 0 !important;
        border: none;
        text-align: left !important;
        max-width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }
      
      .coin-row td:before {
        content: attr(data-label);
        font-weight: bold;
        display: block;
        margin-bottom: 0.25rem;
        color: var(--color-yellow-75);
        font-size: 0.7rem;
        text-transform: uppercase;
      }
      
      /* Coin name and Signal on same row with flex (Signal is now 3rd column) */
      .coin-row td:first-child,
      .coin-row td:nth-child(3) {
        display: inline-block;
        vertical-align: top;
      }
      
      .coin-row td:first-child {
        width: auto;
        max-width: 50%;
        font-size: 2.5rem;
        padding-right: 0.5rem !important;
        word-wrap: break-word;
        overflow-wrap: break-word;
        box-sizing: border-box;
      }
      
      .coin-row td:first-child:before {
        display: none;
      }
      
      .coin-row td:nth-child(3) {
        width: auto;
        float: right;
        text-align: right;
      }
      
      .coin-row td:nth-child(3):before {
        display: none;
      }
      
      /* Make signal text same size as coin name */
      .coin-row td:nth-child(3) div[id^="signal-"] > div:first-child {
        font-size: 1.25rem !important;
      }
      
      .coin-row td:nth-child(3) div[id^="signal-"] > div:last-child {
        font-size: 1rem !important;
      }
      
      /* Strategy on its own row (now 4th column) */
      .coin-row td:nth-child(4) {
        display: block;
        clear: both;
      }
      
      /* Action buttons on their own row (now 5th column) */
      .coin-row td:nth-child(5) {
        display: block;
      }
      
      /* Strategy buttons stretch full width */
      .coin-row td:nth-child(4) .flex {
        width: 100%;
        max-width: 100%;
        display: flex;
        gap: 0;
        box-sizing: border-box;
        overflow: hidden;
      }
      
      /* EditTrades button needs more space */
      .coin-row td:nth-child(4) button {
        flex: 0 0 auto;
        min-width: 80px;
        max-width: 30%;
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        box-sizing: border-box;
      }
      
      /* Indicator buttons share remaining space */
      .coin-row td:nth-child(4) div[id^="indicator-"] {
        flex: 1;
        min-width: 0;
        max-width: 23%;
        font-size: 0.65rem;
        padding: 0.35rem 0.25rem;
        box-sizing: border-box;
      }
      
      /* Action buttons stretch full width */
      .coin-row td:nth-child(5) .flex {
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        gap: 0.5rem;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      
      .coin-row td:nth-child(5) button {
        width: 100%;
        max-width: 100%;
        justify-content: center;
        font-size: 0.65rem;
        padding: 0.35rem 0.25rem;
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      /* Shrink logo on mobile */
      .logo-img {
        height: 32px !important;
      }
      
      
      /* Shrink nav buttons on mobile */
      .grid[style*="grid-template-columns"] {
        grid-template-columns: 1fr 1fr !important;
        gap: 0.2rem !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
      }
      
      .btn-base {
        padding: 0.35rem 0.25rem !important;
        font-size: 0.6rem !important;
        min-width: auto !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
      }
    }
    
    /* Container consistency - match header and content padding */
    .container,
    .max-w-7xl {
      width: 100%;
      max-width: 100%;
      padding-left: var(--spacing-4);
      padding-right: var(--spacing-4);
      box-sizing: border-box;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* Table container responsive */
    .table-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    /* Timeframe grid */
    .tf-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.75rem;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* Mobile: Force 1 column (iOS fix) */
    @media (max-width: 674px) {
      .tf-grid {
        grid-template-columns: 1fr !important;
      }
    }
    
    /* Desktop: 4 columns */
    @media (min-width: 675px) {
      .tf-grid {
        grid-template-columns: repeat(4, 1fr) !important;
      }
    }
    
    .tf-grid > * {
      min-width: 0;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    /* Trade info grid (Confidence, Direction, Setup Type) */
    .trade-info-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    @media (min-width: 675px) {
      .trade-info-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    /* Timeframe cards */
    .tf-card {
      width: 100%;
      max-width: 100%;
      padding: 1rem;
      background-color: black;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      box-sizing: border-box;
      -webkit-box-sizing: border-box;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    
    /* Dashboard cards - oversized version */
    .dashboard-card {
      padding: 2rem !important;
      min-height: 200px;
    }
    
    /* Dashboard grid - responsive */
    @media (min-width: 1024px) {
      .dashboard-grid {
        grid-template-columns: repeat(2, 1fr) !important;
      }
    }
    
    @media (min-width: 1400px) {
      .dashboard-grid {
        grid-template-columns: repeat(3, 1fr) !important;
      }
    }
    
    /* iOS specific fix for grid layout */
    @supports (-webkit-touch-callout: none) {
      .tf-grid {
        display: -webkit-grid;
        display: grid;
      }
      
      @media (max-width: 674px) {
        .tf-grid {
          -webkit-grid-template-columns: 1fr;
          grid-template-columns: 1fr !important;
        }
      }
      
      .tf-card {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
      }
    }
    
    .tf-card.uptrend {
      border-color: rgba(34, 197, 94, 0.6);
      box-shadow: 
        0 0 15px rgba(34, 197, 94, 0.3),
        0 0 30px rgba(34, 197, 94, 0.2),
        inset 0 0 20px rgba(34, 197, 94, 0.05);
    }
    
    .tf-card.downtrend {
      border-color: rgba(239, 68, 68, 0.6);
      box-shadow: 
        0 0 15px rgba(239, 68, 68, 0.3),
        0 0 30px rgba(239, 68, 68, 0.2),
        inset 0 0 20px rgba(239, 68, 68, 0.05);
    }
    
    .tf-card.flat {
      border-color: rgba(156, 163, 175, 0.3);
    }
    
    /* Rotating glow streak effect - fills entire card space */
    .tf-card.uptrend::before,
    .tf-card.downtrend::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      animation: rotateGlow 12.8s linear infinite;
      z-index: 0;
      border-radius: var(--radius-md);
      overflow: hidden;
    }
    
    .tf-card.uptrend::before {
      background: conic-gradient(
        from 0deg at 50% 50%,
        rgba(34, 197, 94, 0.15) 0deg,
        rgba(34, 197, 94, 0.25) 45deg,
        rgba(34, 197, 94, 0.4) 90deg,
        rgba(34, 197, 94, 0.6) 135deg,
        rgba(34, 197, 94, 0.7) 180deg,
        rgba(34, 197, 94, 0.6) 225deg,
        rgba(34, 197, 94, 0.4) 270deg,
        rgba(34, 197, 94, 0.25) 315deg,
        rgba(34, 197, 94, 0.15) 360deg
      );
      filter: blur(30px);
    }
    
    .tf-card.downtrend::before {
      background: conic-gradient(
        from 0deg at 50% 50%,
        rgba(239, 68, 68, 0.15) 0deg,
        rgba(239, 68, 68, 0.25) 45deg,
        rgba(239, 68, 68, 0.4) 90deg,
        rgba(239, 68, 68, 0.6) 135deg,
        rgba(239, 68, 68, 0.7) 180deg,
        rgba(239, 68, 68, 0.6) 225deg,
        rgba(239, 68, 68, 0.4) 270deg,
        rgba(239, 68, 68, 0.25) 315deg,
        rgba(239, 68, 68, 0.15) 360deg
      );
      filter: blur(30px);
    }
    
    /* Ensure card content is above the glow */
    .tf-card > * {
      position: relative;
      z-index: 1;
    }
    
    /* Smooth rotation animation */
    @keyframes rotateGlow {
      0% {
        transform: translate(-50%, -50%) rotate(0deg);
      }
      100% {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
    
    /* News Marquee Animation */
    @keyframes marquee {
      0% {
        transform: translateX(0%);
      }
      100% {
        transform: translateX(-50%);
      }
    }
    
    #newsMarquee:hover #newsMarqueeContent {
      animation-play-state: paused;
    }
    
    #newsMarqueeContent a:hover {
      opacity: 0.8;
    }
    
    /* Table row styling */
    .coin-row {
      position: relative;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      background-color: transparent;
    }
    
    /* Static glow background for LONG trades */
    .coin-row.has-trade-long {
      background: radial-gradient(
        ellipse at 0% 50%,
        rgba(34, 197, 94, 0.2) 0%,
        rgba(34, 197, 94, 0.12) 30%,
        rgba(34, 197, 94, 0.06) 60%,
        transparent 100%
      );
      border-left: 2px solid rgba(34, 197, 94, 0.6);
    }
    
    /* Static glow background for SHORT trades */
    .coin-row.has-trade-short {
      background: radial-gradient(
        ellipse at 0% 50%,
        rgba(239, 68, 68, 0.2) 0%,
        rgba(239, 68, 68, 0.12) 30%,
        rgba(239, 68, 68, 0.06) 60%,
        transparent 100%
      );
      border-left: 2px solid rgba(239, 68, 68, 0.6);
    }
    
    /* All table cells */
    .coin-row > td {
      background-color: transparent;
      position: relative;
    }
    
    /* Pulse glow animation for buttons */
    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
      }
      50% {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.4), 0 0 30px rgba(255, 255, 255, 0.2);
      }
    }
    
    /* Desktop: stronger border */
    @media (min-width: 675px) {
      .coin-row {
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
    }
    
    /* Subtle static glow on text elements */
    .tf-card.uptrend .status-long {
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }
    
    .tf-card.downtrend .status-short {
      text-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
    
    /* Colored titles for trend cards */
    .tf-card.uptrend > div:first-child > p {
      color: rgba(34, 197, 94, 1);
      text-shadow: 0 0 6px rgba(34, 197, 94, 0.4);
    }
    
    .tf-card.downtrend > div:first-child > p {
      color: rgba(239, 68, 68, 1);
      text-shadow: 0 0 6px rgba(239, 68, 68, 0.4);
    }
    
    /* Trend badge subtle glow */
    .tf-card.uptrend > div:first-child > span {
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }
    
    .tf-card.downtrend > div:first-child > span {
      text-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
  </style>
</head>
<body class="min-h-screen">
  
  <!-- Color Bar - Top Border -->
  <img src="/logos/color_bar.png" alt="" style="position: fixed; top: 0; left: 0; width: 100%; height: 5px; max-height: 5px; z-index: 9999; pointer-events: none; display: block; object-fit: cover;">
  
  <!-- Particle Background -->
  <div id="particles-js"></div>
  
  <!-- Header -->
  <header class="header-edittrax">
    <div class="max-w-6xl mx-auto pt-3" style="position: relative;">
      <!-- Trading Indicators (Top Left) -->
      <div style="position: absolute; top: 25px; left: 0; display: flex; flex-direction: column; gap: 6px; font-family: var(--font-mathias); color: var(--color-yellow-75); font-size: 0.75rem; z-index: 50;">
        <!-- 1M Candle Timer -->
        <div id="candle-timer-container" style="display: flex; align-items: center; gap: 8px;">
          <span>1M</span>
          <div style="width: 50px; height: 3px; background-color: rgba(230, 233, 224, 0.2); border-radius: 2px; overflow: hidden;">
            <div id="candle-timer-bar" style="width: 100%; height: 100%; background-color: var(--color-yellow-75); transition: width 0.5s linear;"></div>
          </div>
        </div>
        <!-- 4H Candle Timer -->
        <div id="4h-timer-container" style="display: flex; align-items: center; gap: 8px;">
          <span>4H</span>
          <div style="width: 50px; height: 3px; background-color: rgba(230, 233, 224, 0.2); border-radius: 2px; overflow: hidden;">
            <div id="4h-timer-bar" style="width: 100%; height: 100%; background-color: var(--color-yellow-75); transition: width 0.5s linear;"></div>
          </div>
        </div>
        <!-- Active Signals -->
        <div id="active-signals" style="display: flex; align-items: center; gap: 8px;">
          <span id="signals-count" style="font-weight: bold; color: var(--color-yellow-75);">0 SIGNALS</span>
        </div>
      </div>
      
      <!-- Top Right Actions -->
      <div style="position: absolute; top: 25px; right: 0; display: flex; flex-direction: column; gap: 17px; align-items: flex-end; z-index: 50; font-family: var(--font-mathias); font-size: 0.75rem;">
        <!-- Refresh -->
        <button 
          id="refreshBtn" 
          onclick="scanMajorCoins()"
          style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem;"
          title="Refresh Data"
        >
          <span style="font-weight: bold;">REFRESH</span>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
          </svg>
        </button>
        
        <!-- Download Data -->
        <button 
          id="dataCopyBtn" 
          onclick="downloadAllCoins()"
          style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem;"
          title="Download All Data as .txt file"
        >
          <span style="font-weight: bold;">DL DATA</span>
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
        
        <!-- Copy Toast -->
        <div id="copyToastContainer" style="pointer-events: none;"></div>
        
      </div>
      
      <div class="flex flex-col items-center gap-3 w-full">
        <div class="logo-container flex flex-col items-center gap-2">
          <img src="/logos/load.gif" alt="Loading Animation" style="width: 140px; height: auto;">
          <img src="/logos/et_horizontal.png" alt="EditTrades Logo" class="logo-img">
        </div>
        <div class="grid gap-2 w-full" style="grid-template-columns: 1fr 1fr;">
          <button 
            id="safeToggle" 
            onclick="toggleToSafe()"
            class="btn-base btn-secondary px-2 py-2 text-xs sm:text-sm rounded text-center whitespace-nowrap"
            style="transition: all 0.3s ease;"
          >
            <span id="safeLabel">SAFE (<span id="safe-count">0</span>)</span>
          </button>
          <button 
            id="aggressiveToggle" 
            onclick="toggleToAggressive()"
            class="btn-base btn-secondary px-2 py-2 text-xs sm:text-sm rounded text-center whitespace-nowrap"
            style="transition: all 0.3s ease;"
          >
            <span id="aggressiveLabel">AGGRESSIVE (<span id="aggressive-count">0</span>)</span>
          </button>
            </div>
          </div>
              </div>
  </header>

  <!-- Main Content -->
  <main class="max-w-6xl mx-auto pb-4" style="width: 100%; box-sizing: border-box;overflow: visible; position: relative;">
    
    <!-- AI Market Review Marquee -->
    <div id="newsMarquee" style="background-color: rgba(0, 0, 0, 0.6); border-radius: 5px; padding: 0.5rem 0; margin: 0.5rem 0 1rem 0; overflow: hidden; position: relative;">
      <div id="newsMarqueeContent" style="display: flex; white-space: nowrap; animation: marquee 10.5s linear infinite; font-family: var(--font-mathias); color: var(--color-yellow-75); font-size: 0.875rem;">
        <span style="padding: 0 2rem;">Analyzing Market Sentiment</span>
      </div>
    </div>

    <!-- Loading State -->
    <div id="loadingState" class="text-center py-12">
      <div class="inline-block w-8 h-8 border-2 border-t-transparent rounded-full animate-spin mb-4" style="border-color: var(--text-primary); border-top-color: transparent;"></div>
      <!-- <p style="color: var(--text-secondary);">Loading BTC, ETH & SOL...</p> -->
    </div>

    <!-- Error State -->
    <div id="errorState" class="hidden card rounded p-4 mb-4 border-red-600">
      <h3 class="font-bold mb-2 text-red-400">Error</h3>
      <p id="errorMessage" class="text-sm" style="color: var(--text-secondary);"></p>
      <button onclick="scanMajorCoins()" class="mt-3 btn-primary px-4 py-2 text-sm rounded">
        Retry
      </button>
    </div>

    <!-- Results Container -->
    <div id="resultsContainer" class="hidden" style="padding-left: 1rem; padding-right: 1rem;">
      
      <!-- Opportunities Table -->
      <div class="card-edittrax rounded-lg mb-4" style="overflow: hidden; border: 2px solid var(--color-yellow-75);">
        <div class="table-container">
          <table class="table-edittrax" style="border: none; margin: 0; border-collapse: collapse;">
            <thead style="background-color: var(--color-yellow-75); border: none; border-left: none; border-right: none;">
              <tr style="border: none; border-left: none; border-right: none;">
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; text-align: center; border: none; border-left: none;">COIN</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black;">PRICE</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black;">ENTRY</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black;">EDITTRADES</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black;">ACTIONS</th>
              </tr>
            </thead>
            <tbody id="opportunitiesTable">
              <!-- Rows will be populated dynamically -->
            </tbody>
          </table>
          </div>
          
          <!-- Legend -->
          <div style="padding: 1rem 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 2rem; justify-content: center; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 0.5rem; font-family: var(--font-mathias); font-size: 0.75rem;">
              <div style="width: 12px; height: 12px; border-radius: 50%; background-color: #10b981;"></div>
              <span style="color: var(--color-yellow-75);">LONG TRADE</span>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; font-family: var(--font-mathias); font-size: 0.75rem;">
              <div style="width: 12px; height: 12px; border-radius: 50%; background-color: #ef4444;"></div>
              <span style="color: var(--color-yellow-75);">SHORT TRADE</span>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem; font-family: var(--font-mathias); font-size: 0.75rem;">
              <div style="width: 12px; height: 12px; border-radius: 50%; background-color: #6b7280;"></div>
              <span style="color: var(--color-yellow-75);">NO TRADE</span>
            </div>
          </div>
          
          <!-- Footer Links -->
          <div style="padding: 0.75rem 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
            <a 
              href="/strategy.html"
              style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem; text-decoration: none;"
              title="Proof of Strategy"
            >
              <span style="font-weight: bold;">PROOF OF STRATEGY</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
            </a>
            
            <a 
              href="/tracker.html"
              style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem; text-decoration: none;"
              title="Trade Tracker"
            >
              <span style="font-weight: bold;">TRADE TRACKER</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
            </a>
          </div>
          </div>

      </div>

      <!-- High Level Dashboard -->
      <div id="highLevelDashboard" class="hidden" style="padding: 2rem 1rem; margin-top: 2rem;">
        <div class="card-edittrax rounded-lg" style="border: 2px solid var(--color-yellow-75); padding: 2rem; background: rgba(0, 0, 0, 0.8);">
          <h2 style="font-family: var(--font-mathias); font-size: 1.5rem; color: var(--color-yellow-75); margin-bottom: 2rem; text-align: center; font-weight: bold;">
            HIGH LEVEL DASHBOARD
          </h2>
          
          <!-- Dashboard Grid -->
          <div class="dashboard-grid" style="display: grid; grid-template-columns: 1fr; gap: 1.5rem;">
            
            <!-- 1. HTF Trend State -->
            <div class="dashboard-card tf-card" id="htf-trend-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  HTF Trend Alignment
                </div>
                <div class="htf-trend-display" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                  <div class="htf-tf" data-tf="1d" style="text-align: center;">
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">1D</div>
                    <div class="htf-trend-value" style="font-size: 2rem; font-weight: bold; margin-bottom: 0.25rem;">-</div>
                    <div class="htf-confidence" style="font-size: 1rem; color: rgba(255, 255, 255, 0.7);">-</div>
                  </div>
                  <div class="htf-tf" data-tf="4h" style="text-align: center;">
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">4H</div>
                    <div class="htf-trend-value" style="font-size: 2rem; font-weight: bold; margin-bottom: 0.25rem;">-</div>
                    <div class="htf-confidence" style="font-size: 1rem; color: rgba(255, 255, 255, 0.7);">-</div>
                  </div>
                  <div class="htf-tf" data-tf="1h" style="text-align: center;">
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">1H</div>
                    <div class="htf-trend-value" style="font-size: 2rem; font-weight: bold; margin-bottom: 0.25rem;">-</div>
                    <div class="htf-confidence" style="font-size: 1rem; color: rgba(255, 255, 255, 0.7);">-</div>
                  </div>
                </div>
                <div id="htf-alignment-status" style="margin-top: 1rem; text-align: center; font-size: 1.25rem; font-weight: bold; font-family: var(--font-mathias);">
                  <span style="color: rgba(255, 255, 255, 0.4);">WAITING FOR DATA</span>
                </div>
              </div>
            </div>

            <!-- 2. Liquidity Map -->
            <div class="dashboard-card tf-card" id="liquidity-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  Liquidity Map
                </div>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">Equal Highs Above</div>
                    <div id="liquidity-highs" style="display: flex; gap: 0.5rem; flex-wrap: wrap; min-height: 40px;">
                      <span style="color: rgba(255, 255, 255, 0.4);">-</span>
                    </div>
                  </div>
                  <div style="height: 2px; background: rgba(255, 255, 255, 0.1); margin: 0.5rem 0;">
                    <div id="current-price-marker" style="width: 4px; height: 8px; background: var(--color-yellow-75); margin: -3px auto 0; border-radius: 2px;"></div>
                  </div>
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">Equal Lows Below</div>
                    <div id="liquidity-lows" style="display: flex; gap: 0.5rem; flex-wrap: wrap; min-height: 40px;">
                      <span style="color: rgba(255, 255, 255, 0.4);">-</span>
                    </div>
                  </div>
                </div>
                <div id="liquidity-bias" style="margin-top: 1rem; text-align: center; font-size: 1.25rem; font-weight: bold; font-family: var(--font-mathias);">
                  <span style="color: rgba(255, 255, 255, 0.4);">-</span>
                </div>
              </div>
            </div>

            <!-- 3. FVG State -->
            <div class="dashboard-card tf-card" id="fvg-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  Fair Value Gaps
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">Bullish FVGs Below</div>
                    <div id="fvg-bullish" style="font-size: 2rem; font-weight: bold; color: #10b981;">-</div>
                    <div id="fvg-bullish-status" style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.25rem;">-</div>
                  </div>
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">Bearish FVGs Above</div>
                    <div id="fvg-bearish" style="font-size: 2rem; font-weight: bold; color: #ef4444;">-</div>
                    <div id="fvg-bearish-status" style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.25rem;">-</div>
                  </div>
                </div>
                <div id="fvg-price-status" style="margin-top: 1.5rem; text-align: center; font-size: 1.125rem; font-weight: bold; font-family: var(--font-mathias); padding: 0.75rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                  <span style="color: rgba(255, 255, 255, 0.4);">Price Position: -</span>
                </div>
              </div>
            </div>

            <!-- 4. Divergence Alerts -->
            <div class="dashboard-card tf-card" id="divergence-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  Divergence Alerts
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">1H RSI</div>
                    <div id="div-rsi" style="font-size: 1.5rem; font-weight: bold;">-</div>
                    <div id="div-rsi-detail" style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.25rem;">-</div>
                  </div>
                  <div>
                    <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem;">15m Stoch</div>
                    <div id="div-stoch" style="font-size: 1.5rem; font-weight: bold;">-</div>
                    <div id="div-stoch-detail" style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-top: 0.25rem;">-</div>
                  </div>
                </div>
                <div id="divergence-alert" style="margin-top: 1.5rem; text-align: center; font-size: 1.125rem; font-weight: bold; font-family: var(--font-mathias); padding: 0.75rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                  <span style="color: rgba(255, 255, 255, 0.4);">No Divergences</span>
                </div>
              </div>
            </div>

            <!-- 5. Volatility (ATR State) -->
            <div class="dashboard-card tf-card" id="volatility-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  Volatility State
                </div>
                <div style="text-align: center;">
                  <div id="atr-value" style="font-size: 3rem; font-weight: bold; margin-bottom: 0.5rem;">-</div>
                  <div id="atr-state" style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">-</div>
                  <div id="atr-status" style="font-size: 1rem; color: rgba(255, 255, 255, 0.7); font-family: var(--font-mathias);">
                    <span style="color: rgba(255, 255, 255, 0.4);">-</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- 6. Volume Profile Bias -->
            <div class="dashboard-card tf-card" id="volume-profile-card" style="min-height: 200px;">
              <div style="position: relative; z-index: 1;">
                <div style="font-family: var(--font-mathias); font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">
                  Volume Profile Position
                </div>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                  <div style="position: relative; height: 120px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 1rem;">
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 1px; background: rgba(255, 255, 255, 0.2);" id="vah-line"></div>
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 1px; background: rgba(255, 255, 255, 0.2);" id="val-line"></div>
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 4px; height: 100%; background: var(--color-yellow-75); border-radius: 2px; opacity: 0.6;" id="price-line"></div>
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.25rem; font-weight: bold; color: var(--color-yellow-75); background: rgba(0, 0, 0, 0.8); padding: 0.25rem 0.5rem; border-radius: 4px;" id="price-label">PRICE</div>
                    <div style="position: absolute; top: 0.5rem; left: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.5);" id="vah-label">VAH</div>
                    <div style="position: absolute; bottom: 0.5rem; left: 0.5rem; font-size: 0.75rem; color: rgba(255, 255, 255, 0.5);" id="val-label">VAL</div>
                  </div>
                  <div id="vp-bias" style="text-align: center; font-size: 1.5rem; font-weight: bold; font-family: var(--font-mathias);">
                    <span style="color: rgba(255, 255, 255, 0.4);">-</span>
                  </div>
                </div>
              </div>
            </div>

          </div>
          
          <!-- Trade Readiness Meter -->
          <div id="trade-readiness-section" class="hidden" style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.1);">
            <div class="card-edittrax rounded-lg" style="border: 2px solid var(--color-yellow-75); padding: 2rem; background: rgba(0, 0, 0, 0.8);">
              <h2 style="font-family: var(--font-mathias); font-size: 1.5rem; color: var(--color-yellow-75); margin-bottom: 2rem; text-align: center; font-weight: bold;">
                TRADE READINESS METER
              </h2>
              
              <!-- Big Meter -->
              <div id="readiness-meter" style="text-align: center; margin-bottom: 3rem;">
                <div id="readiness-score" style="font-size: 5rem; font-weight: bold; font-family: var(--font-mathias); margin-bottom: 1rem; text-shadow: 0 0 30px currentColor;">
                  -
                </div>
                <div id="readiness-label" style="font-size: 2rem; font-weight: bold; font-family: var(--font-mathias); margin-bottom: 0.5rem;">
                  -
                </div>
                <div id="readiness-message" style="font-size: 1.125rem; color: rgba(255, 255, 255, 0.7); font-family: var(--font-mathias); margin-bottom: 1rem;">
                  -
                </div>
                <div id="readiness-mode" style="font-size: 1rem; color: rgba(255, 255, 255, 0.5); font-family: var(--font-mathias);">
                  -
                </div>
              </div>
              
              <!-- Why This Score Tiles -->
              <div id="readiness-breakdown" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                <!-- Tiles will be populated dynamically -->
              </div>
              
              <!-- Active Strategy Signals -->
              <div id="active-strategies" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="font-family: var(--font-mathias); font-size: 1.125rem; color: var(--color-yellow-75); margin-bottom: 1rem; font-weight: bold;">
                  Active Strategy Signals
                </div>
                <div id="strategy-signals-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                  <!-- Strategy cards will be populated dynamically -->
                </div>
              </div>
              
              <!-- AI Breakdown -->
              <div id="ai-trade-breakdown" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="font-family: var(--font-mathias); font-size: 1.125rem; color: var(--color-yellow-75); margin-bottom: 1rem; font-weight: bold;">
                  AI Trade Analysis
                </div>
                <div id="ai-breakdown-content" class="tf-card" style="padding: 1.5rem; min-height: 150px;">
                  <div style="position: relative; z-index: 1;">
                    <div id="ai-best-trade" style="font-size: 1.5rem; font-weight: bold; font-family: var(--font-mathias); margin-bottom: 1rem; color: var(--color-yellow-75);">
                      Analyzing...
                    </div>
                    <div id="ai-breakdown-text" style="font-size: 1rem; color: rgba(255, 255, 255, 0.8); line-height: 1.6; font-family: var(--font-mathias);">
                      Waiting for data...
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- AI Chat Section -->
              <div id="ai-chat-section" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="font-family: var(--font-mathias); font-size: 1.125rem; color: var(--color-yellow-75); margin-bottom: 1rem; font-weight: bold;">
                  Ask About Trades & Market
                </div>
                <div id="ai-chat-messages" style="max-height: 400px; overflow-y: auto; margin-bottom: 1rem; padding: 1rem; background: rgba(0, 0, 0, 0.4); border-radius: var(--radius-md); border: 1px solid rgba(255, 255, 255, 0.1);">
                  <div style="color: rgba(255, 255, 255, 0.6); font-size: 0.875rem; font-family: var(--font-system); text-align: center; padding: 1rem;">
                    Ask questions about trade signals, market state, or specific setups...
                  </div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                  <input 
                    type="text" 
                    id="ai-chat-input" 
                    placeholder="Ask about trades, market state, or specific signals..." 
                    style="flex: 1; padding: 0.75rem; background: rgba(0, 0, 0, 0.6); border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); color: white; font-family: var(--font-system); font-size: 0.875rem;"
                    onkeypress="if(event.key === 'Enter') { sendChatMessage(); }"
                  >
                  <button 
                    id="ai-chat-send" 
                    onclick="sendChatMessage()"
                    style="padding: 0.75rem 1.5rem; background: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); font-family: var(--font-mathias); font-weight: bold; cursor: pointer; transition: all 0.3s;"
                    onmouseover="this.style.background='#d4d7cc'; this.style.borderColor='#d4d7cc';"
                    onmouseout="this.style.background='var(--color-yellow-75)'; this.style.borderColor='var(--color-yellow-75)';"
                  >
                    SEND
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

  </main>

  <script>
    let scanResults = {};
    let scanResultsAggressive = {}; // Store aggressive mode results
    let scanResultsSafe = {}; // Store safe mode results
    
    // Aggressive mode state (default: STANDARD)
    let aggressiveMode = localStorage.getItem('aggressiveMode') === 'true' || false;
    
    // Initialize aggressive mode UI on page load
    function initializeAggressiveMode() {
      // Initialize mode button states
      updateModeButtons();
    }
    
    // Toggle aggressive mode
    function toggleToAggressive() {
      if (aggressiveMode) return; // Already in aggressive mode
      aggressiveMode = true;
      localStorage.setItem('aggressiveMode', aggressiveMode);
      updateModeButtons();
      
      // Switch display to aggressive mode
      scanResults = scanResultsAggressive;
      
      // If mode data doesn't exist yet, fetch it
      if (Object.keys(scanResults).length === 0) {
        scanMajorCoins();
      } else {
        displayResults();
      }
    }
    
    function toggleToSafe() {
      if (!aggressiveMode) return; // Already in safe mode
      aggressiveMode = false;
      localStorage.setItem('aggressiveMode', aggressiveMode);
      updateModeButtons();
      
      // Switch display to safe mode
      scanResults = scanResultsSafe;
      
      // If mode data doesn't exist yet, fetch it
      if (Object.keys(scanResults).length === 0) {
        scanMajorCoins();
      } else {
        displayResults();
      }
    }
    
    // Update mode button states
    function updateModeButtons() {
      const aggressiveBtn = document.getElementById('aggressiveToggle');
      const safeBtn = document.getElementById('safeToggle');
      
      // Get highest confidence trade for each mode
      const getStrongestTrade = (results) => {
        let strongestConfidence = 0;
        let dominantDirection = null;
        
        Object.entries(results).forEach(([symbol, data]) => {
          const signal = data?.signal || data?.tradeSignal;
          if (signal && signal.valid) {
            const confidence = signal.confidence || 0;
            if (confidence > strongestConfidence) {
              strongestConfidence = confidence;
              dominantDirection = signal.direction;
            }
          }
        });
        
        return { hasTrade: strongestConfidence > 0, dominantDirection };
      };
      
      const aggressiveTrade = getStrongestTrade(scanResultsAggressive);
      const safeTrade = getStrongestTrade(scanResultsSafe);
      
      if (aggressiveMode) {
        // AGGRESSIVE MODE ACTIVE: Yellow-white bg with black text
        aggressiveBtn.style.backgroundColor = 'var(--color-yellow-75)';
        aggressiveBtn.style.color = 'black';
        aggressiveBtn.style.borderColor = 'var(--color-yellow-75)';
        aggressiveBtn.style.animation = 'none';
        
        // SAFE MODE INACTIVE: Show glow based on trade
        if (safeTrade.hasTrade) {
          const isLong = safeTrade.dominantDirection === 'long' || safeTrade.dominantDirection === 'LONG';
          safeBtn.style.backgroundColor = isLong ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';
          safeBtn.style.color = 'var(--color-yellow-75)';
          safeBtn.style.animation = 'pulse-glow 2s ease-in-out infinite';
        } else {
          safeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          safeBtn.style.color = 'var(--color-yellow-75)';
          safeBtn.style.animation = 'none';
        }
        safeBtn.style.borderColor = 'var(--color-yellow-75)';
        
      } else {
        // SAFE MODE ACTIVE: Yellow-white bg with black text
        safeBtn.style.backgroundColor = 'var(--color-yellow-75)';
        safeBtn.style.color = 'black';
        safeBtn.style.borderColor = 'var(--color-yellow-75)';
        safeBtn.style.animation = 'none';
        
        // AGGRESSIVE MODE INACTIVE: Show glow based on trade
        if (aggressiveTrade.hasTrade) {
          const isLong = aggressiveTrade.dominantDirection === 'long' || aggressiveTrade.dominantDirection === 'LONG';
          aggressiveBtn.style.backgroundColor = isLong ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';
          aggressiveBtn.style.color = 'var(--color-yellow-75)';
          aggressiveBtn.style.animation = 'pulse-glow 2s ease-in-out infinite';
        } else {
          aggressiveBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          aggressiveBtn.style.color = 'var(--color-yellow-75)';
          aggressiveBtn.style.animation = 'none';
        }
        aggressiveBtn.style.borderColor = 'var(--color-yellow-75)';
      }
    }
    
    // Strategy states for each symbol (default: index 0 = 4-Hour)
    const strategyStates = {
      'BTCUSDT': 0,
      'ETHUSDT': 0,
      'SOLUSDT': 0
    };
    
    const strategyOptions = ['4h', 'Swing', 'TrendRider', 'Scalp', 'MicroScalp'];
    
    // Helper function to normalize confidence to 0-100 scale
    // Handles both 0-1 (decimal) and 0-100 (percentage) formats
    function normalizeConfidence(confidence) {
      if (confidence === null || confidence === undefined || isNaN(confidence)) return 0;
      if (typeof confidence !== 'number') return 0;
      // If already 0-100 scale, return as-is (clamped)
      if (confidence > 1) return Math.min(100, Math.max(0, Math.round(confidence)));
      // If 0-1 scale, convert to 0-100
      return Math.min(100, Math.max(0, Math.round(confidence * 100)));
    }
    
    // Trade Templates Configuration
    const tradeTemplates = {
      '4h': {
        label: '4H Set & Forget',
        anchorTimeframes: ['4h'],
        confirmTimeframes: ['1h'],
        entryTimeframes: ['15m', '5m'],
        minConfidence: 0.7,
        maxLeverage: 50,
        rrTargets: [1.0, 2.0],
        maxTradesPerDay: 1,
        displayName: '4 HOUR'
      },
      'Swing': {
        label: '3D / 1D / 4H Swing',
        anchorTimeframes: ['3d', '1d', '4h'],
        confirmTimeframes: ['1h'],
        entryTimeframes: ['15m', '5m'],
        minConfidence: 0.75,
        maxLeverage: 10,
        rrTargets: [3.0, 5.0],  // Minimum 3R as per text file
        maxHoldCandles: { '4h': 20 },
        displayName: 'SWING'
      },
      'TrendRider': {
        label: '4H/1H Trend Rider',
        anchorTimeframes: ['4h', '1h'],
        confirmTimeframes: ['15m', '5m'],
        entryTimeframes: ['15m', '5m'],
        minConfidence: 0.65,
        maxLeverage: 25,
        rrTargets: [2.0, 3.5],
        maxHoldCandles: { '1h': 24 },
        displayName: 'TREND RIDER'
      },
      'Scalp': {
        label: '4H+1H  15m/5m Scalp',
        anchorTimeframes: ['4h', '1h'],  // Both required as gatekeepers
        confirmTimeframes: ['15m', '5m'],  // Both must be in ENTRY_ZONE
        entryTimeframes: ['5m', '1m'],    // 1m as noise filter
        minConfidence: 0.65,
        maxLeverage: 25,
        rrTargets: [1.5, 2.5],  // Updated to match text file (1.5R-3R)
        maxHoldCandles: { '5m': 12 },
        displayName: 'SCALP'
      },
      'MicroScalp': {
        label: 'Micro-Scalp Mean Reversion',
        anchorTimeframes: ['1h'],  // 1H must be trending
        confirmTimeframes: ['15m', '5m'],  // Both within 0.25% of 21 EMA
        entryTimeframes: ['5m', '1m'],
        minConfidence: 0.5,
        maxLeverage: 10,
        rrTargets: [1.0, 1.5],  // Quick 1R-1.5R targets
        maxHoldCandles: { '5m': 6 },
        displayName: 'MICRO-SCALP'
      }
    };
    
    // Evaluate signal based on template
    // Evaluate 3D Swing Signal (frontend version matching backend logic)
    function evaluateSwingSignalFrontend(symbol, data) {
      try {
        const analysis = data.analysis;
        const tf3d = analysis['3d'];
        const tf1d = analysis['1d'];
        const tf4h = analysis['4h'];
        const currentPrice = data.currentPrice;
        
        // Guard: Need all required timeframes
        if (!tf3d || !tf1d || !tf4h || !currentPrice) {
          return {
            valid: false,
            direction: 'NO_TRADE',
            reason: 'Missing 3D/1D/4H data for swing analysis',
            confidence: 0,
            setupType: 'Swing'
          };
        }
      
      const trend3d = tf3d.indicators?.analysis?.trend;
      const trend1d = tf1d.indicators?.analysis?.trend;
      const trend4h = tf4h.indicators?.analysis?.trend;
      const pullback3d = tf3d.indicators?.pullback;
      const pullback1d = tf1d.indicators?.pullback;
      const pullback4h = tf4h.indicators?.pullback;
      const stoch3d = tf3d.indicators?.stoch;
      const stoch1d = tf1d.indicators?.stoch;
      const stoch4h = tf4h.indicators?.stoch;
      const ema21_4h = tf4h.indicators?.ema21;
      const ema21_1d = tf1d.indicators?.ema21;
      const swingLow3d = tf3d.indicators?.swingLow;
      const swingLow1d = tf1d.indicators?.swingLow;
      const swingHigh3d = tf3d.indicators?.swingHigh;
      const swingHigh1d = tf1d.indicators?.swingHigh;
      
      // Guard: Check if we have all critical data points
      if (!trend3d || !trend1d || !trend4h || !pullback3d || !pullback1d || !pullback4h ||
          !stoch3d || !stoch1d || !stoch4h || !ema21_4h || !ema21_1d) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Missing required data for swing analysis',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // GATEKEEPERS  WHEN SWING IS EVEN ALLOWED
      // 4H trend must NOT be FLAT for swing trades
      if (trend4h === 'FLAT') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Swing blocked: 4H trend is FLAT',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // 3D trend must NOT be FLAT
      if (trend3d === 'FLAT') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Swing blocked: 3D trend is FLAT',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // 1D trend must be either UPTREND or DOWNTREND
      if (trend1d === 'FLAT') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Swing blocked: 1D trend is FLAT',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // 3D pullback must be OVEREXTENDED or RETRACING
      if (pullback3d.state !== 'OVEREXTENDED' && pullback3d.state !== 'RETRACING') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Swing blocked: 3D pullback not in position',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // 1D pullback must be RETRACING or ENTRY_ZONE
      if (pullback1d.state !== 'RETRACING' && pullback1d.state !== 'ENTRY_ZONE') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Swing blocked: 1D pullback not in position',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // Check for LONG swing setup
      let direction = null;
      let reclaimLevel = null;
      let confidence = 70;
      
      const longConditionsCheck = 
        // 3D bullish or flat leaning bullish
        (trend3d === 'UPTREND' || (trend3d === 'FLAT' && (stoch3d?.condition === 'BULLISH' || stoch3d?.condition === 'OVERSOLD'))) &&
        // 1D trending down BUT with bullish pivot
        (trend1d === 'DOWNTREND' && (stoch1d?.condition === 'BULLISH' || (stoch1d?.k && stoch1d.k < 25))) &&
        // 3D overextended below
        (pullback3d?.state === 'OVEREXTENDED' && pullback3d?.distanceFrom21EMA && pullback3d.distanceFrom21EMA < -8) &&
        // 1D pullback OK
        (pullback1d?.state === 'RETRACING' || pullback1d?.state === 'ENTRY_ZONE') &&
        // Price near 1D EMA21
        (currentPrice >= (swingLow1d || ema21_1d * 0.90) && currentPrice <= ema21_1d * 1.02) &&
        // 4H confirmation
        ((trend4h === 'UPTREND' || (trend4h === 'FLAT' && stoch4h?.condition === 'BULLISH')) &&
         (pullback4h?.state === 'RETRACING' || pullback4h?.state === 'ENTRY_ZONE') &&
         Math.abs(currentPrice - ema21_4h) / currentPrice <= 0.01);
      
      if (longConditionsCheck) {
        direction = 'long';
        const swingLowToUse = swingLow1d || ema21_1d * 0.95;
        reclaimLevel = (swingLowToUse + ema21_1d) / 2;
        
        // Boost confidence
        if (stoch3d?.condition === 'OVERSOLD' && stoch1d?.condition === 'BULLISH') confidence += 10;
        if (Math.abs(currentPrice - ema21_4h) / currentPrice <= 0.005) confidence += 5;
        if (pullback3d?.distanceFrom21EMA && Math.abs(pullback3d.distanceFrom21EMA) >= 10) confidence += 5;
      }
      
      // Check for SHORT swing setup
      if (!direction) {
        const shortConditionsCheck = 
          // 3D bearish or flat leaning bearish
          (trend3d === 'DOWNTREND' || (trend3d === 'FLAT' && (stoch3d?.condition === 'BEARISH' || stoch3d?.condition === 'OVERBOUGHT'))) &&
          // 1D trending up BUT with bearish rejection
          (trend1d === 'UPTREND' && (stoch1d?.condition === 'BEARISH' || (stoch1d?.k && stoch1d.k > 75))) &&
          // 3D overextended above
          (pullback3d?.state === 'OVEREXTENDED' && pullback3d?.distanceFrom21EMA && pullback3d.distanceFrom21EMA > 8) &&
          // 1D pullback OK
          (pullback1d?.state === 'RETRACING' || pullback1d?.state === 'ENTRY_ZONE') &&
          // Price near 1D EMA21
          (currentPrice <= (swingHigh1d || ema21_1d * 1.10) && currentPrice >= ema21_1d * 0.98) &&
          // 4H confirmation
          ((trend4h === 'DOWNTREND' || (trend4h === 'FLAT' && stoch4h?.condition === 'BEARISH')) &&
           (pullback4h?.state === 'RETRACING' || pullback4h?.state === 'ENTRY_ZONE') &&
           Math.abs(currentPrice - ema21_4h) / currentPrice <= 0.01);
        
        if (shortConditionsCheck) {
          direction = 'short';
          const swingHighToUse = swingHigh1d || ema21_1d * 1.05;
          reclaimLevel = (swingHighToUse + ema21_1d) / 2;
          
          // Boost confidence
          if (stoch3d?.condition === 'OVERBOUGHT' && stoch1d?.condition === 'BEARISH') confidence += 10;
          if (Math.abs(currentPrice - ema21_4h) / currentPrice <= 0.005) confidence += 5;
          if (pullback3d?.distanceFrom21EMA && Math.abs(pullback3d.distanceFrom21EMA) >= 10) confidence += 5;
        }
      }
      
      // If no valid direction, return NO_TRADE
      if (!direction || !reclaimLevel) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: '3D + 1D swing conditions not met',
          confidence: 0,
          setupType: 'Swing'
        };
      }
      
      // Calculate SL/TP
      let stopLoss;
      if (direction === 'long') {
        const sl3d = swingLow3d || (ema21_1d * 0.90);
        const sl1d = swingLow1d || (ema21_1d * 0.92);
        stopLoss = Math.min(sl3d, sl1d);
      } else {
        const sh3d = swingHigh3d || (ema21_1d * 1.10);
        const sh1d = swingHigh1d || (ema21_1d * 1.08);
        stopLoss = Math.max(sh3d, sh1d);
      }
      
      // Entry zone
      const entryMin = reclaimLevel * 0.995;
      const entryMax = reclaimLevel * 1.005;
      const midEntry = (entryMin + entryMax) / 2;
      const R = Math.abs(midEntry - stopLoss);
      
      // Targets: 3R, 4R, 5R
      let tp1, tp2, tp3;
      if (direction === 'long') {
        tp1 = midEntry + (R * 3);
        tp2 = midEntry + (R * 4);
        tp3 = midEntry + (R * 5);
      } else {
        tp1 = midEntry - (R * 3);
        tp2 = midEntry - (R * 4);
        tp3 = midEntry - (R * 5);
      }
      
      confidence = Math.min(confidence, 90);
      
      return {
        valid: true,
        direction: direction,
        setupType: 'Swing',
        confidence: confidence / 100,
        reason: direction === 'long' ? 
          '3D oversold pivot + 1D reclaim + 4H confirmation' : 
          '3D overbought rejection + 1D distribution + 4H confirmation',
        entryZone: {
          min: parseFloat(entryMin.toFixed(2)),
          max: parseFloat(entryMax.toFixed(2))
        },
        stopLoss: parseFloat(stopLoss.toFixed(2)),
        targets: {
          tp1: parseFloat(tp1.toFixed(2)),
          tp2: parseFloat(tp2.toFixed(2)),
          tp3: parseFloat(tp3.toFixed(2))
        },
        riskReward: {
          tp1RR: 3.0,
          tp2RR: 4.0,
          tp3RR: 5.0
        }
      };
      } catch (error) {
        console.error(`Error evaluating Swing signal for ${symbol}:`, error);
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Error analyzing swing setup',
          confidence: 0,
          setupType: 'Swing'
        };
      }
    }
    
    /**
     * Get backend strategy for a symbol and template key
     * Returns strategy object from richSymbol.strategies, or null if not available
     * @param {string} symbol - Trading symbol
     * @param {string} templateKey - Frontend strategy key ('4h', 'Swing', 'Scalp', 'MicroScalp')
     * @returns {Object|null} Backend strategy object or null
     */
    function getBackendStrategy(symbol, templateKey) {
      const data = scanResults[symbol];
      if (!data) return null;
      
      const richSymbol = data?.richSymbol || data;
      if (!richSymbol?.strategies) return null;
      
      // Map frontend keys to backend strategy names
      const strategyMap = {
        '4h': 'TREND_4H',
        'Swing': 'SWING',
        'TrendRider': 'TREND_RIDER',
        'Scalp': 'SCALP_1H',
        'MicroScalp': 'MICRO_SCALP'
      };
      
      const backendStrategyName = strategyMap[templateKey];
      if (!backendStrategyName) return null;
      
      return richSymbol.strategies[backendStrategyName] || null;
    }
    
    /**
     * Get active signal for a symbol (uses bestSignal or selected strategy)
     * @param {string} symbol - Trading symbol
     * @param {string} templateKey - Optional: specific strategy key, otherwise uses bestSignal
     * @returns {Object|null} Signal object or null
     */
    function getActiveSignal(symbol, templateKey = null) {
      const data = scanResults[symbol];
      if (!data) return null;
      
      const richSymbol = data?.richSymbol || data;
      if (!richSymbol?.strategies) {
        // Fallback to legacy signal
        return data?.signal || data?.tradeSignal || null;
      }
      
      // If templateKey provided, use that strategy
      if (templateKey) {
        const strategy = getBackendStrategy(symbol, templateKey);
        if (strategy && strategy.valid) {
          return {
            valid: true,
            direction: strategy.direction,
            confidence: normalizeConfidence(strategy.confidence),
            reason: strategy.reason,
            entryZone: strategy.entryZone,
            stopLoss: strategy.stopLoss,
            invalidationLevel: strategy.invalidationLevel,
            targets: strategy.targets,
            riskReward: strategy.riskReward,
            setupType: templateKey
          };
        }
        return null;
      }
      
      // Use bestSignal if available
      if (richSymbol.bestSignal && richSymbol.strategies[richSymbol.bestSignal]) {
        const bestStrategy = richSymbol.strategies[richSymbol.bestSignal];
        if (bestStrategy && bestStrategy.valid) {
          return {
            valid: true,
            direction: bestStrategy.direction,
            confidence: bestStrategy.confidence,
            reason: bestStrategy.reason,
            entryZone: bestStrategy.entryZone,
            stopLoss: bestStrategy.stopLoss,
            invalidationLevel: bestStrategy.invalidationLevel,
            targets: bestStrategy.targets,
            riskReward: bestStrategy.riskReward,
            setupType: richSymbol.bestSignal === 'TREND_4H' ? '4h' :
                       richSymbol.bestSignal === 'SWING' ? 'Swing' :
                       richSymbol.bestSignal === 'SCALP_1H' ? 'Scalp' :
                       richSymbol.bestSignal === 'MICRO_SCALP' ? 'MicroScalp' : 'auto'
          };
        }
      }
      
      // Fallback to legacy signal
      return data?.signal || data?.tradeSignal || null;
    }
    
    // DEPRECATED: evaluateTemplateSignal - kept for backward compatibility but should not be used
    // All new code should use getBackendStrategy() or getActiveSignal()
    function evaluateTemplateSignal(symbol, templateKey) {
      try {
        const data = scanResults[symbol];
        if (!data || !data.analysis) return null;
        
        const template = tradeTemplates[templateKey];
        const analysis = data.analysis;
      
      // PRIORITY 1: Handle SWING trades (3D -> 1D -> 4H structure)
      if (templateKey === 'Swing') {
        return evaluateSwingSignalFrontend(symbol, data);
      }
      
      // CRITICAL: Check 4H trend first (gatekeeper for ALL other trades per text file)
      const tf4h = analysis['4h'];
      if (!tf4h || !tf4h.indicators || !tf4h.indicators.analysis) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'No 4H data available',
          confidence: 0
        };
      }
      
      const trend4h = tf4h.indicators.analysis.trend;
      
      // Block ALL trades if 4H is FLAT (text file rule: "4H must show clear direction")
      // This blocks Scalp and 4H trades, but Swing is handled separately above
      if (trend4h === 'FLAT') {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: '4H trend is FLAT - no trade allowed per strategy rules',
          confidence: 0
        };
      }
      
      // For SCALP: Require 4H AND 1H both have clear trends (text file: "4H+1H as gatekeepers")
      if (templateKey === 'Scalp') {
        const tf1h = analysis['1h'];
        if (!tf1h || !tf1h.indicators || !tf1h.indicators.analysis) {
          return {
            valid: false,
            direction: 'NO_TRADE',
            reason: 'No 1H data for scalp confirmation',
            confidence: 0
          };
        }
        
        const trend1h = tf1h.indicators.analysis.trend;
        if (trend1h === 'FLAT') {
          return {
            valid: false,
            direction: 'NO_TRADE',
            reason: 'Scalp blocked: 1H trend is FLAT',
            confidence: 0
          };
        }
        
        // Check 4H and 1H are aligned
        if (trend4h === 'UPTREND' && trend1h === 'DOWNTREND') {
          return {
            valid: false,
            direction: 'NO_TRADE',
            reason: 'Scalp blocked: 4H/1H trends not aligned',
            confidence: 0
          };
        }
        if (trend4h === 'DOWNTREND' && trend1h === 'UPTREND') {
          return {
            valid: false,
            direction: 'NO_TRADE',
            reason: 'Scalp blocked: 4H/1H trends not aligned',
            confidence: 0
          };
        }
      }
      
      // Check anchor timeframe trends (now that 4H gatekeeper passed)
      let anchorTrend = null;
      for (const tf of template.anchorTimeframes) {
        const tfData = analysis[tf];
        if (tfData && tfData.indicators && tfData.indicators.analysis) {
          const trend = tfData.indicators.analysis.trend;
          if (trend && trend !== 'FLAT') {
            anchorTrend = trend;
            break;
          }
        }
      }
      
      if (!anchorTrend) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: `No clear trend on ${template.anchorTimeframes.join('/')} anchor`,
          confidence: 0
        };
      }
      
      // Check confirmation timeframes alignment
      let confirmsAlign = true;
      for (const tf of template.confirmTimeframes) {
        const tfData = analysis[tf];
        if (tfData && tfData.indicators && tfData.indicators.analysis) {
          const trend = tfData.indicators.analysis.trend;
          if (trend && trend !== anchorTrend && trend !== 'FLAT') {
            confirmsAlign = false;
            break;
          }
        }
      }
      
      if (!confirmsAlign) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: `Confirmation timeframes don't align with ${anchorTrend}`,
          confidence: 0
        };
      }
      
      // If we have a valid 4h trade signal, use it
      const originalSignal = data.signal || data.tradeSignal;
      if (originalSignal && originalSignal.valid && templateKey === '4h') {
        return originalSignal;
      }
      
      // For Swing/Scalp, create a basic signal
      const direction = anchorTrend === 'UPTREND' ? 'long' : 'short';
      let confidence = 0.3; // Lowered base confidence (was 0.5)
      
      // Check pullback state on 4H (critical for entry validity)
      const pullbackState4h = tf4h.indicators.analysis.pullbackState;
      if (pullbackState4h === 'OVEREXTENDED') {
        // Price too far from 21 EMA - block trade per text file
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Price OVEREXTENDED from 4H 21 EMA - no entry',
          confidence: 0
        };
      }
      
      // Increase confidence based on pullback state
      if (pullbackState4h === 'ENTRY_ZONE') {
        confidence += 0.25;  // Perfect entry zone
      } else if (pullbackState4h === 'RETRACING') {
        confidence += 0.10;  // Approaching, but not perfect
      }
      
      // Increase confidence based on confirmation alignment
      if (confirmsAlign) confidence += 0.15;
      
      // Check stoch alignment for additional confidence
      const stoch4h = tf4h.indicators.stochRSI;
      if (stoch4h && stoch4h.condition) {
        if (direction === 'long' && stoch4h.condition === 'BULLISH') {
          confidence += 0.10;
        } else if (direction === 'short' && stoch4h.condition === 'BEARISH') {
          confidence += 0.10;
        } else if (stoch4h.condition !== 'NEUTRAL') {
          // Stoch fighting the trade direction
          confidence -= 0.15;
        }
      }
      
      // Calculate entry zone based on current price and 21 EMA
      const primaryTf = template.anchorTimeframes[0];
      const primaryData = analysis[primaryTf];
      let entryZone = originalSignal?.entryZone || null;
      let stopLoss = originalSignal?.stopLoss || null;
      let invalidationLevel = originalSignal?.invalidationLevel || null;
      
      if (primaryData && primaryData.indicators && primaryData.indicators.ema) {
        const ema21 = primaryData.indicators.ema.ema21;
        const currentPrice = data.currentPrice;
        const distanceFrom21 = Math.abs(
          ((currentPrice - ema21) / currentPrice) * 100
        );
        
        // Only give bonus if very close to EMA
        if (distanceFrom21 < 0.5) {
          confidence += 0.15;
        } else if (distanceFrom21 < 1.5) {
          confidence += 0.08;
        }
        // If distance > 2%, reduce confidence
        else if (distanceFrom21 > 2.5) {
          confidence -= 0.10;
        }
        
        // Calculate entry zone around 21 EMA (0.4%)
        if (!entryZone) {
          entryZone = {
            min: ema21 * 0.996,
            max: ema21 * 1.004
          };
        }
        
        // Calculate stop loss using setupType-conditional logic (matching text file)
        if (!stopLoss) {
          let slStructure = null;
          
          if (templateKey === 'Swing') {
            // Swing: Use HTF (3D or 1D) structure
            slStructure = analysis['3d']?.indicators?.swings || 
                         analysis['1d']?.indicators?.swings || 
                         analysis['4h']?.indicators?.swings;
          } else if (templateKey === 'Scalp') {
            // Scalp: Use LTF (5m or 15m) structure
            slStructure = analysis['5m']?.indicators?.swings || 
                         analysis['15m']?.indicators?.swings || 
                         analysis['4h']?.indicators?.swings;
          } else {
            // 4H: Use 4H structure
            slStructure = analysis['4h']?.indicators?.swings;
          }
          
          if (slStructure) {
            if (direction === 'long') {
              stopLoss = slStructure.swingLow || (currentPrice * 0.95);
              invalidationLevel = slStructure.swingLow;
            } else {
              stopLoss = slStructure.swingHigh || (currentPrice * 1.05);
              invalidationLevel = slStructure.swingHigh;
            }
          } else {
            stopLoss = direction === 'long' ? (currentPrice * 0.95) : (currentPrice * 1.05);
          }
        }
      }
      
      // DO NOT force confidence to minimum - let validation reject low confidence trades
      // Clamp confidence between 0 and 1
      confidence = Math.max(0, Math.min(confidence, 0.95));
      
      // If confidence below minimum, return NO TRADE
      if (confidence < template.minConfidence) {
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: `Confidence ${normalizeConfidence(confidence)}% below minimum ${normalizeConfidence(template.minConfidence)}% for ${templateKey}`,
          confidence: confidence
        };
      }
      
      // Ensure entryZone is set (fallback to current price 0.4%)
      if (!entryZone && data.currentPrice) {
        entryZone = {
          min: data.currentPrice * 0.996,
          max: data.currentPrice * 1.004
        };
      }
      
      // Calculate targets based on R:R ratios and entry/SL
      const entryMid = entryZone ? (entryZone.min + entryZone.max) / 2 : data.currentPrice;
      const risk = direction === 'long' ? 
        (entryMid - stopLoss) : 
        (stopLoss - entryMid);
      
      const tp1 = direction === 'long' ? 
        entryMid + (risk * template.rrTargets[0]) : 
        entryMid - (risk * template.rrTargets[0]);
      
      const tp2 = direction === 'long' ? 
        entryMid + (risk * template.rrTargets[1]) : 
        entryMid - (risk * template.rrTargets[1]);
      
      return {
        valid: true,  // Already validated above
        direction: direction,
        setupType: templateKey,
        confidence: confidence,  // Already clamped above
        reason: `${template.label}: ${anchorTrend}, confidence ${normalizeConfidence(confidence)}%`,
        entryZone: entryZone,
        stopLoss: stopLoss,
        invalidationLevel: invalidationLevel,  // Added: HTF/LTF invalidation
        targets: {
          tp1: tp1 ? parseFloat(tp1.toFixed(2)) : null,
          tp2: tp2 ? parseFloat(tp2.toFixed(2)) : null
        },
        riskReward: {
          tp1RR: template.rrTargets[0],
          tp2RR: template.rrTargets[1]
        },
        riskAmount: risk ? parseFloat(risk.toFixed(2)) : null  // Added: dollar risk
      };
      } catch (error) {
        console.error(`Error evaluating ${templateKey} signal for ${symbol}:`, error);
        return {
          valid: false,
          direction: 'NO_TRADE',
          reason: 'Error analyzing data',
          confidence: 0
        };
      }
    }
    
    // Set specific strategy (replacing cycleStrategy)
    function setStrategy(symbol, strategyIndex) {
      strategyStates[symbol] = strategyIndex;
      
      // Update button appearance
      updateStrategyButtons(symbol);
      
      // Map frontend strategy keys to backend strategy names
      const strategyKeyMap = {
        '4h': 'TREND_4H',
        'Swing': 'SWING',
        'Scalp': 'SCALP_1H',
        'MicroScalp': 'MICRO_SCALP'
      };
      
      const templateKey = strategyOptions[strategyIndex];
      const backendStrategyName = strategyKeyMap[templateKey] || 'TREND_4H';
      
      // Get backend strategy directly from rich symbol (NO template evaluation)
      const data = scanResults[symbol];
      const richSymbol = data?.richSymbol || data;
      const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
      
      // Convert backend strategy to frontend signal format
      let templateSignal = null;
      if (backendStrategy && backendStrategy.valid) {
        templateSignal = {
          valid: true,
          direction: backendStrategy.direction,
          confidence: backendStrategy.confidence,
          reason: backendStrategy.reason,
          entryZone: backendStrategy.entryZone,
          stopLoss: backendStrategy.stopLoss,
          invalidationLevel: backendStrategy.invalidationLevel,
          targets: backendStrategy.targets,
          riskReward: backendStrategy.riskReward,
          setupType: templateKey
        };
      } else {
        templateSignal = {
          valid: false,
          direction: 'NO_TRADE',
          reason: backendStrategy?.reason || 'No trade setup available',
          confidence: 0,
          setupType: templateKey
        };
      }
      
      // Update signal display with template-specific evaluation
      updateSignalForTemplate(symbol, templateKey, templateSignal);
      
      // Update entry price display
      updateEntryPrice(symbol, templateSignal);
      
      // Update row glow animation based on active signal (template or API)
      const row = document.getElementById(`row-${symbol}`);
      if (row) {
        // Remove existing trade classes
        row.classList.remove('has-trade-long', 'has-trade-short');
        
        // Use backend strategy signal (already extracted above)
        const activeSignal = templateSignal;
        
        // Add appropriate class if there's any valid trade
        if (activeSignal && activeSignal.valid) {
          const tradeClass = (activeSignal.direction === 'long' || activeSignal.direction === 'LONG') ? 'has-trade-long' : 'has-trade-short';
          row.classList.add(tradeClass);
        }
      }
      
      // If details row is expanded, regenerate it with new signal
      const detailsRow = document.getElementById(`details-${symbol}`);
      if (detailsRow && detailsRow.classList.contains('expanded')) {
        const data = scanResults[symbol];
        if (data) {
          const newDetailsRow = createDetailsRow(symbol, data);
          detailsRow.innerHTML = newDetailsRow.innerHTML;
        }
      }
      
      // Auto-trigger AI review when strategy changes
      getAIReview(symbol, true);  // isAutoTrigger = true (silent mode)
    }
    
    // Update entry price display
    function updateEntryPrice(symbol, templateSignal) {
      const data = scanResults[symbol];
      
      // Get active signal from backend (use provided templateSignal if it's from backend, otherwise get from backend)
      let tradeSignal = null;
      if (templateSignal && templateSignal.valid) {
        tradeSignal = templateSignal;
      } else {
        // Get from backend using current selected strategy
        const currentStrategyIndex = strategyStates[symbol] || 0;
        const currentStrategy = strategyOptions[currentStrategyIndex];
        tradeSignal = getActiveSignal(symbol, currentStrategy);
        
        // Fallback to legacy signal if backend not available
        if (!tradeSignal) {
          tradeSignal = data?.signal || data?.tradeSignal;
        }
      }
      
      let entryPriceDisplay = 'NO TRADE';
      let hasSignal = false;
      
      if (tradeSignal && tradeSignal.valid) {
        // Handle both API format (entry_zone) and template format (entryZone)
        const entryZone = tradeSignal.entryZone || tradeSignal.entry_zone;
        
        if (entryZone && entryZone.min && entryZone.max) {
          const entryMin = entryZone.min;
          const entryMax = entryZone.max;
          // For LONG: lowest entry (entryMin), for SHORT: highest entry (entryMax)
          const direction = tradeSignal.direction || 'long';
          const recommendedEntry = (direction === 'long' || direction === 'LONG') ? entryMin : entryMax;
          entryPriceDisplay = `$${parseFloat(recommendedEntry).toLocaleString()}`;
          hasSignal = true;
        }
      }
      // If no valid signal, show "NO TRADE"
      
      // Update mobile entry price (under coin name) - this should show current PRICE, not entry
      const row = document.getElementById(`row-${symbol}`);
      if (row) {
        const mobilePrice = row.querySelector('.entry-price-mobile');
        if (mobilePrice && data?.currentPrice) {
          mobilePrice.textContent = `$${data.currentPrice.toLocaleString()}`;
        }
        
        // Update desktop entry price column
        const desktopEntry = row.querySelector('.entry-price-desktop div');
        if (desktopEntry && data?.currentPrice) {
          desktopEntry.textContent = `$${data.currentPrice.toLocaleString()}`;
        }
        
        // Update the actual entry column (3rd column)
        const entryCell = row.querySelectorAll('td')[2];
        if (entryCell) {
          const entryDiv = entryCell.querySelector('div');
          if (entryDiv) {
            entryDiv.textContent = entryPriceDisplay;
            // Add opacity if no signal
            entryDiv.style.opacity = hasSignal ? '1' : '0.7';
          }
        }
      }
    }
    
    // Update signal text based on current strategy
    function updateSignalText(symbol) {
      const data = scanResults[symbol];
      if (!data) return;
      
      const signal = data.signal || data.tradeSignal;
      const hasValidTrade = signal && signal.valid;
      
      // Only update if NO TRADE
      if (!hasValidTrade) {
        const currentStrategyIndex = strategyStates[symbol] || 0;
        const currentStrategy = strategyOptions[currentStrategyIndex];
        const strategyNames = {
          '4h': '4 HOUR',
          'Swing': 'SWING',
          'Scalp': 'SCALP'
        };
        const strategyName = strategyNames[currentStrategy] || '4 HOUR';
        
        // Calculate readiness
        const readiness = calculateSignalReadiness(data);
        
        // Show readiness only if on 4h strategy
        const showReadiness = currentStrategy === '4h';
        const readinessHtml = showReadiness ? 
          `<div class="text-xs ${readiness.class}" style="font-size: 0.65rem; white-space: nowrap;">${readiness.text}</div>` : 
          `<div class="text-xs status-neutral">-</div>`;
        
        const signalElement = document.getElementById(`signal-${symbol}`);
        if (signalElement) {
          signalElement.innerHTML = `
            <div class="status-neutral" style="font-size: 0.65rem; white-space: nowrap;">NO ${strategyName}</div>
            ${readinessHtml}
          `;
        }
      }
    }
    
    // Update signal display based on template evaluation
    function updateSignalForTemplate(symbol, templateKey, templateSignal) {
      if (!templateSignal) return;
      
      const template = tradeTemplates[templateKey];
      if (!template) {
        console.error('Template not found for key:', templateKey);
        return;
      }
      
      const signalElement = document.getElementById(`signal-${symbol}`);
      if (!signalElement) return;
      
      if (templateSignal.valid) {
        // Valid trade signal - simple display matching price font size
        const dirClass = templateSignal.direction === 'long' ? 'status-long' : 'status-short';
        signalElement.style.textAlign = 'center';
        signalElement.innerHTML = `
          <div class="${dirClass}" style="font-size: 0.875rem; white-space: nowrap;">${template.displayName} TRADE</div>
        `;
      } else {
        // No trade signal
        signalElement.style.textAlign = 'center';
        signalElement.innerHTML = `
          <div class="status-neutral" style="font-size: 0.875rem; white-space: nowrap;">NO TRADE</div>
        `;
      }
    }
    
    // Update strategy button appearance
    function updateStrategyButtons(symbol) {
      console.log(` Updating buttons for ${symbol}`);
      
      const activeIndex = strategyStates[symbol];
      const data = scanResults[symbol];
      
      if (!data) {
        console.warn(`No data for ${symbol}`);
        return;
      }
      
      // Get API signal as fallback
      const apiSignal = data?.signal || data?.tradeSignal;
      
      // Debug logging for Bitcoin
      if (symbol === 'BTCUSDT') {
        console.log('=== BITCOIN BUTTON UPDATE ===');
        console.log('Active index:', activeIndex);
        console.log('API Signal:', apiSignal);
        console.log('Full data:', data);
      }
      
      // Evaluate ALL strategies for color coding
      // For each strategy, use template signal if valid, otherwise check if API signal matches that strategy
      // Get ALL strategies from backend for color coding (NO template evaluation)
      const richSymbol = data?.richSymbol || data;
      const strategy4h = getBackendStrategy(symbol, '4h');
      const strategySwing = getBackendStrategy(symbol, 'Swing');
      const strategyScalp = getBackendStrategy(symbol, 'Scalp');
      
      const strategy4hSignal = strategy4h && strategy4h.valid ? {
        valid: true,
        direction: strategy4h.direction,
        confidence: strategy4h.confidence
      } : null;
      
      const strategySwingSignal = strategySwing && strategySwing.valid ? {
        valid: true,
        direction: strategySwing.direction,
        confidence: strategySwing.confidence
      } : null;
      
      const strategyScalpSignal = strategyScalp && strategyScalp.valid ? {
        valid: true,
        direction: strategyScalp.direction,
        confidence: strategyScalp.confidence
      } : null;
      
      // Get micro-scalp signal from API data
      const microScalpSignal = data && data.microScalp && data.microScalp.valid ? {
        valid: true,
        direction: data.microScalp.direction,
        confidence: data.microScalp.confidence
      } : null;
      
      const strategySignals = [strategy4hSignal, strategySwingSignal, strategyScalpSignal, microScalpSignal];
      
      // Update each button
      strategyOptions.forEach((option, index) => {
        const button = document.getElementById(`strategy-btn-${symbol}-${index}`);
        if (!button) {
          console.warn(`Button not found: strategy-btn-${symbol}-${index}`);
          return;
        }
        
        const signal = strategySignals[index];
        const hasValidTrade = signal && signal.valid;
        
        // Update background and color based on state
        const isLong = signal?.direction === 'long' || signal?.direction === 'LONG';
        const isShort = signal?.direction === 'short' || signal?.direction === 'SHORT';
        
        if (symbol === 'BTCUSDT' && index === 0) {
          console.log('Bitcoin 4H button update:');
          console.log('  - Index:', index, 'Active:', activeIndex);
          console.log('  - Signal:', signal);
          console.log('  - hasValidTrade:', hasValidTrade);
          console.log('  - isLong:', isLong, 'isShort:', isShort);
          console.log('  - Will apply:', index === activeIndex && hasValidTrade ? 'COLORED BG' : 'transparent');
        }
        
        if (index === activeIndex && hasValidTrade) {
          // Active button with valid trade: colored background, yellow-white text
          button.style.backgroundColor = isLong ? '#10b981' : '#ef4444';
          button.style.color = 'var(--color-yellow-75)';
          if (symbol === 'BTCUSDT' && index === 0) {
            console.log('   Applied colored background:', isLong ? 'GREEN' : 'RED');
          }
        } else if (index === activeIndex && !hasValidTrade) {
          // Active button without trade: yellow-white background, grey text
          button.style.backgroundColor = 'var(--color-yellow-75)';
          button.style.color = '#6b7280';
        } else if (hasValidTrade) {
          // Inactive button with valid trade: transparent background, colored text
          button.style.backgroundColor = 'transparent';
          button.style.color = isLong ? '#10b981' : '#ef4444';
        } else {
          // Inactive button without trade: transparent background, grey text
          button.style.backgroundColor = 'transparent';
          button.style.color = '#6b7280';
        }
      });
    }

    // Auto-trigger AI analysis for MAJOR COINS ONLY (BTC, ETH, SOL)
    async function autoTriggerAIAnalysis() {
      console.log('Starting automatic AI analysis for major coins only...');
      
      // Only analyze the 3 major coins (not starred coins)
      const majorCoins = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      
      // Trigger AI analysis for each major coin with current strategy (default: 4h)
      for (const symbol of majorCoins) {
        // Only analyze if we have data for this coin
        if (!scanResults[symbol]) {
          console.log(`Skipping ${symbol} - no data available`);
          continue;
        }
        
        try {
          console.log(`Auto-triggering AI for ${symbol}...`);
          await getAIReview(symbol, true);  // isAutoTrigger = true (silent mode)
          
          // Small delay between requests to avoid overwhelming the API
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.error(`Auto AI analysis failed for ${symbol}:`, error);
          // Continue with next symbol even if one fails
        }
      }
      
      console.log(' Automatic AI analysis complete for major coins (BTC, ETH, SOL)');
    }
    
    // Auto-run scan on page load
    // 1-minute candle timer
    function updateCandleTimer() {
      const now = new Date();
      const seconds = now.getSeconds();
      const milliseconds = now.getMilliseconds();
      
      // Calculate time remaining until next minute
      const secondsRemaining = 60 - seconds - (milliseconds / 1000);
      const percentageRemaining = (secondsRemaining / 60) * 100;
      
      // Update progress bar width
      const timerBar = document.getElementById('candle-timer-bar');
      if (timerBar) {
        timerBar.style.width = `${percentageRemaining}%`;
      }
    }
    
    // 4-hour candle timer
    function update4HTimer() {
      const now = new Date();
      const minutes = now.getMinutes();
      const seconds = now.getSeconds();
      const milliseconds = now.getMilliseconds();
      const hours = now.getUTCHours(); // Use UTC for consistency with trading
      
      // Calculate minutes into current 4H period
      const minutesInto4H = ((hours % 4) * 60) + minutes;
      const secondsInto4H = (minutesInto4H * 60) + seconds + (milliseconds / 1000);
      
      // Total seconds in 4 hours = 14400
      const totalSeconds4H = 4 * 60 * 60;
      const secondsRemaining = totalSeconds4H - secondsInto4H;
      const percentageRemaining = (secondsRemaining / totalSeconds4H) * 100;
      
      // Update progress bar width
      const timer4H = document.getElementById('4h-timer-bar');
      if (timer4H) {
        timer4H.style.width = `${percentageRemaining}%`;
      }
    }
    
    // Update active signals and market bias
    function updateTradingIndicators() {
      let activeSignalsCount = 0;
      let longCount = 0;
      let shortCount = 0;
      
      console.log('=== Counting All Signals Across BOTH Modes ===');
      
      // Helper function to count signals from a result set
      const countSignalsFromResults = (results, modeName) => {
        let modeCount = 0;
        Object.entries(results).forEach(([symbol, data]) => {
          const strategies = ['4h', 'Swing', 'Scalp', 'MicroScalp'];
          const apiSignal = data.signal || data.tradeSignal;
          
          strategies.forEach(strategy => {
            // Temporarily set scanResults to this mode's data for evaluation
            const originalScanResults = scanResults;
            scanResults = results;
            
            // Get backend strategy directly (NO template evaluation)
            const strategyMap = {
              '4h': 'TREND_4H',
              'Swing': 'SWING',
              'Scalp': 'SCALP_1H',
              'MicroScalp': 'MICRO_SCALP'
            };
            const backendStrategyName = strategyMap[strategy];
            const richSymbol = results[symbol]?.richSymbol || results[symbol];
            const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
            
            // Restore original scanResults
            scanResults = originalScanResults;
            
            const templateSignal = backendStrategy && backendStrategy.valid ? {
              valid: true,
              direction: backendStrategy.direction,
              confidence: backendStrategy.confidence
            } : null;
            
            if (templateSignal && templateSignal.valid) {
              activeSignalsCount++;
              modeCount++;
              const isLong = templateSignal.direction === 'long' || templateSignal.direction === 'LONG';
              console.log(` ${symbol} ${strategy} [${modeName}]: ${templateSignal.direction} (Total: ${activeSignalsCount})`);
              if (isLong) {
                longCount++;
              } else {
                shortCount++;
              }
            }
          });
        });
        return modeCount;
      };
      
      // Count from BOTH modes
      const aggressiveCount = Object.keys(scanResultsAggressive).length > 0 ? 
        countSignalsFromResults(scanResultsAggressive, 'AGGRESSIVE') : 0;
      const safeCount = Object.keys(scanResultsSafe).length > 0 ? 
        countSignalsFromResults(scanResultsSafe, 'SAFE') : 0;
      
      console.log(`\n Total Signals: ${activeSignalsCount} (${longCount}L | ${shortCount}S)`);
      console.log(`   Aggressive: ${aggressiveCount} | Safe: ${safeCount}`);
      
      // Update Active Signals (always yellow-white)
      const signalsCountEl = document.getElementById('signals-count');
      if (signalsCountEl) {
        signalsCountEl.textContent = `${activeSignalsCount} SIGNAL${activeSignalsCount !== 1 ? 'S' : ''}`;
        signalsCountEl.style.color = 'var(--color-yellow-75)';
      }
      
      // Update mode button counts
      const aggressiveCountEl = document.getElementById('aggressive-count');
      const safeCountEl = document.getElementById('safe-count');
      if (aggressiveCountEl) aggressiveCountEl.textContent = aggressiveCount;
      if (safeCountEl) safeCountEl.textContent = safeCount;
    }
    
    // Start timers
    function startCandleTimers() {
      updateCandleTimer();
      update4HTimer();
      setInterval(updateCandleTimer, 500); // Update twice per second for smooth animation
      setInterval(update4HTimer, 1000); // Update every second for 4H timer
    }

    // AI Market Review (replacing news marquee)
    let marketReviewCache = 'Analyzing Market Sentiment';
    
    // Get AI market review from all trades data
    async function getAIMarketReview() {
      try {
        console.log(' Requesting AI market review...');
        console.log('Current scanResults:', Object.keys(scanResults));
        console.log('Safe results:', Object.keys(scanResultsSafe));
        console.log('Aggressive results:', Object.keys(scanResultsAggressive));
        
        // Store current state
        const originalScanResults = scanResults;
        
        // Collect all trades from both modes
        const allTradesData = {
          SAFE_MODE: {},
          AGGRESSIVE_MODE: {}
        };
        
        const strategyKeys = ['4h', 'Swing', 'Scalp', 'MicroScalp'];
        const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
        
        // SAFE MODE
        scanResults = scanResultsSafe;
        for (const symbol of symbols) {
          const safeData = scanResultsSafe[symbol];
          if (!safeData) continue;
          
          allTradesData.SAFE_MODE[symbol] = {
            currentPrice: safeData.currentPrice,
            strategies: {}
          };
          
          strategyKeys.forEach((strategyKey) => {
            // Get backend strategy directly (NO template evaluation)
            const strategyMap = {
              '4h': 'TREND_4H',
              'Swing': 'SWING',
              'Scalp': 'SCALP_1H',
              'MicroScalp': 'MICRO_SCALP'
            };
            const backendStrategyName = strategyMap[strategyKey];
            const richSymbol = safeData?.richSymbol || safeData;
            const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
            const signal = backendStrategy && backendStrategy.valid ? {
              valid: true,
              direction: backendStrategy.direction,
              setupType: strategyKey,
              confidence: backendStrategy.confidence
            } : null;
            if (signal && signal.valid) {
              allTradesData.SAFE_MODE[symbol].strategies[strategyKey] = {
                direction: signal.direction,
                setupType: signal.setupType,
                confidence: normalizeConfidence(signal.confidence) + '%'
              };
            }
          });
        }
        
        // AGGRESSIVE MODE
        scanResults = scanResultsAggressive;
        for (const symbol of symbols) {
          const aggressiveData = scanResultsAggressive[symbol];
          if (!aggressiveData) continue;
          
          // Use buildRichSymbolFromScanResults to get all new context
          const richSymbol = buildRichSymbolFromScanResults(symbol, 'AGGRESSIVE') || aggressiveData?.richSymbol || aggressiveData;
          
          allTradesData.AGGRESSIVE_MODE[symbol] = {
            currentPrice: aggressiveData.currentPrice || richSymbol.currentPrice,
            htfBias: richSymbol.htfBias || aggressiveData.htfBias || { direction: 'neutral', confidence: 0, source: 'none' },
            timeframes: richSymbol.timeframes || {},
            marketData: richSymbol.marketData || aggressiveData.marketData || null,
            dflowData: richSymbol.dflowData || aggressiveData.dflowData || null,
            strategies: {}
          };
          
          strategyKeys.forEach((strategyKey) => {
            // Get backend strategy directly (NO template evaluation)
            const strategyMap = {
              '4h': 'TREND_4H',
              'Swing': 'SWING',
              'Scalp': 'SCALP_1H',
              'MicroScalp': 'MICRO_SCALP'
            };
            const backendStrategyName = strategyMap[strategyKey];
            const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
            const signal = backendStrategy && backendStrategy.valid ? {
              valid: true,
              direction: backendStrategy.direction,
              setupType: strategyKey,
              confidence: backendStrategy.confidence
            } : null;
            if (signal && signal.valid) {
              allTradesData.AGGRESSIVE_MODE[symbol].strategies[strategyKey] = {
                direction: signal.direction,
                setupType: signal.setupType,
                confidence: normalizeConfidence(signal.confidence) + '%'
              };
            }
          });
          
          // Verify new context is included (for debugging)
          console.log(` [getAIMarketReview] AGGRESSIVE ${symbol}: Context includes htfBias:`, !!allTradesData.AGGRESSIVE_MODE[symbol].htfBias);
          console.log(` [getAIMarketReview] AGGRESSIVE ${symbol}: Context includes timeframes:`, !!allTradesData.AGGRESSIVE_MODE[symbol].timeframes);
          console.log(` [getAIMarketReview] AGGRESSIVE ${symbol}: Context includes marketData:`, !!allTradesData.AGGRESSIVE_MODE[symbol].marketData);
          console.log(` [getAIMarketReview] AGGRESSIVE ${symbol}: Context includes dflowData:`, !!allTradesData.AGGRESSIVE_MODE[symbol].dflowData);
        }
        
        // Restore original scan results
        scanResults = originalScanResults;
        
        // Calculate tone for market review using tone interpolation module
        // Aggregate scores across all symbols
        let aggregateRiskScore = 0;
        let aggregateTrendScore = 0;
        let aggregateSignalScore = 0;
        let symbolCount = 0;
        
        for (const symbol of symbols) {
          const safeData = scanResultsSafe[symbol];
          const aggressiveData = scanResultsAggressive[symbol];
          const data = safeData || aggressiveData;
          
          if (data) {
            const scores = calculateToneScores(data, symbol);
            aggregateRiskScore += scores.riskScore;
            aggregateTrendScore += scores.trendScore;
            aggregateSignalScore += scores.signalScore;
            symbolCount++;
          }
        }
        
        // Average scores across symbols
        if (symbolCount > 0) {
          aggregateRiskScore /= symbolCount;
          aggregateTrendScore /= symbolCount;
          aggregateSignalScore /= symbolCount;
        }
        
        const marketTone = getInterpolatedTone({
          riskScore: aggregateRiskScore,
          trendScore: aggregateTrendScore,
          signalScore: aggregateSignalScore,
          overrideTone: null,
          allowOverride: true
        });
        
        console.log(` [getAIMarketReview] Market tone: ${marketTone.finalTone} (weight: ${marketTone.weight.toFixed(2)})`);
        
        // Build system prompt with tone guidance
        const toneGuidance = marketTone.softToneHints.secondary 
          ? `Tone: ${marketTone.finalTone} (blend with ${marketTone.softToneHints.secondary} at ${(marketTone.softToneHints.blendRatio * 100).toFixed(0)}% strength).`
          : `Tone: ${marketTone.finalTone} (${(marketTone.weight * 100).toFixed(0)}% strength).`;
        
        // Call AI agent for market review
        console.log(' Sending request to /api/agent-review with trades data');
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            tradesData: allTradesData,
            systemPrompt: `When analyzing trade JSON, respond with direct, concise market insight. Avoid technical jargon unless necessary. Focus on what the market is behaving like rather than what indicators say. Identify whether assets influence each other and call out any shared momentum or correlation. If no trades appear, state why the structure isn't clean. ${toneGuidance} Tone should be confident, observational, and actionablesimilar to a seasoned trader explaining what they see without fluff. Always keep responses tight, honest, and rooted in the bigger picture sentiment behind the data, not just the numbers. Keep your response to 1-2 sentences maximum.`
          })
        });
        
        console.log(' Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(' API error response:', errorText);
          throw new Error(`AI review failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        console.log(' API response data:', data);
        
        if (data.review) {
          marketReviewCache = data.review;
          updateMarketReviewDisplay();
          console.log(' AI market review received:', data.review);
        } else {
          console.warn(' No review in response:', data);
          marketReviewCache = 'Market analysis temporarily unavailable';
          updateMarketReviewDisplay();
        }
      } catch (error) {
        console.error(' Error getting AI market review:', error);
        console.error('Error details:', error.message, error.stack);
        marketReviewCache = 'Market analysis temporarily unavailable';
        updateMarketReviewDisplay();
      }
    }
    
    function updateMarketReviewDisplay() {
      const marqueeContent = document.getElementById('newsMarqueeContent');
      
      if (!marqueeContent) {
        console.error(' Marquee content element not found!');
        return;
      }
      
      // Display as a scrolling message
      marqueeContent.innerHTML = `
        <span style="padding-right: 4rem;">${marketReviewCache}</span>
        <span style="padding-right: 4rem;">${marketReviewCache}</span>
      `;
      
      console.log(' Market review updated');
    }
    
    // Market Pulse Intelligence Cache
    const pulseCache = new Map(); // { cacheKey: { pulse, timestamp, contextHash } }
    const PULSE_CACHE_TTL = 60000; // 60 seconds
    
    // Dev-only prompt tuning configuration (set to false in production)
    const PULSE_DEV_CONFIG = {
      enabled: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
      systemPromptTone: 'neutral', // Override default tone globally
      temperatureCap: 0.8, // Maximum temperature allowed
      toneFlavor: null, // 'relatable' | 'pro' | 'hype' | 'coach' | null (uses default)
      messageFormat: {
        dashboard: 'normal', // 'short' | 'normal' | 'detailed'
        'trade-panel': 'normal',
        marquee: 'short'
      }
    };
    
    // Voice Packs - Natural Language Tone Mapping
    const VOICE_PACKS = {
      relatable: {
        name: 'Relatable',
        description: 'Casual, conversational tone like explaining to a peer',
        systemPromptSuffix: `Keep your tone casual and conversational. Speak like a human trader who's explaining things to a peer, not a bot or analyst. Avoid jargon. Use phrases like "the market's been acting..." or "feels like...". Make it feel natural and relatable.`,
        mappings: {
          'HTF bias flipped to short (85%)': "Momentum's shifted down latelyit's looking pretty heavy.",
          'HTF bias is long with (\\d+)% confidence': (match, p1) => `Looks like the bias is to the upside (${p1}% confidence)`,
          'HTF bias is short with (\\d+)% confidence': (match, p1) => `Bias has shifted down (${p1}% confidence)`,
          'No valid signal due to 4H trend = flat': "Nothing clean showing up yet. Market's kinda sideways.",
          '4H trend is FLAT': "4H is just chopping aroundno clear direction.",
          'Entry zone: ([\\d,]+)([\\d,]+)': (match, p1, p2) => `Best spot to jump in looks around the ${p1.replace(/,/g, '')} to ${p2.replace(/,/g, '')} area.`,
          'Entry zone is ([\\d,]+) to ([\\d,]+)': (match, p1, p2) => `Somewhere in the ${p1.replace(/,/g, '')} to ${p2.replace(/,/g, '')} range makes sense.`,
          'Volume quality = LOW': "Not much activity out therefeels like traders are waiting.",
          'Volume quality is LOW': "Volume's pretty thinnot a lot happening.",
          'Stop loss: ([\\d,]+)': (match, p1) => `Would want to cut it if price dips under ${p1.replace(/,/g, '')}.`,
          'Stop loss at ([\\d,]+)': (match, p1) => `Stop's sitting at ${p1.replace(/,/g, '')}that's where you'd bail.`,
          'Targets at ([\\d,]+) and ([\\d,]+)': (match, p1, p2) => `Aiming for that ${p1.replace(/,/g, '')} and ${p2.replace(/,/g, '')} area.`,
          'Risk-reward is 1:([\\d.]+)': (match, p1) => `Decent stretch for a ${p1}x play.`,
          'Risk-reward ratio of 1:([\\d.]+)': (match, p1) => `You're looking at a ${p1}x setup.`
        }
      },
      pro: {
        name: 'Professional Analyst',
        description: 'Technical, precise, institutional-grade analysis',
        systemPromptSuffix: `Use professional, technical language appropriate for institutional traders. Be precise with terminology and data points. Maintain analytical rigor while remaining accessible.`,
        mappings: {}
      },
      hype: {
        name: 'Hype',
        description: 'Energetic, engaging, momentum-focused',
        systemPromptSuffix: `Use energetic, engaging language that captures momentum and excitement. Be enthusiastic about opportunities while maintaining accuracy.`,
        mappings: {}
      },
      coach: {
        name: 'Coach',
        description: 'Educational, supportive, teaching-focused',
        systemPromptSuffix: `Use an educational, supportive tone. Explain concepts clearly and help the trader understand why decisions are being made. Be encouraging and constructive.`,
        mappings: {}
      }
    };
    
    // Apply natural language tone mapping to text
    function applyToneMapping(text, toneFlavor) {
      if (!toneFlavor || !VOICE_PACKS[toneFlavor] || !VOICE_PACKS[toneFlavor].mappings) {
        return text; // No mapping, return original
      }
      
      const mappings = VOICE_PACKS[toneFlavor].mappings;
      let mappedText = text;
      
      // Apply each mapping pattern
      for (const [pattern, replacement] of Object.entries(mappings)) {
        if (typeof replacement === 'function') {
          // Function replacement (for regex with captures)
          const regex = new RegExp(pattern, 'gi');
          mappedText = mappedText.replace(regex, replacement);
        } else {
          // Simple string replacement
          const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
          mappedText = mappedText.replace(regex, replacement);
        }
      }
      
      return mappedText;
    }
    
    // Generate cache key from parameters
    function getPulseCacheKey(symbol, target, tone, depth, temperature, toneFlavor = null) {
      const flavorSuffix = toneFlavor ? `:${toneFlavor}` : '';
      return `${symbol}:${target}:${tone}:${depth}:${temperature}${flavorSuffix}`;
    }
    
    // Generate hash of market state for change detection
    function getMarketStateHash(context) {
      if (!context) return null;
      // Hash key market indicators that would invalidate cache
      const stateKey = [
        context.symbol,
        context.mode,
        context.htfBias?.direction,
        context.htfBias?.confidence,
        context.activeSignals,
        context.trendMap?.['4h'],
        context.trendMap?.['1h'],
        context.volumeQuality,
        context.price
      ].join('|');
      return stateKey;
    }
    
    // Check if cached response is still valid
    function isCacheValid(cacheKey, currentContextHash) {
      const cached = pulseCache.get(cacheKey);
      if (!cached) return false;
      
      const age = Date.now() - cached.timestamp;
      if (age > PULSE_CACHE_TTL) {
        console.log(` Cache expired for ${cacheKey} (age: ${age}ms)`);
        pulseCache.delete(cacheKey);
        return false;
      }
      
      // Check if market state changed significantly
      if (cached.contextHash !== currentContextHash) {
        console.log(` Market state changed for ${cacheKey}, invalidating cache`);
        pulseCache.delete(cacheKey);
        return false;
      }
      
      console.log(` Using cached pulse for ${cacheKey} (age: ${age}ms)`);
      return true;
    }
    
    // Signal timestamp tracking (temporal awareness)
    const lastSignalTimestamps = new Map(); // { symbol: { timestamp, strategy } }
    
    // Update last signal timestamp when a valid signal is detected
    function updateLastSignalTimestamp(symbol, strategy, timestamp = null) {
      const signalTime = timestamp || Date.now();
      lastSignalTimestamps.set(symbol, {
        timestamp: signalTime,
        strategy: strategy,
        iso: new Date(signalTime).toISOString()
      });
      console.log(` Updated lastSignalAt for ${symbol}: ${strategy} @ ${new Date(signalTime).toISOString()}`);
    }
    
    // Calculate time since last signal
    function getTimeSinceLastSignal(symbol) {
      const lastSignal = lastSignalTimestamps.get(symbol);
      if (!lastSignal) return null;
      
      const now = Date.now();
      const elapsed = now - lastSignal.timestamp;
      const hours = Math.floor(elapsed / (1000 * 60 * 60));
      const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
      
      return {
        hours,
        minutes,
        totalHours: elapsed / (1000 * 60 * 60),
        timestamp: lastSignal.timestamp,
        iso: lastSignal.iso,
        strategy: lastSignal.strategy
      };
    }
    
    // ============================================
    // Tone Interpolation Module (Reusable Globally)
    // ============================================
    // Centralized tone weighting system for all AI interfaces
    // (dashboard, marquee, tracker, details section)
    
    /**
     * Get interpolated tone based on market scores
     * @param {Object} params - Scoring parameters
     * @param {number} params.riskScore - Risk profile score (0-1, higher = more risk-off)
     * @param {number} params.trendScore - Trend alignment score (-1 to 1, negative = bearish, positive = bullish)
     * @param {number} params.signalScore - Signal count score (0-1, higher = more signals)
     * @param {string} params.overrideTone - Optional override tone ('neutral' | 'optimistic' | 'cautionary' | 'assertive')
     * @param {boolean} params.allowOverride - Whether to allow override (default: true)
     * @returns {Object} Tone interpolation result
     */
    function getInterpolatedTone({ riskScore = 0, trendScore = 0, signalScore = 0, overrideTone = null, allowOverride = true }) {
      // Apply override if provided and allowed
      if (allowOverride && overrideTone && ['neutral', 'optimistic', 'cautionary', 'assertive'].includes(overrideTone)) {
        console.log(` [Tone Interpolation] Override applied: ${overrideTone}`);
        return {
          finalTone: overrideTone,
          weight: 1.0,
          scores: {
            cautionary: overrideTone === 'cautionary' ? 1.0 : 0,
            optimistic: overrideTone === 'optimistic' ? 1.0 : 0,
            neutral: overrideTone === 'neutral' ? 1.0 : 0,
            assertive: overrideTone === 'assertive' ? 1.0 : 0
          },
          softToneHints: {
            primary: overrideTone,
            secondary: null,
            blendRatio: 1.0
          },
          override: true
        };
      }
      
      // Calculate component scores
      let cautionaryScore = 0;
      let optimisticScore = 0;
      
      // 1. Risk score (0-0.3 weight toward cautionary)
      if (riskScore > 0) {
        cautionaryScore += riskScore * 0.3;
        console.log(` [Tone Interpolation] Risk score: +${(riskScore * 0.3).toFixed(2)} cautionary`);
      }
      
      // 2. Trend score (-1 to 1, mapped to 0-0.4 weight)
      if (trendScore < 0) {
        // Bearish trend
        const bearishWeight = Math.abs(trendScore) * 0.4;
        cautionaryScore += bearishWeight;
        console.log(` [Tone Interpolation] Bearish trend: +${bearishWeight.toFixed(2)} cautionary`);
      } else if (trendScore > 0) {
        // Bullish trend
        const bullishWeight = trendScore * 0.4;
        optimisticScore += bullishWeight;
        console.log(` [Tone Interpolation] Bullish trend: +${bullishWeight.toFixed(2)} optimistic`);
      }
      
      // 3. Signal score (0-0.2 weight)
      if (signalScore === 0) {
        cautionaryScore += 0.1; // No signals = slightly cautionary
        console.log(` [Tone Interpolation] No signals: +0.1 cautionary`);
      } else if (signalScore >= 0.5) {
        optimisticScore += 0.2; // Multiple signals = optimistic
        console.log(` [Tone Interpolation] Strong signals: +0.2 optimistic`);
      }
      
      // Normalize scores (cap at 1.0)
      cautionaryScore = Math.min(1.0, cautionaryScore);
      optimisticScore = Math.min(1.0, optimisticScore);
      const neutralScore = Math.max(0, 1.0 - Math.max(cautionaryScore, optimisticScore));
      
      // Determine final tone based on highest score
      let finalTone = 'neutral';
      let weight = 0;
      let softToneHints = {
        primary: 'neutral',
        secondary: null,
        blendRatio: 1.0
      };
      
      if (cautionaryScore > optimisticScore && cautionaryScore > 0.5) {
        finalTone = 'cautionary';
        weight = cautionaryScore;
        softToneHints = {
          primary: 'cautionary',
          secondary: optimisticScore > 0.2 ? 'optimistic' : 'neutral',
          blendRatio: cautionaryScore
        };
      } else if (optimisticScore > cautionaryScore && optimisticScore > 0.5) {
        finalTone = 'optimistic';
        weight = optimisticScore;
        softToneHints = {
          primary: 'optimistic',
          secondary: cautionaryScore > 0.2 ? 'cautionary' : 'neutral',
          blendRatio: optimisticScore
        };
      } else {
        finalTone = 'neutral';
        weight = Math.max(cautionaryScore, optimisticScore);
        softToneHints = {
          primary: 'neutral',
          secondary: cautionaryScore > optimisticScore ? 'cautionary' : (optimisticScore > 0 ? 'optimistic' : null),
          blendRatio: weight
        };
      }
      
      console.log(` [Tone Interpolation] Final: ${finalTone} (weight: ${weight.toFixed(2)}, cautionary: ${cautionaryScore.toFixed(2)}, optimistic: ${optimisticScore.toFixed(2)}, neutral: ${neutralScore.toFixed(2)})`);
      
      return {
        finalTone,
        weight,
        scores: {
          cautionary: cautionaryScore,
          optimistic: optimisticScore,
          neutral: neutralScore
        },
        softToneHints,
        override: false
      };
    }
    
    /**
     * Calculate scores from market data for tone interpolation
     * @param {Object} data - Market data object
     * @param {string} symbol - Trading symbol
     * @returns {Object} Scores object { riskScore, trendScore, signalScore }
     */
    function calculateToneScores(data, symbol) {
      if (!data) return { riskScore: 0, trendScore: 0, signalScore: 0 };
      
      // 1. Risk score (0-1)
      let riskScore = 0;
      const userRiskProfile = localStorage.getItem('userRiskProfile');
      if (userRiskProfile === 'risk-off') {
        riskScore = 1.0;
      }
      
      // 2. Trend score (-1 to 1, negative = bearish, positive = bullish)
      let trendScore = 0;
      const htfBias = data.htfBias || data.richSymbol?.htfBias;
      if (htfBias) {
        const biasConf = (htfBias.confidence || 0) / 100;
        if (htfBias.direction === 'short') {
          trendScore = -biasConf; // Negative for bearish
        } else if (htfBias.direction === 'long') {
          trendScore = biasConf; // Positive for bullish
        }
      }
      
      // Also consider trend alignment across timeframes
      if (data.analysis) {
        let bearishCount = 0;
        let bullishCount = 0;
        let totalTrends = 0;
        
        for (const [tf, tfData] of Object.entries(data.analysis)) {
          if (tfData && tfData.indicators && tfData.indicators.analysis) {
            const trend = (tfData.indicators.analysis.trend || '').toUpperCase();
            totalTrends++;
            if (trend === 'DOWNTREND' || trend === 'DOWN') {
              bearishCount++;
            } else if (trend === 'UPTREND' || trend === 'UP') {
              bullishCount++;
            }
          }
        }
        
        if (totalTrends > 0) {
          const bearishRatio = bearishCount / totalTrends;
          const bullishRatio = bullishCount / totalTrends;
          
          // Blend with HTF bias (trend alignment gets 0.3 weight)
          if (bearishRatio >= 0.6) {
            trendScore = trendScore * 0.7 - 0.3; // Shift more bearish
          } else if (bullishRatio >= 0.6) {
            trendScore = trendScore * 0.7 + 0.3; // Shift more bullish
          }
        }
      }
      
      // Clamp trend score to -1 to 1
      trendScore = Math.max(-1, Math.min(1, trendScore));
      
      // 3. Signal score (0-1)
      let signalScore = 0;
      const strategies = data.richSymbol?.strategies || {};
      const validSignals = Object.values(strategies).filter(s => s && s.valid === true).length;
      if (validSignals === 0) {
        signalScore = 0;
      } else if (validSignals === 1) {
        signalScore = 0.3;
      } else if (validSignals >= 2) {
        signalScore = 1.0;
      }
      
      return { riskScore, trendScore, signalScore };
    }
    
    // Dynamic tone weighting system (uses tone interpolation module)
    // Scores signals + bias and blends tone weights gradually
    function calculateDynamicToneWeight(data, symbol, overrideTone = null) {
      const scores = calculateToneScores(data, symbol);
      return getInterpolatedTone({
        riskScore: scores.riskScore,
        trendScore: scores.trendScore,
        signalScore: scores.signalScore,
        overrideTone: overrideTone,
        allowOverride: true
      });
    }
    
    // Detect bear mode or risk-off conditions (legacy function, now uses dynamic weighting)
    function detectBearModeOrRiskOff(data, symbol) {
      const toneWeight = calculateDynamicToneWeight(data, symbol);
      return toneWeight.tone === 'cautionary' && toneWeight.weight >= 0.6;
    }
    
    // Market Pulse Intelligence - New adaptive AI system with caching
    async function getMarketPulse(symbol, target = 'dashboard', tone = 'neutral', depth = 'normal', temperature = 0.5, options = {}) {
      try {
        const data = scanResults[symbol];
        if (!data) {
          console.error(`No data for symbol: ${symbol}`);
          // Return fallback message instead of null
          return `Market data for ${symbol} is currently unavailable. Please check again soon.`;
        }
        
        // Extract toneFlavor from options or dev config
        let toneFlavor = options.toneFlavor || null;
        if (PULSE_DEV_CONFIG.enabled && PULSE_DEV_CONFIG.toneFlavor) {
          toneFlavor = PULSE_DEV_CONFIG.toneFlavor;
        }
        
        // Calculate dynamic tone weighting (blends tones gradually)
        const toneWeight = calculateDynamicToneWeight(data, symbol);
        
        // Apply dynamic tone if base tone is neutral or if weight is strong
        if (tone === 'neutral' || toneWeight.weight >= 0.6) {
          tone = toneWeight.tone;
          console.log(` Dynamic tone applied: ${tone} (weight: ${toneWeight.weight.toFixed(2)})`);
        }
        
        // Apply dev config overrides if enabled (after dynamic tone calculation)
        if (PULSE_DEV_CONFIG.enabled) {
          // Only override if dev config doesn't explicitly set a different tone
          if (!PULSE_DEV_CONFIG.systemPromptTone || PULSE_DEV_CONFIG.systemPromptTone === 'neutral') {
            // Keep dynamic tone if calculated
          } else {
            tone = PULSE_DEV_CONFIG.systemPromptTone;
          }
          temperature = Math.min(temperature, PULSE_DEV_CONFIG.temperatureCap);
          depth = PULSE_DEV_CONFIG.messageFormat[target] || depth;
        }
        
        console.log(` Getting Market Pulse Intelligence for ${symbol} (${target}, ${tone}, ${depth}${toneFlavor ? `, flavor: ${toneFlavor}` : ''})`);
        
        // Build pulse context from existing data structure (includes temporal awareness)
        const pulseContext = buildPulseContext(data, symbol);
        
        // Add tone weight information to context for prompt interpolation
        pulseContext.toneWeight = toneWeight;
        
        // Add toneFlavor to context
        if (toneFlavor) {
          pulseContext.toneFlavor = toneFlavor;
        }
        
        // Check cache before making API call (include toneFlavor in cache key)
        const cacheKey = getPulseCacheKey(symbol, target, tone, depth, temperature, toneFlavor);
        const contextHash = getMarketStateHash(pulseContext);
        
        if (isCacheValid(cacheKey, contextHash)) {
          const cachedPulse = pulseCache.get(cacheKey).pulse;
          // Apply tone mapping if flavor is specified
          if (toneFlavor) {
            return applyToneMapping(cachedPulse, toneFlavor);
          }
          return cachedPulse;
        }
        
        // Build pulse variables
        const pulseVariables = {
          tone: tone,
          depth: depth,
          target: target,
          temperature: temperature.toString(),
          toneFlavor: toneFlavor || null
        };
        
        // Call Market Pulse Intelligence endpoint
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            pulseContext: pulseContext,
            pulseVariables: pulseVariables
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || 'Market Pulse Intelligence failed');
        }
        
        const result = await response.json();
        let pulse = result.pulse;
        
        if (!pulse) {
          // Fallback if API returns empty response
          return `Market analysis for ${symbol} is temporarily unavailable. Please check again soon.`;
        }
        
        // Apply tone mapping if flavor is specified (backend may not apply it, so we do it here too)
        if (toneFlavor) {
          pulse = applyToneMapping(pulse, toneFlavor);
        }
        
        console.log(' Market Pulse Intelligence received:', pulse.substring(0, 100));
        
        // Cache the response (cache original, apply mapping on retrieval)
        pulseCache.set(cacheKey, {
          pulse: result.pulse, // Cache original (before mapping)
          timestamp: Date.now(),
          contextHash: contextHash
        });
        
        // Clean up old cache entries (keep only last 50)
        if (pulseCache.size > 50) {
          const entries = Array.from(pulseCache.entries());
          entries.sort((a, b) => b[1].timestamp - a[1].timestamp);
          pulseCache.clear();
          entries.slice(0, 50).forEach(([key, value]) => pulseCache.set(key, value));
        }
        
        return pulse;
        
      } catch (error) {
        console.error(' Market Pulse Intelligence error:', error);
        // Return fallback message instead of null
        const symbolName = symbol || 'market';
        return `Market data for ${symbolName} is currently unavailable. Please check again soon.`;
      }
    }
    
    // Build pulse context from existing data structure
    function buildPulseContext(data, symbol) {
      const htfBias = data.htfBias || { direction: 'neutral', confidence: 0, source: 'none' };
      // Get current mode from global state or data
      const modeFromData = data.mode || (data.richSymbol?.mode === 'SAFE' ? 'STANDARD' : 'AGGRESSIVE');
      const currentMode = modeFromData === 'SAFE' ? 'STANDARD' : modeFromData;
      
      // Extract trend states from analysis
      const trendMap = {};
      if (data.analysis) {
        for (const [tf, tfData] of Object.entries(data.analysis)) {
          if (tfData && tfData.indicators && tfData.indicators.analysis) {
            const trend = tfData.indicators.analysis.trend || 'UNKNOWN';
            trendMap[tf] = trend.toUpperCase();
          }
        }
      }
      
      // Calculate volatility (3-day range if available)
      let volatility3d = null;
      if (data.analysis && data.analysis['3d']) {
        // Simple volatility calculation from price range
        const tf3d = data.analysis['3d'];
        if (tf3d.indicators && tf3d.indicators.price) {
          const currentPrice = tf3d.indicators.price.current || data.currentPrice;
          // Estimate volatility from recent price action (simplified)
          volatility3d = 'N/A'; // Could be enhanced with actual volatility calculation
        }
      }
      
      // Get market data
      const marketData = data.richSymbol?.marketData || data.marketData || null;
      const volumeQuality = marketData?.volumeQuality || 'N/A';
      
      // Get dFlow status
      const dflowData = data.richSymbol?.dflowData || data.dflowData || null;
      const dflowStatus = dflowData && dflowData.markets && dflowData.markets.length > 0 
        ? 'Available' 
        : 'Unavailable';
      
      // Count active signals
      const strategies = data.richSymbol?.strategies || {};
      let activeSignals = 0;
      Object.values(strategies).forEach(strategy => {
        if (strategy && strategy.valid === true) {
          activeSignals++;
        }
      });
      
      // Get last signal time (from generatedAt if available)
      const lastSignalTime = data.richSymbol?.generatedAt || data.generatedAt || null;
      
      // Calculate temporal awareness (time since last signal)
      const timeSinceLastSignal = getTimeSinceLastSignal(symbol);
      let lastSignalAt = null;
      let hoursSinceLastSignal = null;
      
      if (timeSinceLastSignal) {
        lastSignalAt = timeSinceLastSignal.iso;
        hoursSinceLastSignal = timeSinceLastSignal.totalHours;
      } else if (lastSignalTime) {
        // Fallback to generatedAt if no explicit signal timestamp
        lastSignalAt = lastSignalTime;
        const now = Date.now();
        const lastSignal = new Date(lastSignalTime).getTime();
        hoursSinceLastSignal = (now - lastSignal) / (1000 * 60 * 60);
      }
      
      // Update last signal timestamp if we have a valid signal now
      const bestSignal = data.richSymbol?.bestSignal || null;
      if (bestSignal && strategies[bestSignal] && strategies[bestSignal].valid) {
        updateLastSignalTimestamp(symbol, bestSignal, lastSignalTime ? new Date(lastSignalTime).getTime() : Date.now());
      }
      
      return {
        symbol: symbol,
        mode: currentMode,
        price: data.currentPrice || null,
        htfBias: htfBias,
        trendMap: trendMap,
        volatility3d: volatility3d,
        volumeQuality: volumeQuality,
        dflowStatus: dflowStatus,
        activeSignals: activeSignals,
        lastSignalTime: lastSignalTime,
        lastSignalAt: lastSignalAt, // ISO timestamp
        hoursSinceLastSignal: hoursSinceLastSignal // Numeric hours
      };
    }
    
    function startMarketReview() {
      console.log(' Starting AI market review...');
      // Initial review display with placeholder
      updateMarketReviewDisplay();
      
      // Wait for data to load, then get first review (non-blocking)
      setTimeout(() => {
        if (Object.keys(scanResults).length > 0) {
          getAIMarketReview().catch(err => {
            console.error(' Market review failed:', err);
            marketReviewCache = 'Market analysis temporarily unavailable';
            updateMarketReviewDisplay();
          });
        } else {
          console.log(' No scan results yet, will retry in 5 seconds...');
          setTimeout(() => {
            if (Object.keys(scanResults).length > 0) {
              getAIMarketReview().catch(err => console.error('Market review error:', err));
            }
          }, 5000);
        }
      }, 5000);
      
      // Refresh every 5 minutes
      setInterval(() => {
        if (Object.keys(scanResults).length > 0) {
          getAIMarketReview().catch(err => console.error('Market review error:', err));
        }
      }, 300000);
    }

    window.addEventListener('DOMContentLoaded', () => {
      initializeAggressiveMode();
      startCandleTimers();
      startMarketReview(); // AI market review enabled
      scanMajorCoins();
    });

    // Main scan function
    async function scanMajorCoins() {
      // Always show BTC, ETH, SOL plus any additional starred coins
      const defaults = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      const starredCoins = JSON.parse(localStorage.getItem('starredCoins') || '[]');
      // Combine defaults with starred coins, remove duplicates
      const symbols = [...new Set([...defaults, ...starredCoins])];
      
      // Show loading
      document.getElementById('loadingState').classList.remove('hidden');
      document.getElementById('resultsContainer').classList.add('hidden');
      document.getElementById('errorState').classList.add('hidden');
      
      try {
        scanResults = {};
        
        // Fetch data for BOTH modes to count all signals
        const mode = aggressiveMode ? 'AGGRESSIVE' : 'STANDARD';
        
        // Fetch current mode (for display) - USE /api/analyze-full for rich structure
        const currentModePromises = symbols.map(symbol => 
          fetch(`/api/analyze-full?symbol=${symbol}&mode=${mode}`)
            .then(async res => {
              if (!res.ok) {
                const errorText = await res.text();
                console.error(`[scanMajorCoins] ${symbol} (${mode}) failed:`, res.status, errorText);
                throw new Error(`Failed to fetch ${symbol} (${res.status}): ${errorText.substring(0, 100)}`);
              }
              return res.json();
            })
            .then(richSymbol => {
              // Convert rich symbol to legacy format for backward compatibility
              try {
              const legacyData = convertRichSymbolToLegacy(richSymbol);
                return { symbol, data: legacyData, mode, richSymbol, success: true };
              } catch (convertError) {
                console.error(`[scanMajorCoins] Error converting ${symbol} to legacy format:`, convertError);
                throw new Error(`Failed to convert ${symbol} data: ${convertError.message}`);
              }
            })
            .catch(error => {
              console.error(`[scanMajorCoins] Error processing ${symbol} (${mode}):`, error);
              return { symbol, data: null, mode, richSymbol: null, success: false, error: error.message };
            })
        );
        
        // Fetch opposite mode (for counting) - USE /api/analyze-full for rich structure
        const oppositeMode = aggressiveMode ? 'STANDARD' : 'AGGRESSIVE';
        const oppositeModePromises = symbols.map(symbol => 
          fetch(`/api/analyze-full?symbol=${symbol}&mode=${oppositeMode}`)
            .then(async res => {
              if (!res.ok) {
                const errorText = await res.text();
                console.error(`[scanMajorCoins] ${symbol} (${oppositeMode}) failed:`, res.status, errorText);
                throw new Error(`Failed to fetch ${symbol} (${res.status}): ${errorText.substring(0, 100)}`);
              }
              return res.json();
            })
            .then(richSymbol => {
              // Convert rich symbol to legacy format for backward compatibility
              try {
              const legacyData = convertRichSymbolToLegacy(richSymbol);
                return { symbol, data: legacyData, mode: oppositeMode, richSymbol, success: true };
              } catch (convertError) {
                console.error(`[scanMajorCoins] Error converting ${symbol} to legacy format:`, convertError);
                throw new Error(`Failed to convert ${symbol} data: ${convertError.message}`);
              }
            })
            .catch(error => {
              console.error(`[scanMajorCoins] Error processing ${symbol} (${oppositeMode}):`, error);
              return { symbol, data: null, mode: oppositeMode, richSymbol: null, success: false, error: error.message };
            })
        );
        
        // Fetch both modes in parallel - use allSettled so one failure doesn't break everything
        const allResults = await Promise.allSettled([...currentModePromises, ...oppositeModePromises]);
        
        // Process results - handle both fulfilled and rejected promises
        const processedResults = allResults.map((result, index) => {
          if (result.status === 'fulfilled') {
            return result.value; // This is our { symbol, data, mode, richSymbol, success } object
          } else {
            // Promise was rejected (shouldn't happen since we catch in the promise chain, but handle it)
            console.error(`[scanMajorCoins] Promise rejected:`, result.reason);
            const symbolIndex = index % symbols.length;
            const modeIndex = Math.floor(index / symbols.length);
            const symbol = symbols[symbolIndex];
            const resultMode = modeIndex === 0 ? mode : oppositeMode;
            return { symbol, data: null, mode: resultMode, richSymbol: null, success: false, error: result.reason?.message || 'Unknown error' };
          }
        });
        
        // Store results by mode (store both legacy data and rich symbol)
        const failedSymbols = [];
        processedResults.forEach(({ symbol, data, mode: resultMode, richSymbol, success, error }) => {
          if (!success || !data) {
            console.warn(`[scanMajorCoins] Skipping ${symbol} (${resultMode}) - ${error || 'no data'}`);
            failedSymbols.push({ symbol, mode: resultMode, error: error || 'No data returned' });
            // Create a minimal error entry so UI can show the error
            const errorData = {
              error: true,
              errorMessage: error || `Failed to fetch ${symbol}`,
              symbol,
              mode: resultMode
            };
            if (resultMode === 'AGGRESSIVE') {
              scanResultsAggressive[symbol] = errorData;
            } else {
              scanResultsSafe[symbol] = errorData;
            }
            return;
          }
          
          const resultData = data;
          // Store rich symbol for direct backend access
          if (richSymbol) {
            resultData.richSymbol = richSymbol;
            resultData.strategies = richSymbol.strategies;
            resultData.bestSignal = richSymbol.bestSignal;
            // Preserve marketData and dflowData from richSymbol if not already in resultData
            if (richSymbol.marketData && !resultData.marketData) {
              resultData.marketData = richSymbol.marketData;
            }
            if (richSymbol.dflowData && !resultData.dflowData) {
              resultData.dflowData = richSymbol.dflowData;
            }
          }
          if (resultMode === 'AGGRESSIVE') {
            scanResultsAggressive[symbol] = resultData;
          } else {
            scanResultsSafe[symbol] = resultData;
          }
        });
        
        // Log summary
        if (failedSymbols.length > 0) {
          console.warn(`[scanMajorCoins] ${failedSymbols.length} symbols failed:`, failedSymbols);
        } else {
          console.log(`[scanMajorCoins] All ${symbols.length * 2} requests succeeded`);
        }
        
        // Set scanResults to current mode for display
        scanResults = aggressiveMode ? scanResultsAggressive : scanResultsSafe;
        
        // Display results
        displayResults();
        
        document.getElementById('loadingState').classList.add('hidden');
        document.getElementById('resultsContainer').classList.remove('hidden');
        
        // Update all strategy buttons to ensure correct state
        setTimeout(() => {
          console.log(' scanResults symbols:', Object.keys(scanResults));
          console.log(' strategyStates:', strategyStates);
          
          for (const symbol in scanResults) {
            console.log(`Attempting to update buttons for ${symbol}`);
            updateStrategyButtons(symbol);
          }
          console.log(' All strategy buttons updated');
          
          // Update aggressive/standard button based on trade status
          initializeAggressiveMode();
        }, 50);
        
        // Auto-trigger AI analysis for all coins after page load
        console.log('Auto-triggering AI analysis for all coins...');
        autoTriggerAIAnalysis();
        
      } catch (error) {
        console.error('Scan error:', error);
        showError(error.message || 'Failed to scan markets. Check your connection and try again.');
        document.getElementById('loadingState').classList.add('hidden');
      }
    }

    // Auto-select best strategy based on available signals
    // Priority: 4h > Swing (Daily) > Scalp (1h) > MicroScalp
    function autoSelectStrategy(symbol) {
      const data = scanResults[symbol];
      const apiSignal = data?.signal || data?.tradeSignal;
      
      // Priority order: 0 (4h), 1 (Swing), 2 (Scalp), 3 (MicroScalp)
      const strategies = ['4h', 'Swing', 'Scalp', 'MicroScalp'];
      
      for (let i = 0; i < strategies.length; i++) {
        const strategy = strategies[i];
        
        // Map frontend strategy key to backend strategy name
        const strategyKeyMap = {
          '4h': 'TREND_4H',
          'Swing': 'SWING',
          'Scalp': 'SCALP_1H',
          'MicroScalp': 'MICRO_SCALP'
        };
        const backendStrategyName = strategyKeyMap[strategy];
        
        // Get backend strategy directly (NO template evaluation)
        const richSymbol = data?.richSymbol || data;
        const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
        const signal = backendStrategy && backendStrategy.valid ? {
          valid: true,
          direction: backendStrategy.direction,
          confidence: backendStrategy.confidence
        } : null;
        
        if (signal && signal.valid) {
          // Found a valid signal, select this strategy
          strategyStates[symbol] = i;
          console.log(`Auto-selected ${strategy} for ${symbol}`);
          return i;
        }
      }
      
      // No valid signals found, default to 4h (index 0)
      strategyStates[symbol] = 0;
      return 0;
    }
    
    // Display scan results
    function displayResults() {
      console.log('[displayResults] Starting displayResults()');
      console.log('[displayResults] scanResults keys:', Object.keys(scanResults));
      console.log('[displayResults] scanResults structure:', scanResults);
      
      const tableBody = document.getElementById('opportunitiesTable');
      if (!tableBody) {
        console.error('[displayResults] ERROR: opportunitiesTable tbody element not found!');
        return;
      }
      
      tableBody.innerHTML = '';
      
      // Always show all symbols, even if they have errors or no trades
      const symbolsToShow = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      
      for (const symbol of symbolsToShow) {
        const data = scanResults[symbol];
        console.log(`[displayResults] Processing ${symbol}:`, {
          hasData: !!data,
          hasError: data?.error,
          hasRichSymbol: !!data?.richSymbol,
          hasStrategies: !!data?.strategies,
          hasSignal: !!data?.signal,
          hasTradeSignal: !!data?.tradeSignal
        });
        
        // Show symbol even if data is missing or has errors - create minimal data structure
        const displayData = data || {
          error: true,
          errorMessage: 'No data available',
          symbol,
          currentPrice: null,
          strategies: {},
          bestSignal: null
        };
        
        // Ensure currentPrice exists (use null if missing, but still display)
        if (!displayData.currentPrice && !displayData.error) {
          displayData.currentPrice = null;
        }
        
        try {
          // Auto-select best strategy for this symbol
          autoSelectStrategy(symbol);
          
          const row = createCoinRow(symbol, displayData);
          const detailsRow = createDetailsRow(symbol, displayData);
          tableBody.appendChild(row);
          tableBody.appendChild(detailsRow);
          
          // Update strategy buttons after row is added to DOM
          setTimeout(() => updateStrategyButtons(symbol), 10);
        } catch (error) {
          console.error(`[displayResults] Error creating row for ${symbol}:`, error);
          console.error(`[displayResults] Error stack:`, error.stack);
          // Still try to create a basic row even on error
          try {
            const errorRow = document.createElement('tr');
            errorRow.innerHTML = `<td colspan="10" style="padding: 1rem; text-align: center; color: #ef4444;">Error displaying ${symbol}: ${error.message}</td>`;
            tableBody.appendChild(errorRow);
          } catch (e) {
            console.error(`[displayResults] Failed to create error row for ${symbol}:`, e);
          }
        }
      }
      
      console.log(`[displayResults] Completed. Rows added: ${tableBody.children.length}`);
      
      // Update trading indicators
      updateTradingIndicators();
      
      // Update mode buttons
      updateModeButtons();
      
      // Update high-level dashboard
      updateHighLevelDashboard();
    }
    
    // Update High-Level Dashboard with BTCUSDT data (primary symbol)
    function updateHighLevelDashboard() {
      const dashboard = document.getElementById('highLevelDashboard');
      if (!dashboard) return;
      
      // Use BTCUSDT as primary symbol for dashboard
      const symbol = 'BTCUSDT';
      const data = scanResults[symbol];
      
      if (!data) {
        dashboard.classList.add('hidden');
        return;
      }
      
      // Show dashboard
      dashboard.classList.remove('hidden');
      
      const richSymbol = data?.richSymbol || data;
      const timeframes = richSymbol?.timeframes || {};
      const currentPrice = richSymbol?.currentPrice || data?.currentPrice || 0;
      const htfBias = richSymbol?.htfBias || { direction: 'neutral', confidence: 0, source: 'none' };
      
      // 1. HTF Trend State (1D, 4H, 1H)
      updateHTFTrendState(timeframes, htfBias, currentPrice);
      
      // 2. Liquidity Map
      updateLiquidityMap(timeframes, currentPrice);
      
      // 3. FVG State
      updateFVGState(timeframes, currentPrice);
      
      // 4. Divergence Alerts
      updateDivergenceAlerts(timeframes);
      
      // 5. Volatility (ATR State)
      updateVolatilityState(timeframes);
      
      // 6. Volume Profile Bias
      updateVolumeProfileBias(timeframes, currentPrice);
      
      // 7. Trade Readiness Meter
      updateTradeReadinessMeter(richSymbol, timeframes, currentPrice);
      
      // 8. AI Trade Breakdown - Analyze all signals from all symbols
      updateAITradeBreakdown(scanResults);
    }
    
    // Calculate Trade Readiness Score
    function calculateTradeReadinessScore(richSymbol, timeframes, currentPrice) {
      const tf1d = timeframes['1d'];
      const tf4h = timeframes['4h'];
      const tf1h = timeframes['1h'];
      const htfBias = richSymbol?.htfBias || { direction: 'neutral', confidence: 0 };
      const strategies = richSymbol?.strategies || {};
      
      let score = 0;
      let playType = 'none';
      const breakdown = {
        htfAlignment: { score: 0, details: '' },
        structureLiquidity: { score: 0, details: '' },
        fvgContext: { score: 0, details: '' },
        divergences: { score: 0, details: '' },
        volatility: { score: 0, details: '' },
        volumeProfile: { score: 0, details: '' },
        strategyBoost: { score: 0, details: '' }
      };
      
      // A. HTF Trend Alignment (up to 35 pts)
      const trends = {
        '1d': tf1d?.trend ? String(tf1d.trend).toLowerCase() : null,
        '4h': tf4h?.trend ? String(tf4h.trend).toLowerCase() : null,
        '1h': tf1h?.trend ? String(tf1h.trend).toLowerCase() : null
      };
      
      const trendDirs = Object.values(trends).filter(t => t && (t.includes('up') || t.includes('down')));
      const upCount = trendDirs.filter(t => t.includes('up')).length;
      const downCount = trendDirs.filter(t => t.includes('down')).length;
      const allSame = (upCount === 3) || (downCount === 3);
      const twoAligned = (upCount === 2) || (downCount === 2);
      
      if (allSame && htfBias.confidence >= 70) {
        breakdown.htfAlignment.score = 35;
        breakdown.htfAlignment.details = `All 3 aligned ${upCount === 3 ? '' : ''} (${htfBias.confidence}% confidence)`;
        playType = 'trend';
      } else if (twoAligned && htfBias.confidence >= 60) {
        breakdown.htfAlignment.score = 25;
        breakdown.htfAlignment.details = `2/3 aligned (${htfBias.confidence}% confidence)`;
        playType = 'trend';
      } else if (trendDirs.length > 0) {
        breakdown.htfAlignment.score = 10;
        breakdown.htfAlignment.details = 'Mixed/choppy alignment';
      } else {
        breakdown.htfAlignment.score = 0;
        breakdown.htfAlignment.details = 'No clear trend';
      }
      score += breakdown.htfAlignment.score;
      
      // B. Market Structure & Liquidity (up to 20 pts)
      let structScore = 0;
      const ms4h = tf4h?.marketStructure;
      const lz4h = tf4h?.liquidityZones || [];
      
      // Check structure clarity
      if (ms4h) {
        const swings = ms4h.lastSwings || [];
        const lastBos = ms4h.lastBos;
        const lastChoch = ms4h.lastChoch;
        const currentStruct = ms4h.currentStructure;
        
        // Clean series check (simplified)
        if (swings.length >= 2) {
          const swingTypes = swings.map(s => s.type);
          const hasHH = swingTypes.includes('HH');
          const hasHL = swingTypes.includes('HL');
          const hasLH = swingTypes.includes('LH');
          const hasLL = swingTypes.includes('LL');
          
          if (currentStruct === 'uptrend' && (hasHH || hasHL)) structScore += 10;
          else if (currentStruct === 'downtrend' && (hasLH || hasLL)) structScore += 10;
        }
        
        // BOS in HTF direction
        if (lastBos && lastBos.type === 'BOS') {
          const bosDir = lastBos.direction;
          const htfDir = htfBias.direction;
          if ((htfDir === 'long' && bosDir === 'bullish') || (htfDir === 'short' && bosDir === 'bearish')) {
            structScore += 5;
          }
        }
        
        // CHOCH against trend (trend weakening)
        if (lastChoch && lastChoch.type === 'CHOCH') {
          const chochDir = lastChoch.direction;
          const htfDir = htfBias.direction;
          if ((htfDir === 'long' && chochDir === 'bearish') || (htfDir === 'short' && chochDir === 'bullish')) {
            structScore -= 5;
          }
        }
      }
      
      // Liquidity check
      const equalHighs = lz4h.filter(z => z.type === 'equal_highs');
      const equalLows = lz4h.filter(z => z.type === 'equal_lows');
      const htfDir = htfBias.direction;
      
      if (htfDir === 'short' && equalLows.length > 0) {
        structScore += 5; // Liquidity below for shorts
      } else if (htfDir === 'long' && equalHighs.length > 0) {
        structScore += 5; // Liquidity above for longs
      }
      
      // Opposing liquidity penalty
      if (htfDir === 'short' && equalHighs.length > equalLows.length * 2) {
        structScore -= 5; // Too much liquidity above blocking shorts
      } else if (htfDir === 'long' && equalLows.length > equalHighs.length * 2) {
        structScore -= 5; // Too much liquidity below blocking longs
      }
      
      breakdown.structureLiquidity.score = Math.max(0, Math.min(20, structScore));
      breakdown.structureLiquidity.details = breakdown.structureLiquidity.score >= 15 
        ? 'Clean structure + liquidity aligned' 
        : breakdown.structureLiquidity.score >= 10 
        ? 'Structure clear, some liquidity' 
        : 'Structure unclear or conflicting';
      score += breakdown.structureLiquidity.score;
      
      // C. FVG Context (up to 10 pts)
      const fvgs4h = tf4h?.fairValueGaps || [];
      const fvgs1h = tf1h?.fairValueGaps || [];
      const allFvgs = [...fvgs4h, ...fvgs1h];
      const unfilledBullish = allFvgs.filter(f => f.direction === 'bullish' && !f.filled);
      const unfilledBearish = allFvgs.filter(f => f.direction === 'bearish' && !f.filled);
      
      let fvgScore = 0;
      if (playType === 'trend') {
        // Price pulling back toward FVG in trend direction
        if (htfDir === 'short' && unfilledBearish.length > 0) {
          const nearFvg = unfilledBearish.some(f => Math.abs(currentPrice - f.high) / currentPrice < 0.02);
          if (nearFvg) fvgScore = 10;
          else fvgScore = 7;
        } else if (htfDir === 'long' && unfilledBullish.length > 0) {
          const nearFvg = unfilledBullish.some(f => Math.abs(currentPrice - f.low) / currentPrice < 0.02);
          if (nearFvg) fvgScore = 10;
          else fvgScore = 7;
        }
        
        // Price inside FVG
        const inBullishFvg = unfilledBullish.some(f => currentPrice > f.low && currentPrice < f.high);
        const inBearishFvg = unfilledBearish.some(f => currentPrice > f.low && currentPrice < f.high);
        if (inBullishFvg || inBearishFvg) fvgScore = Math.max(fvgScore, 7);
      }
      
      breakdown.fvgContext.score = fvgScore;
      breakdown.fvgContext.details = fvgScore >= 7 
        ? 'Price near/inside FVG - high probability move' 
        : fvgScore > 0 
        ? 'FVG context present' 
        : 'No active FVG';
      score += breakdown.fvgContext.score;
      
      // D. Divergences (up to 15 pts)
      const tf15m = timeframes['15m'];
      const divs1h = tf1h?.divergences || [];
      const divs15m = tf15m?.divergences || [];
      const allDivs = [...divs1h, ...divs15m];
      
      let divScore = 0;
      const bullishDivs = allDivs.filter(d => d.side === 'bullish');
      const bearishDivs = allDivs.filter(d => d.side === 'bearish');
      
      if (playType === 'trend') {
        // Divergence against trend reduces score
        if (htfDir === 'short' && bullishDivs.length >= 2) {
          divScore = -10; // Bullish divergence in downtrend = bad for trend
        } else if (htfDir === 'long' && bearishDivs.length >= 2) {
          divScore = -10; // Bearish divergence in uptrend = bad for trend
        }
        
        // Hidden divergence with trend is good
        const hiddenWithTrend = allDivs.filter(d => 
          d.type === 'hidden' && 
          ((htfDir === 'short' && d.side === 'bearish') || (htfDir === 'long' && d.side === 'bullish'))
        );
        if (hiddenWithTrend.length > 0) divScore = 10;
      } else if (playType === 'reversal' || (bullishDivs.length >= 2 || bearishDivs.length >= 2)) {
        // Reversal mode: regular divergence at extreme
        if (bullishDivs.length >= 2 || bearishDivs.length >= 2) {
          divScore = 15;
          playType = 'reversal';
        }
      }
      
      breakdown.divergences.score = divScore;
      breakdown.divergences.details = divScore >= 10 
        ? 'Strong divergence signal' 
        : divScore < 0 
        ? 'Divergence against trend' 
        : 'No significant divergences';
      score += breakdown.divergences.score;
      
      // E. Volatility / ATR (up to 10 pts)
      const vol4h = tf4h?.volatility;
      const volState = vol4h?.state || 'normal';
      let volScore = 0;
      
      if (volState === 'normal') volScore = 10;
      else if (volState === 'high') volScore = 5;
      else if (volState === 'low') volScore = 0;
      else if (volState === 'extreme') volScore = -5;
      
      breakdown.volatility.score = volScore;
      breakdown.volatility.details = volState === 'normal' 
        ? 'Normal - Prime trading conditions' 
        : volState === 'high' 
        ? 'High - Manage size' 
        : volState === 'extreme' 
        ? 'Extreme - Reduce risk' 
        : 'Low - Choppy conditions';
      score += breakdown.volatility.score;
      
      // F. Volume Profile Position (up to 10 pts)
      const vp4h = tf4h?.volumeProfile;
      let vpScore = 0;
      
      if (vp4h && vp4h.valueAreaHigh && vp4h.valueAreaLow && currentPrice) {
        const vah = vp4h.valueAreaHigh;
        const val = vp4h.valueAreaLow;
        const mid = (vah + val) / 2;
        
        if (playType === 'trend') {
          if (htfDir === 'short' && currentPrice >= mid) vpScore = 10; // Upper half for shorts
          else if (htfDir === 'short' && currentPrice > val) vpScore = 5;
          else if (htfDir === 'long' && currentPrice <= mid) vpScore = 10; // Lower half for longs
          else if (htfDir === 'long' && currentPrice < vah) vpScore = 5;
        } else if (playType === 'reversal') {
          if (currentPrice >= vah || currentPrice <= val) vpScore = 10; // At extremes for reversal
        }
      }
      
      breakdown.volumeProfile.score = vpScore;
      breakdown.volumeProfile.details = vpScore >= 10 
        ? 'Optimal VP position' 
        : vpScore > 0 
        ? 'Good VP position' 
        : 'Neutral VP position';
      score += breakdown.volumeProfile.score;
      
      // Strategy Boost
      const validStrategies = Object.values(strategies).filter(s => s && s.valid === true);
      let strategyBoost = 0;
      
      if (validStrategies.length === 0) {
        // No valid strategy = cap score
        score = Math.min(score, 40);
        breakdown.strategyBoost.details = 'No valid setups - environment may be ok but no trade';
      } else {
        const bestConfidence = Math.max(...validStrategies.map(s => s.confidence || 0));
        strategyBoost = Math.min(bestConfidence / 2, 15); // Max +15 from strategy confidence
        score += strategyBoost;
        breakdown.strategyBoost.details = `Best strategy: ${bestConfidence}% confidence`;
      }
      breakdown.strategyBoost.score = strategyBoost;
      
      // Final score clamp
      score = Math.max(0, Math.min(100, score));
      
      return { score, playType, breakdown };
    }
    
    // Update Trade Readiness Meter
    function updateTradeReadinessMeter(richSymbol, timeframes, currentPrice) {
      const section = document.getElementById('trade-readiness-section');
      if (!section) return;
      
      // Use tradeReadiness from API if available, otherwise calculate locally
      let tradeReadiness = richSymbol?.tradeReadiness;
      
      if (!tradeReadiness) {
        // Fallback to local calculation if API doesn't have it yet
        const scoreData = calculateTradeReadinessScore(richSymbol, timeframes, currentPrice);
        const { score, playType, breakdown } = scoreData;
        
        // Convert to new format
        let level;
        if (score < 40) level = 'DONT_BOTHER';
        else if (score < 70) level = 'WATCH';
        else level = 'PRIME';
        
        tradeReadiness = {
          tradeReadinessScore: score,
          tradeReadinessLevel: level,
          directionBias: richSymbol?.htfBias?.direction || 'neutral',
          timeframeAlignment: {
            '1d': 'unknown',
            '4h': 'unknown',
            '1h': 'unknown',
            aligned: false
          },
          keyDrivers: Object.values(breakdown).filter(b => b.score > 0).map(b => b.details).slice(0, 5),
          redFlags: Object.values(breakdown).filter(b => b.score < 0).map(b => b.details).slice(0, 3),
          quickView: {
            htfAligned: breakdown.htfAlignment.score >= 25,
            liquidityClean: breakdown.structureLiquidity.score >= 15,
            volatilityTradable: breakdown.volatility.score >= 5,
            structureClean: breakdown.structureLiquidity.score >= 10,
            fvgContext: breakdown.fvgContext.score > 0 ? 'supportive' : 'none',
            divergenceContext: breakdown.divergences.score > 0 ? 'supportive' : breakdown.divergences.score < 0 ? 'warning' : 'none'
          }
        };
      }
      
      const { tradeReadinessScore, tradeReadinessLevel, directionBias, keyDrivers, redFlags, quickView } = tradeReadiness;
      
      // Show section
      section.classList.remove('hidden');
      
      // Determine label and color based on level
      let label, color, message, modeText;
      
      if (tradeReadinessLevel === 'DONT_BOTHER') {
        label = "DON'T BOTHER";
        color = '#ef4444';
        message = redFlags.length > 0 ? redFlags[0] : "Conditions are mid or conflicting. Not worth your focus right now.";
        modeText = "No clear edge";
      } else if (tradeReadinessLevel === 'WATCH') {
        label = "WATCH ONLY";
        color = '#f59e0b';
        message = keyDrivers.length > 0 ? keyDrivers[0] : "Some good signals, but not clean. Size small or wait for better confluence.";
        modeText = "Mixed conditions";
      } else {
        label = "PRIME SETUP";
        color = '#10b981';
        const dir = directionBias === 'long' ? 'Longs' : directionBias === 'short' ? 'Shorts' : 'Neutral';
        message = keyDrivers.length > 0 ? keyDrivers.slice(0, 2).join('  ') : "Prime trading conditions detected.";
        modeText = `Bias: ${dir.toUpperCase()}`;
      }
      
      // Update meter
      const scoreEl = document.getElementById('readiness-score');
      const labelEl = document.getElementById('readiness-label');
      const messageEl = document.getElementById('readiness-message');
      const modeEl = document.getElementById('readiness-mode');
      
      if (scoreEl) {
        scoreEl.textContent = tradeReadinessScore;
        scoreEl.style.color = color;
        scoreEl.style.textShadow = `0 0 30px ${color}, 0 0 60px ${color}40`;
      }
      if (labelEl) {
        labelEl.textContent = label;
        labelEl.style.color = color;
      }
      if (messageEl) {
        messageEl.textContent = message;
      }
      if (modeEl) {
        modeEl.textContent = modeText;
      }
      
      // Update key drivers and red flags display
      updateReadinessInsights(keyDrivers, redFlags, quickView);
      
      // Update breakdown tiles - show quickView status
      const breakdownEl = document.getElementById('readiness-breakdown');
      if (breakdownEl && quickView) {
        const tiles = [
          {
            title: 'HTF Alignment',
            status: quickView.htfAligned,
            icon: quickView.htfAligned ? '' : '',
            color: quickView.htfAligned ? '#10b981' : '#6b7280'
          },
          {
            title: 'Liquidity Clean',
            status: quickView.liquidityClean,
            icon: quickView.liquidityClean ? '' : '',
            color: quickView.liquidityClean ? '#10b981' : '#6b7280'
          },
          {
            title: 'Volatility Tradable',
            status: quickView.volatilityTradable,
            icon: quickView.volatilityTradable ? '' : '',
            color: quickView.volatilityTradable ? '#10b981' : '#6b7280'
          },
          {
            title: 'Structure Clean',
            status: quickView.structureClean,
            icon: quickView.structureClean ? '' : '',
            color: quickView.structureClean ? '#10b981' : '#6b7280'
          },
          {
            title: 'FVG Context',
            status: quickView.fvgContext !== 'none',
            icon: quickView.fvgContext === 'supportive' ? '' : quickView.fvgContext === 'opposite' ? '' : '',
            color: quickView.fvgContext === 'supportive' ? '#10b981' : quickView.fvgContext === 'opposite' ? '#ef4444' : '#6b7280'
          },
          {
            title: 'Divergence',
            status: quickView.divergenceContext !== 'none',
            icon: quickView.divergenceContext === 'supportive' ? '' : quickView.divergenceContext === 'warning' ? '' : '',
            color: quickView.divergenceContext === 'supportive' ? '#10b981' : quickView.divergenceContext === 'warning' ? '#ef4444' : '#6b7280'
          }
        ];
        
        breakdownEl.innerHTML = tiles.map(tile => {
          return `
            <div class="tf-card" style="padding: 1rem; border-color: ${tile.color}40;">
              <div style="position: relative; z-index: 1;">
                <div style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-bottom: 0.5rem; text-transform: uppercase;">${tile.title}</div>
                <div style="font-size: 2rem; font-weight: bold; color: ${tile.color}; margin-bottom: 0.25rem;">${tile.icon}</div>
                <div style="font-size: 0.875rem; color: ${tile.color}; font-weight: bold;">${tile.status ? 'GOOD' : 'CHECK'}</div>
              </div>
            </div>
          `;
        }).join('');
      }
      
      // Update active strategy signals
      const strategiesEl = document.getElementById('strategy-signals-list');
      const strategies = richSymbol?.strategies || {};
      
      if (strategiesEl) {
        const strategyList = [
          { key: 'TREND_RIDER', name: 'TREND_RIDER' },
          { key: 'TREND_4H', name: 'TREND_4H' },
          { key: 'SWING', name: 'SWING' },
          { key: 'SCALP_1H', name: 'SCALP_1H' },
          { key: 'MICRO_SCALP', name: 'MICRO_SCALP' }
        ];
        
        strategiesEl.innerHTML = strategyList.map(strat => {
          const s = strategies[strat.key];
          const isValid = s && s.valid === true;
          const direction = s?.direction || 'NO_TRADE';
          const confidence = s?.confidence || 0;
          
          const bgColor = isValid 
            ? (direction === 'LONG' || direction === 'long' ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)')
            : 'rgba(107, 114, 128, 0.1)';
          const borderColor = isValid 
            ? (direction === 'LONG' || direction === 'long' ? '#10b981' : '#ef4444')
            : 'rgba(255, 255, 255, 0.1)';
          const textColor = isValid 
            ? (direction === 'LONG' || direction === 'long' ? '#10b981' : '#ef4444')
            : 'rgba(255, 255, 255, 0.4)';
          
          return `
            <div class="tf-card" style="padding: 1rem; background: ${bgColor}; border-color: ${borderColor};">
              <div style="position: relative; z-index: 1;">
                <div style="font-size: 0.875rem; font-weight: bold; color: ${textColor}; margin-bottom: 0.5rem;">${strat.name}</div>
                <div style="font-size: 1.25rem; font-weight: bold; color: ${textColor}; margin-bottom: 0.25rem;">
                  ${isValid ? direction.toUpperCase() : 'NO_TRADE'}
                </div>
                <div style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.7);">
                  ${isValid ? `${confidence}% confidence` : 'No setup'}
                </div>
              </div>
            </div>
          `;
        }).join('');
      }
      
      // Note: AI Breakdown is now updated in updateHighLevelDashboard() with all scanResults
    }
    
    // Update Readiness Insights (Key Drivers & Red Flags)
    function updateReadinessInsights(keyDrivers, redFlags, quickView) {
      // Add a new section for key drivers and red flags if it doesn't exist
      let insightsSection = document.getElementById('readiness-insights');
      if (!insightsSection) {
        const meterSection = document.getElementById('readiness-meter');
        if (meterSection && meterSection.parentElement) {
          insightsSection = document.createElement('div');
          insightsSection.id = 'readiness-insights';
          insightsSection.style.marginTop = '2rem';
          insightsSection.style.paddingTop = '2rem';
          insightsSection.style.borderTop = '1px solid rgba(255, 255, 255, 0.1)';
          meterSection.parentElement.insertBefore(insightsSection, meterSection.nextSibling);
        } else {
          return;
        }
      }
      
      let html = '<div style="font-family: var(--font-mathias); font-size: 1.125rem; color: var(--color-yellow-75); margin-bottom: 1rem; font-weight: bold;">Quick Insights</div>';
      
      // Key Drivers
      if (keyDrivers && keyDrivers.length > 0) {
        html += '<div style="margin-bottom: 1.5rem;">';
        html += '<div style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 0.5rem; text-transform: uppercase;">Key Drivers</div>';
        html += '<div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">';
        keyDrivers.slice(0, 5).forEach(driver => {
          html += `<span style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.5); padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.875rem; color: #10b981;"> ${driver}</span>`;
        });
        html += '</div></div>';
      }
      
      // Red Flags
      if (redFlags && redFlags.length > 0) {
        html += '<div>';
        html += '<div style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6); margin-bottom: 0.5rem; text-transform: uppercase;">Red Flags</div>';
        html += '<div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">';
        redFlags.slice(0, 3).forEach(flag => {
          html += `<span style="background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.5); padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.875rem; color: #ef4444;"> ${flag}</span>`;
        });
        html += '</div></div>';
      }
      
      insightsSection.innerHTML = html;
    }
    
    // Collect all valid trade signals from scanResults
    function collectAllTradeSignals(allScanResults) {
      const allSignals = [];
      
      Object.entries(allScanResults).forEach(([symbol, data]) => {
        if (!data || data.error) return;
        
        const richSymbol = data?.richSymbol || data;
        const strategies = richSymbol?.strategies || {};
        const timeframes = richSymbol?.timeframes || {};
        const currentPrice = richSymbol?.currentPrice || data?.currentPrice || 0;
        
        // Check each strategy type
        Object.entries(strategies).forEach(([strategyKey, strategy]) => {
          if (strategy && strategy.valid) {
            // Get trade readiness for this symbol
            const readinessScore = calculateTradeReadinessScore(richSymbol, timeframes, currentPrice);
            
            // Map strategy key to readable name
            const strategyNames = {
              'TREND_4H': '4H',
              'SWING': 'Swing',
              'SCALP_1H': 'Scalp',
              'MICRO_SCALP': 'MicroScalp'
            };
            
            allSignals.push({
              symbol,
              strategy: strategyNames[strategyKey] || strategyKey,
              strategyKey: strategyKey,
              direction: strategy.direction,
              confidence: strategy.confidence || 0,
              entryZone: strategy.entryZone || strategy.entry_zone,
              stopLoss: strategy.stopLoss || strategy.stop_loss,
              targets: strategy.targets,
              readinessScore: readinessScore.score,
              readinessBreakdown: readinessScore.breakdown,
              readinessPlayType: readinessScore.playType,
              htfBias: richSymbol?.htfBias,
              timeframes: timeframes,
              currentPrice: currentPrice,
              reason: strategy.reason || strategy.reason_summary || ''
            });
          }
        });
      });
      
      return allSignals;
    }
    
    // Rank signals by readiness score + confidence
    function rankSignals(signals) {
      return signals.sort((a, b) => {
        const scoreA = (a.readinessScore || 0) * 0.6 + (a.confidence || 0) * 0.4;
        const scoreB = (b.readinessScore || 0) * 0.6 + (b.confidence || 0) * 0.4;
        return scoreB - scoreA;
      });
    }
    
    // Analyze all trade signals using AI
    async function analyzeAllTradeSignals(signals) {
      if (!signals || signals.length === 0) {
        return {
          bestTrade: null,
          analysis: 'No valid trade signals found. Market conditions may not be favorable for trading right now.',
          topSignals: []
        };
      }
      
      // Get top 3 signals
      const topSignals = signals.slice(0, 3);
      
      // Build context for AI
      const signalsContext = topSignals.map(signal => ({
        symbol: signal.symbol,
        strategy: signal.strategy,
        direction: signal.direction,
        confidence: signal.confidence,
        readinessScore: signal.readinessScore,
        entryZone: signal.entryZone,
        stopLoss: signal.stopLoss,
        targets: signal.targets,
        readinessBreakdown: signal.readinessBreakdown,
        htfBias: signal.htfBias
      }));
      
      try {
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            tradesData: {
              signals: signalsContext,
              totalSignals: signals.length,
              topSignals: topSignals.length
            },
            systemPrompt: `You're an expert trader analyzing live signals. Give quick snapshots, real talk only.

WHAT TO DO:
1. Call out the STRONGEST signals - why they're fire, what entry to hit
2. Best price entry for each - be specific with numbers
3. Market state snapshot - what's actually happening
4. Risk factors - what could go wrong, be honest

STYLE:
- Talk like a trader: "BTC short looks clean, entry around $89.2k, structure's aligned"
- Quick snapshots, not long analysis
- Use readiness scores to back your calls
- If something's mid, say it's mid - don't sugarcoat
- Real talk: "This one's risky because..." or "This is the play right now because..."

FOCUS:
- Readiness score tells you if it's worth it
- HTF alignment = trend is clean
- Entry zone = where to get in
- Structure = is it clean or messy
- Confluence = multiple things lining up

Keep it tight, actionable, and real. No fluff.`
          })
        });
        
        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        return {
          bestTrade: topSignals[0] || null,
          analysis: data.review || data.pulse || 'Analysis completed',
          topSignals: topSignals
        };
      } catch (error) {
        console.error('[analyzeAllTradeSignals] Error:', error);
        // Fallback to local analysis
        return {
          bestTrade: topSignals[0] || null,
          analysis: generateLocalAnalysis(topSignals),
          topSignals: topSignals
        };
      }
    }
    
    // Generate local analysis fallback
    function generateLocalAnalysis(topSignals) {
      if (topSignals.length === 0) {
        return 'No valid trade signals found.';
      }
      
      const best = topSignals[0];
      const entryZone = best.entryZone || {};
      const bestEntry = entryZone.min ? `$${entryZone.min.toLocaleString()}` : 'N/A';
      
      let analysis = ` STRONGEST SIGNAL: ${best.symbol} ${best.direction} (${best.strategy} strategy)\n\n`;
      analysis += `Readiness Score: ${best.readinessScore}/100 | Confidence: ${best.confidence}%\n\n`;
      analysis += `BEST ENTRY: ${bestEntry}`;
      if (entryZone.max) {
        analysis += ` - $${entryZone.max.toLocaleString()}`;
      }
      analysis += `\n\nWhy it's strong:\n`;
      
      const breakdown = best.readinessBreakdown || {};
      if (breakdown.htfAlignment?.score >= 25) {
        analysis += ` HTF alignment: ${breakdown.htfAlignment.details}\n`;
      }
      if (breakdown.structureLiquidity?.score >= 15) {
        analysis += ` Structure: ${breakdown.structureLiquidity.details}\n`;
      }
      if (breakdown.fvgContext?.score >= 7) {
        analysis += ` FVG context: ${breakdown.fvgContext.details}\n`;
      }
      
      if (topSignals.length > 1) {
        analysis += `\nOther strong signals: ${topSignals.slice(1).map(s => `${s.symbol} ${s.direction} (${s.readinessScore}/100)`).join(', ')}`;
      }
      
      return analysis;
    }
    
    // Update AI Trade Breakdown - Enhanced to analyze all signals
    async function updateAITradeBreakdown(allScanResults) {
      const bestTradeEl = document.getElementById('ai-best-trade');
      const breakdownEl = document.getElementById('ai-breakdown-text');
      
      if (!bestTradeEl || !breakdownEl) {
        console.warn('[updateAITradeBreakdown] AI breakdown elements not found');
        return;
      }
      
      // Show loading state
      bestTradeEl.innerHTML = 'Analyzing all trade signals...';
      breakdownEl.innerHTML = 'Collecting signals and calculating readiness scores...';
      
      try {
        // Collect all signals
        const allSignals = collectAllTradeSignals(allScanResults);
        console.log(`[updateAITradeBreakdown] Collected ${allSignals.length} signals`);
        
        if (allSignals.length === 0) {
          bestTradeEl.innerHTML = '<span style="color: #ef4444;"> NO TRADE SIGNALS FOUND</span>';
          breakdownEl.innerHTML = `
            <div style="margin-bottom: 1rem;">
              No valid trade signals detected across all symbols. Market conditions may not be favorable for trading right now.
            </div>
            <div>
              Check back when market structure improves or wait for better confluence.
            </div>
          `;
          return;
        }
        
        // Rank signals
        const rankedSignals = rankSignals([...allSignals]);
        
        // Analyze with AI
        const analysis = await analyzeAllTradeSignals(rankedSignals);
        
        // Display results
        if (analysis.bestTrade) {
          const best = analysis.bestTrade;
          const direction = best.direction === 'LONG' || best.direction === 'long' ? 'LONG' : 'SHORT';
          const entryZone = best.entryZone || {};
          const bestEntry = entryZone.min ? `$${entryZone.min.toLocaleString()}` : 'N/A';
          
          bestTradeEl.innerHTML = ` <span style="color: var(--color-yellow-75);">${best.symbol}</span> ${direction} (${best.strategy}) - Readiness: ${best.readinessScore}/100`;
          
          breakdownEl.innerHTML = `
            <div style="margin-bottom: 1rem;">
              <strong style="color: var(--color-yellow-75);">BEST ENTRY:</strong> ${bestEntry}${entryZone.max ? ` - $${entryZone.max.toLocaleString()}` : ''}
            </div>
            <div style="margin-bottom: 1rem; white-space: pre-wrap; line-height: 1.6;">
              ${analysis.analysis}
            </div>
            ${analysis.topSignals.length > 1 ? `
            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <strong style="color: var(--color-yellow-75);">Other Strong Signals:</strong>
              <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                ${analysis.topSignals.slice(1).map(s => `
                  <li style="margin-bottom: 0.5rem;">
                    ${s.symbol} ${s.direction} (${s.strategy}) - Score: ${s.readinessScore}/100 | Entry: ${s.entryZone?.min ? `$${s.entryZone.min.toLocaleString()}` : 'N/A'}
                  </li>
                `).join('')}
              </ul>
            </div>
            ` : ''}
          `;
        } else {
          bestTradeEl.innerHTML = '<span style="color: #f59e0b;"> CONDITIONS ARE MIXED</span>';
          breakdownEl.innerHTML = `
            <div style="margin-bottom: 1rem; white-space: pre-wrap;">
              ${analysis.analysis}
            </div>
          `;
        }
      } catch (error) {
        console.error('[updateAITradeBreakdown] Error:', error);
        bestTradeEl.innerHTML = '<span style="color: #ef4444;"> ANALYSIS ERROR</span>';
        breakdownEl.innerHTML = `
          <div style="margin-bottom: 1rem;">
            Error analyzing trade signals: ${error.message}
          </div>
          <div>
            Please try refreshing the page or check your connection.
          </div>
        `;
      }
    }
    
    // Chat Functions
    function getChatContext() {
      // Build context from current scanResults for AI
      const allSignals = collectAllTradeSignals(scanResults || {});
      const rankedSignals = rankSignals([...allSignals]);
      
      // Build market state summary
      const marketState = {
        totalSignals: allSignals.length,
        topSignals: rankedSignals.slice(0, 5).map(s => ({
          symbol: s.symbol,
          strategy: s.strategy,
          direction: s.direction,
          confidence: s.confidence,
          readinessScore: s.readinessScore,
          entryZone: s.entryZone,
          htfBias: s.htfBias
        })),
        symbols: Object.keys(scanResults || {}).filter(s => scanResults[s] && !scanResults[s].error),
        currentMode: aggressiveMode ? 'AGGRESSIVE' : 'STANDARD'
      };
      
      // Ensure we always return a valid object structure
      return {
        signals: marketState,
        marketData: {
          totalSignals: marketState.totalSignals,
          topSignals: marketState.topSignals,
          symbols: marketState.symbols,
          mode: marketState.currentMode
        },
        timestamp: new Date().toISOString()
      };
    }
    
    function displayChatMessage(role, content) {
      const messagesContainer = document.getElementById('ai-chat-messages');
      if (!messagesContainer) return;
      
      // Remove placeholder if it exists
      const placeholder = messagesContainer.querySelector('div[style*="text-align: center"]');
      if (placeholder) {
        placeholder.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.style.cssText = `
        margin-bottom: 1rem;
        padding: 0.75rem;
        border-radius: var(--radius-md);
        font-family: var(--font-system);
        font-size: 0.875rem;
        line-height: 1.6;
        ${role === 'user' 
          ? 'background: rgba(230, 233, 224, 0.1); border-left: 3px solid var(--color-yellow-75); color: rgba(255, 255, 255, 0.9);' 
          : 'background: rgba(0, 0, 0, 0.3); border-left: 3px solid rgba(255, 255, 255, 0.3); color: rgba(255, 255, 255, 0.8);'}
      `;
      
      if (role === 'user') {
        messageDiv.innerHTML = `
          <div style="font-weight: bold; color: var(--color-yellow-75); margin-bottom: 0.5rem; font-family: var(--font-mathias); font-size: 0.75rem; text-transform: uppercase;">
            YOU
          </div>
          <div style="white-space: pre-wrap;">${content}</div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div style="font-weight: bold; color: rgba(255, 255, 255, 0.7); margin-bottom: 0.5rem; font-family: var(--font-mathias); font-size: 0.75rem; text-transform: uppercase;">
            AI
          </div>
          <div style="white-space: pre-wrap;">${content}</div>
        `;
      }
      
      messagesContainer.appendChild(messageDiv);
      
      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    async function sendChatMessage() {
      const input = document.getElementById('ai-chat-input');
      const sendButton = document.getElementById('ai-chat-send');
      
      if (!input || !sendButton) return;
      
      const message = input.value.trim();
      if (!message) return;
      
      // Clear input
      input.value = '';
      
      // Disable input and button
      input.disabled = true;
      sendButton.disabled = true;
      sendButton.textContent = 'SENDING...';
      
      // Display user message
      displayChatMessage('user', message);
      
      // Show loading message
      const loadingId = 'loading-' + Date.now();
      const loadingDiv = document.createElement('div');
      loadingDiv.id = loadingId;
      loadingDiv.style.cssText = `
        margin-bottom: 1rem;
        padding: 0.75rem;
        border-radius: var(--radius-md);
        background: rgba(0, 0, 0, 0.3);
        border-left: 3px solid rgba(255, 255, 255, 0.3);
        color: rgba(255, 255, 255, 0.6);
        font-family: var(--font-system);
        font-size: 0.875rem;
        font-style: italic;
      `;
      loadingDiv.textContent = 'AI is thinking...';
      const messagesContainer = document.getElementById('ai-chat-messages');
      messagesContainer.appendChild(loadingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      try {
        // Get context
        const context = getChatContext();
        
        // Build tradesData with user question prominently included
        const tradesDataWithQuestion = {
          userQuestion: message,
          questionToAnswer: `USER IS ASKING: "${message}" - Please answer this specific question using the market data below.`,
          ...context
        };
        
        // Build system prompt for chat - Expert trader voice
        const systemPrompt = `You're an expert crypto trader. The user asked a specific question - ANSWER IT DIRECTLY.

CRITICAL: Look for the "QUESTION TO ANSWER" section in the user's message. That's what they want to know. Answer it specifically using the market data provided.

STYLE:
- Talk like you're texting a trading buddy - casual but sharp
- Give quick snapshots, not essays
- Use trader slang naturally (HTF, LTF, BOS, FVG, etc.)
- Be direct: "This looks good" or "Skip this, structure's messy"
- Call out what matters: entry price, why it's strong, what could go wrong
- Real talk only - if something's mid, say it's mid

WHAT TO DO:
1. READ the question carefully - it's marked "QUESTION TO ANSWER"
2. ANSWER that specific question using the market data
3. Be SPECIFIC: 
   - If they ask "best trade"  Tell them which symbol/strategy and WHY
   - If they ask "entry price"  Give them the exact dollar amount
   - If they ask "market state"  Tell them what's actually happening
   - If they ask "why is X strong"  Explain using readiness score, HTF alignment, etc.
4. Use the data: Reference specific signals, scores, entry zones from the market snapshot
5. Give numbers: Entry prices, confidence scores, readiness scores - be concrete

TONE:
- Confident but not cocky
- Helpful but not hand-holdy
- Fast-paced, like you're watching the charts live
- Drop the formal analysis language - just tell it like it is

Remember: They asked a specific question. Answer it directly with real trader insight and specific data.`;
        
        // Validate data before sending
        if (!tradesDataWithQuestion || !systemPrompt) {
          throw new Error('Failed to prepare request data');
        }
        
        const requestBody = {
          tradesData: tradesDataWithQuestion,
          systemPrompt: systemPrompt
        };
        
        console.log('[sendChatMessage] Sending request:', {
          hasTradesData: !!requestBody.tradesData,
          hasSystemPrompt: !!requestBody.systemPrompt,
          tradesDataKeys: Object.keys(requestBody.tradesData || {}),
          systemPromptLength: requestBody.systemPrompt?.length
        });
        
        // Call API
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('[sendChatMessage] API error response:', errorText);
          let errorMessage = `API error: ${response.status}`;
          try {
            const errorJson = JSON.parse(errorText);
            errorMessage = errorJson.error || errorJson.message || errorMessage;
          } catch (e) {
            // Not JSON, use text as-is
            errorMessage = errorText || errorMessage;
          }
          throw new Error(errorMessage);
        }
        
        const data = await response.json();
        const aiResponse = data.review || data.pulse || 'I apologize, but I could not generate a response. Please try again.';
        
        // Remove loading message
        const loadingEl = document.getElementById(loadingId);
        if (loadingEl) {
          loadingEl.remove();
        }
        
        // Display AI response
        displayChatMessage('assistant', aiResponse);
        
      } catch (error) {
        console.error('[sendChatMessage] Error:', error);
        
        // Remove loading message
        const loadingEl = document.getElementById(loadingId);
        if (loadingEl) {
          loadingEl.remove();
        }
        
        // Display error message
        displayChatMessage('assistant', `Sorry, I encountered an error: ${error.message}. Please try again.`);
      } finally {
        // Re-enable input and button
        input.disabled = false;
        sendButton.disabled = false;
        sendButton.textContent = 'SEND';
        input.focus();
      }
    }
    
    // Update HTF Trend State
    function updateHTFTrendState(timeframes, htfBias, currentPrice) {
      const tf1d = timeframes['1d'];
      const tf4h = timeframes['4h'];
      const tf1h = timeframes['1h'];
      
      const tfs = [
        { key: '1d', data: tf1d, el: document.querySelector('.htf-tf[data-tf="1d"]') },
        { key: '4h', data: tf4h, el: document.querySelector('.htf-tf[data-tf="4h"]') },
        { key: '1h', data: tf1h, el: document.querySelector('.htf-tf[data-tf="1h"]') }
      ];
      
      let allAligned = true;
      let alignedDirection = null;
      let alignedCount = 0;
      
      tfs.forEach(({ key, data, el }) => {
        if (!el) return;
        
        const trendValue = el.querySelector('.htf-trend-value');
        const confidence = el.querySelector('.htf-confidence');
        
        if (!data || !data.trend) {
          if (trendValue) trendValue.textContent = '-';
          if (trendValue) trendValue.style.color = 'rgba(255, 255, 255, 0.4)';
          if (confidence) confidence.textContent = '-';
          allAligned = false;
          return;
        }
        
        const trend = String(data.trend).toLowerCase();
        const isUp = trend.includes('up');
        const isDown = trend.includes('down');
        const isFlat = !isUp && !isDown;
        
        if (isUp) {
          if (trendValue) {
            trendValue.textContent = '';
            trendValue.style.color = '#10b981';
          }
          alignedDirection = alignedDirection || 'up';
          if (alignedDirection === 'up') alignedCount++;
          else allAligned = false;
        } else if (isDown) {
          if (trendValue) {
            trendValue.textContent = '';
            trendValue.style.color = '#ef4444';
          }
          alignedDirection = alignedDirection || 'down';
          if (alignedDirection === 'down') alignedCount++;
          else allAligned = false;
        } else {
          if (trendValue) {
            trendValue.textContent = '';
            trendValue.style.color = 'rgba(255, 255, 255, 0.4)';
          }
          allAligned = false;
        }
        
        // Confidence from EMA alignment
        const ema21 = data.ema21;
        const ema200 = data.ema200;
        const price = currentPrice || 0;
        let conf = 0;
        if (ema21 && ema200 && price) {
          if (isUp && price > ema21 && ema21 > ema200) conf = 85;
          else if (isDown && price < ema21 && ema21 < ema200) conf = 85;
          else if (isUp && price > ema21) conf = 60;
          else if (isDown && price < ema21) conf = 60;
        }
        if (confidence) confidence.textContent = conf > 0 ? `${conf}%` : '-';
      });
      
      // Update alignment status
      const statusEl = document.getElementById('htf-alignment-status');
      const card = document.getElementById('htf-trend-card');
      
      if (allAligned && alignedCount === 3) {
        statusEl.innerHTML = `<span style="color: ${alignedDirection === 'up' ? '#10b981' : '#ef4444'}; text-shadow: 0 0 20px ${alignedDirection === 'up' ? 'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)'};">
           ALL ALIGNED - PAY ATTENTION
        </span>`;
        card.className = `dashboard-card tf-card ${alignedDirection === 'up' ? 'uptrend' : 'downtrend'}`;
      } else if (alignedCount >= 2) {
        statusEl.innerHTML = `<span style="color: rgba(255, 255, 255, 0.7);">
          ${alignedCount}/3 Aligned
        </span>`;
        card.className = `dashboard-card tf-card ${alignedDirection === 'up' ? 'uptrend' : alignedDirection === 'down' ? 'downtrend' : 'flat'}`;
      } else {
        statusEl.innerHTML = `<span style="color: rgba(255, 255, 255, 0.4);">
          No Clear Alignment
        </span>`;
        card.className = 'dashboard-card tf-card flat';
      }
    }
    
    // Update Liquidity Map
    function updateLiquidityMap(timeframes, currentPrice) {
      const tf4h = timeframes['4h'];
      const lz = tf4h?.liquidityZones || [];
      
      const equalHighs = lz.filter(z => z.type === 'equal_highs').sort((a, b) => a.price - b.price);
      const equalLows = lz.filter(z => z.type === 'equal_lows').sort((a, b) => a.price - b.price);
      
      const highsEl = document.getElementById('liquidity-highs');
      const lowsEl = document.getElementById('liquidity-lows');
      const biasEl = document.getElementById('liquidity-bias');
      
      // Display equal highs
      if (equalHighs.length > 0) {
        highsEl.innerHTML = equalHighs.slice(0, 5).map(z => {
          const pct = currentPrice > 0 ? ((z.price - currentPrice) / currentPrice * 100).toFixed(1) : 0;
          return `<span style="background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.5); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem; color: #ef4444; font-weight: bold;">
            ${z.price.toLocaleString()} (+${pct}%)
          </span>`;
        }).join('');
      } else {
        highsEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.4);">None</span>';
      }
      
      // Display equal lows
      if (equalLows.length > 0) {
        lowsEl.innerHTML = equalLows.slice(0, 5).map(z => {
          const pct = currentPrice > 0 ? ((currentPrice - z.price) / currentPrice * 100).toFixed(1) : 0;
          return `<span style="background: rgba(16, 185, 129, 0.2); border: 1px solid rgba(16, 185, 129, 0.5); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem; color: #10b981; font-weight: bold;">
            ${z.price.toLocaleString()} (-${pct}%)
          </span>`;
        }).join('');
      } else {
        lowsEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.4);">None</span>';
      }
      
      // Determine bias
      const highStrength = equalHighs.reduce((sum, z) => sum + (z.strength || 0), 0);
      const lowStrength = equalLows.reduce((sum, z) => sum + (z.strength || 0), 0);
      
      if (highStrength > lowStrength * 1.5) {
        biasEl.innerHTML = '<span style="color: #ef4444; text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);"> More Liquidity Above  Expect Sweep Down</span>';
      } else if (lowStrength > highStrength * 1.5) {
        biasEl.innerHTML = '<span style="color: #10b981; text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"> More Liquidity Below  Expect Sweep Up</span>';
      } else {
        biasEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.6);">Balanced Liquidity</span>';
      }
    }
    
    // Update FVG State
    function updateFVGState(timeframes, currentPrice) {
      const tf4h = timeframes['4h'];
      const tf1h = timeframes['1h'];
      const fvgs4h = tf4h?.fairValueGaps || [];
      const fvgs1h = tf1h?.fairValueGaps || [];
      const allFvgs = [...fvgs4h, ...fvgs1h];
      
      const bullishFvgs = allFvgs.filter(f => f.direction === 'bullish' && !f.filled);
      const bearishFvgs = allFvgs.filter(f => f.direction === 'bearish' && !f.filled);
      
      const bullishEl = document.getElementById('fvg-bullish');
      const bullishStatusEl = document.getElementById('fvg-bullish-status');
      const bearishEl = document.getElementById('fvg-bearish');
      const bearishStatusEl = document.getElementById('fvg-bearish-status');
      const priceStatusEl = document.getElementById('fvg-price-status');
      const card = document.getElementById('fvg-card');
      
      bullishEl.textContent = bullishFvgs.length;
      bearishEl.textContent = bearishFvgs.length;
      
      bullishStatusEl.textContent = bullishFvgs.length > 0 
        ? `${bullishFvgs.filter(f => currentPrice > f.low && currentPrice < f.high).length} below price`
        : 'None';
      bearishStatusEl.textContent = bearishFvgs.length > 0
        ? `${bearishFvgs.filter(f => currentPrice > f.low && currentPrice < f.high).length} above price`
        : 'None';
      
      // Check if price is inside an FVG
      const priceInBullishFvg = bullishFvgs.some(f => currentPrice > f.low && currentPrice < f.high);
      const priceInBearishFvg = bearishFvgs.some(f => currentPrice > f.low && currentPrice < f.high);
      
      if (priceInBullishFvg) {
        priceStatusEl.innerHTML = '<span style="color: #10b981; text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"> Price Inside Bullish FVG  High Probability Move</span>';
        card.className = 'dashboard-card tf-card uptrend';
      } else if (priceInBearishFvg) {
        priceStatusEl.innerHTML = '<span style="color: #ef4444; text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);"> Price Inside Bearish FVG  High Probability Move</span>';
        card.className = 'dashboard-card tf-card downtrend';
      } else {
        priceStatusEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.6);">Price Outside FVGs</span>';
        card.className = 'dashboard-card tf-card flat';
      }
    }
    
    // Update Divergence Alerts
    function updateDivergenceAlerts(timeframes) {
      const tf1h = timeframes['1h'];
      const tf15m = timeframes['15m'];
      
      const divs1h = tf1h?.divergences || [];
      const divs15m = tf15m?.divergences || [];
      
      const rsiDivs = divs1h.filter(d => d.oscillator === 'RSI');
      const stochDivs = divs15m.filter(d => d.oscillator === 'StochRSI');
      
      const rsiEl = document.getElementById('div-rsi');
      const rsiDetailEl = document.getElementById('div-rsi-detail');
      const stochEl = document.getElementById('div-stoch');
      const stochDetailEl = document.getElementById('div-stoch-detail');
      const alertEl = document.getElementById('divergence-alert');
      const card = document.getElementById('divergence-card');
      
      if (rsiDivs.length > 0) {
        const bullish = rsiDivs.filter(d => d.side === 'bullish').length;
        const bearish = rsiDivs.filter(d => d.side === 'bearish').length;
        rsiEl.textContent = bullish > bearish ? '' : bearish > bullish ? '' : '';
        rsiEl.style.color = bullish > bearish ? '#10b981' : bearish > bullish ? '#ef4444' : 'rgba(255, 255, 255, 0.4)';
        rsiDetailEl.textContent = `${bullish}B ${bearish}S`;
      } else {
        rsiEl.textContent = '';
        rsiEl.style.color = 'rgba(255, 255, 255, 0.4)';
        rsiDetailEl.textContent = 'None';
      }
      
      if (stochDivs.length > 0) {
        const bullish = stochDivs.filter(d => d.side === 'bullish').length;
        const bearish = stochDivs.filter(d => d.side === 'bearish').length;
        stochEl.textContent = bullish > bearish ? '' : bearish > bullish ? '' : '';
        stochEl.style.color = bullish > bearish ? '#10b981' : bearish > bullish ? '#ef4444' : 'rgba(255, 255, 255, 0.4)';
        stochDetailEl.textContent = `${bullish}B ${bearish}S`;
      } else {
        stochEl.textContent = '';
        stochEl.style.color = 'rgba(255, 255, 255, 0.4)';
        stochDetailEl.textContent = 'None';
      }
      
      // Check for significant divergence
      const allDivs = [...rsiDivs, ...stochDivs];
      const bullishDivs = allDivs.filter(d => d.side === 'bullish');
      const bearishDivs = allDivs.filter(d => d.side === 'bearish');
      
      if (bullishDivs.length >= 2) {
        alertEl.innerHTML = '<span style="color: #10b981; text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"> Multiple Bullish Divergences  Reversal Signal</span>';
        card.className = 'dashboard-card tf-card uptrend';
      } else if (bearishDivs.length >= 2) {
        alertEl.innerHTML = '<span style="color: #ef4444; text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);"> Multiple Bearish Divergences  Reversal Signal</span>';
        card.className = 'dashboard-card tf-card downtrend';
      } else if (allDivs.length > 0) {
        alertEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.7);">Divergence Detected</span>';
        card.className = 'dashboard-card tf-card flat';
      } else {
        alertEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.4);">No Divergences</span>';
        card.className = 'dashboard-card tf-card flat';
      }
    }
    
    // Update Volatility State
    function updateVolatilityState(timeframes) {
      const tf4h = timeframes['4h'];
      const vol = tf4h?.volatility;
      
      const atrValueEl = document.getElementById('atr-value');
      const atrStateEl = document.getElementById('atr-state');
      const atrStatusEl = document.getElementById('atr-status');
      const card = document.getElementById('volatility-card');
      
      if (!vol || vol.atrPctOfPrice === null || vol.atrPctOfPrice === undefined) {
        atrValueEl.textContent = '-';
        atrStateEl.textContent = '-';
        atrStatusEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.4);">No Data</span>';
        card.className = 'dashboard-card tf-card flat';
        return;
      }
      
      const atrPct = vol.atrPctOfPrice;
      const state = vol.state || 'normal';
      
      atrValueEl.textContent = `${atrPct.toFixed(2)}%`;
      atrStateEl.textContent = state.toUpperCase();
      
      // Color code based on state
      if (state === 'extreme') {
        atrValueEl.style.color = '#ef4444';
        atrStateEl.style.color = '#ef4444';
        atrStatusEl.innerHTML = '<span style="color: #ef4444; text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);"> EXTREME  No Trades / Reduce Risk</span>';
        card.className = 'dashboard-card tf-card downtrend';
      } else if (state === 'high') {
        atrValueEl.style.color = '#f59e0b';
        atrStateEl.style.color = '#f59e0b';
        atrStatusEl.innerHTML = '<span style="color: #f59e0b;">High Volatility  Caution</span>';
        card.className = 'dashboard-card tf-card flat';
      } else if (state === 'normal') {
        atrValueEl.style.color = '#10b981';
        atrStateEl.style.color = '#10b981';
        atrStatusEl.innerHTML = '<span style="color: #10b981; text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"> Normal  Prime Trading Conditions</span>';
        card.className = 'dashboard-card tf-card uptrend';
      } else {
        atrValueEl.style.color = '#6b7280';
        atrStateEl.style.color = '#6b7280';
        atrStatusEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.6);">Low Volatility</span>';
        card.className = 'dashboard-card tf-card flat';
      }
    }
    
    // Update Volume Profile Bias
    function updateVolumeProfileBias(timeframes, currentPrice) {
      const tf4h = timeframes['4h'];
      const vp = tf4h?.volumeProfile;
      
      const vahLabel = document.getElementById('vah-label');
      const valLabel = document.getElementById('val-label');
      const priceLabel = document.getElementById('price-label');
      const vahLine = document.getElementById('vah-line');
      const valLine = document.getElementById('val-line');
      const priceLine = document.getElementById('price-line');
      const biasEl = document.getElementById('vp-bias');
      const card = document.getElementById('volume-profile-card');
      
      if (!vp || !vp.valueAreaHigh || !vp.valueAreaLow || !currentPrice) {
        vahLabel.textContent = 'VAH: -';
        valLabel.textContent = 'VAL: -';
        priceLabel.textContent = 'PRICE';
        biasEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.4);">No Data</span>';
        card.className = 'dashboard-card tf-card flat';
        return;
      }
      
      const vah = vp.valueAreaHigh;
      const val = vp.valueAreaLow;
      const range = vah - val;
      
      // Calculate position (0 = VAL, 100 = VAH)
      const position = range > 0 ? ((currentPrice - val) / range) * 100 : 50;
      const positionPct = Math.max(0, Math.min(100, position));
      
      // Update visual position
      priceLine.style.top = `${100 - positionPct}%`;
      priceLabel.style.top = `${100 - positionPct}%`;
      
      vahLabel.textContent = `VAH: ${vah.toLocaleString()}`;
      valLabel.textContent = `VAL: ${val.toLocaleString()}`;
      priceLabel.textContent = currentPrice.toLocaleString();
      
      // Determine bias
      if (currentPrice <= val) {
        biasEl.innerHTML = '<span style="color: #10b981; text-shadow: 0 0 10px rgba(16, 185, 129, 0.5); font-size: 1.75rem;"> BELOW VAL  Excellent Long R:R</span>';
        card.className = 'dashboard-card tf-card uptrend';
      } else if (currentPrice >= vah) {
        biasEl.innerHTML = '<span style="color: #ef4444; text-shadow: 0 0 10px rgba(239, 68, 68, 0.5); font-size: 1.75rem;"> ABOVE VAH  Excellent Short R:R</span>';
        card.className = 'dashboard-card tf-card downtrend';
      } else {
        const mid = (vah + val) / 2;
        if (currentPrice < mid) {
          biasEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.7);">In Value Area (Lower Half)</span>';
        } else {
          biasEl.innerHTML = '<span style="color: rgba(255, 255, 255, 0.7);">In Value Area (Upper Half)</span>';
        }
        card.className = 'dashboard-card tf-card flat';
      }
    }

    // Calculate signal readiness (proximity to trade setup)
    function calculateSignalReadiness(data) {
      if (!data || !data.analysis) {
        return { score: 0, text: 'No data', class: 'status-neutral' };
      }
      
      const signal = data.tradeSignal;
      if (signal && signal.valid) {
        // Valid trade signal = 100% ready
        return { 
          score: 100, 
          text: 'READY', 
          class: signal.direction === 'long' ? 'status-long' : 'status-short'
        };
      }
      
      // Calculate proximity based on indicator alignment
      const timeframes = ['4h', '1h', '15m', '5m'];
      let aligned = 0;
      let total = 0;
      let direction = null;
      
      // Guard: Ensure analysis exists
      if (!data.analysis) {
        return { score: 0, text: 'No data', class: 'status-neutral' };
      }
      
      timeframes.forEach(tf => {
        const analysis = data.analysis[tf];
        if (analysis && analysis.indicators) {
          const trend = analysis.indicators.analysis?.trend;
          const stochCond = analysis.indicators.stochRSI?.condition;
          const pullbackState = analysis.indicators.analysis?.pullbackState;
          
          if (trend === 'UPTREND' || trend === 'DOWNTREND') {
            total += 3;
            if (!direction) direction = trend;
            
            // Count alignment factors
            if (trend === direction) aligned += 1;
            if ((direction === 'UPTREND' && (stochCond === 'OVERSOLD' || stochCond === 'BULLISH')) ||
                (direction === 'DOWNTREND' && (stochCond === 'OVERBOUGHT' || stochCond === 'BEARISH'))) {
              aligned += 1;
            }
            if (pullbackState === 'ENTRY_ZONE') aligned += 1;
          }
        }
      });
      
      if (total === 0) {
        return { score: 0, text: 'No trend', class: 'status-neutral' };
      }
      
      const proximityPct = Math.round((aligned / total) * 100);
      const awayPct = 100 - proximityPct;
      
      return {
        score: proximityPct,
        text: `${awayPct}% away`,
        class: proximityPct > 70 ? 'status-long' : proximityPct > 40 ? 'text-yellow-400' : 'status-neutral'
      };
    }

    // Create table row for coin
    function createCoinRow(symbol, data) {
      const row = document.createElement('tr');
      row.id = `row-${symbol}`;
      
      // Get current strategy for this symbol FIRST
      const currentStrategyIndex = strategyStates[symbol] || 0;
      const currentStrategy = strategyOptions[currentStrategyIndex];
      const strategyNames = {
        '4h': '4 HOUR',
        'Swing': 'SWING',
        'Scalp': 'SCALP'
      };
      const strategyName = strategyNames[currentStrategy] || '4 HOUR';
      
      // Get active signal from backend (no template evaluation)
      const templateSignal = getActiveSignal(symbol, currentStrategy);
      
      // Use backend signal if available, otherwise fall back to legacy signal
      const activeSignal = templateSignal || (data.signal || data.tradeSignal);
      
      // Set row class based on active signal (template or API)
      const hasValidTrade = activeSignal && activeSignal.valid;
      const tradeClass = hasValidTrade ? 
        (activeSignal.direction === 'long' || activeSignal.direction === 'LONG' ? 'has-trade-long' : 'has-trade-short') : '';
      
      row.className = `coin-row ${tradeClass}`;
      
      // Coin name - spell out full names
      const coinNames = {
        'BTCUSDT': 'BITCOIN',
        'ETHUSDT': 'ETHEREUM',
        'SOLUSDT': 'SOLANA'
      };
      const coinName = coinNames[symbol] || symbol.replace('USDT', '');
      
      // Price and change
      const price = data.currentPrice ? `$${data.currentPrice.toLocaleString()}` : 'N/A';
      const changeClass = (data.priceChange24h || 0) >= 0 ? 'status-long' : 'status-short';
      const change = data.priceChange24h ? 
        `${data.priceChange24h >= 0 ? '+' : ''}${data.priceChange24h.toFixed(2)}%` : 'N/A';
      
      // Signal readiness
      const readiness = calculateSignalReadiness(data);
      
      // Get API signal as fallback
      const apiSignal = data?.signal || data?.tradeSignal;
      
      // Get ALL strategies from backend to color-code the indicator buttons
      const richSymbol = data?.richSymbol || data;
      const strategies = richSymbol?.strategies || {};
      
      // Get backend strategies directly (NO template evaluation)
      const strategy4h = getBackendStrategy(symbol, '4h');
      const strategySwing = getBackendStrategy(symbol, 'Swing');
      const strategyScalp = getBackendStrategy(symbol, 'Scalp');
      const strategyMicroScalp = getBackendStrategy(symbol, 'MicroScalp');
      
      const strategy4hSignal = strategy4h && strategy4h.valid ? {
        valid: true,
        direction: strategy4h.direction,
        confidence: strategy4h.confidence
      } : null;
      
      const strategySwingSignal = strategySwing && strategySwing.valid ? {
        valid: true,
        direction: strategySwing.direction,
        confidence: strategySwing.confidence
      } : null;
      
      const strategyScalpSignal = strategyScalp && strategyScalp.valid ? {
        valid: true,
        direction: strategyScalp.direction,
        confidence: strategyScalp.confidence
      } : null;
      
      // Check if ANY strategy has a valid trade for coin name color
      const hasAnyTrade = (strategy4hSignal && strategy4hSignal.valid) || 
                          (strategySwingSignal && strategySwingSignal.valid) || 
                          (strategyScalpSignal && strategyScalpSignal.valid) ||
                          (strategyMicroScalp && strategyMicroScalp.valid);
      
      
      // Calculate current price display
      const currentPriceDisplay = data.currentPrice ? `$${data.currentPrice.toLocaleString()}` : 'N/A';
      
      // Calculate entry price - use backend signal
      const tradeSignal = templateSignal || (data.signal || data.tradeSignal);
      
      let entryPriceDisplay = 'NO TRADE';
      let entryHasSignal = false;
      
      if (tradeSignal && tradeSignal.valid) {
        // Handle both API format (entry_zone) and template format (entryZone)
        const entryZone = tradeSignal.entryZone || tradeSignal.entry_zone;
        
        if (entryZone && entryZone.min && entryZone.max) {
          const entryMin = entryZone.min;
          const entryMax = entryZone.max;
          // For LONG: lowest entry (entryMin), for SHORT: highest entry (entryMax)
          const direction = tradeSignal.direction || 'long';
          const recommendedEntry = direction === 'long' || direction === 'LONG' ? entryMin : entryMax;
          entryPriceDisplay = `$${parseFloat(recommendedEntry).toLocaleString()}`;
          entryHasSignal = true;
        }
      } else if (data.microScalp && data.microScalp.valid && data.microScalp.entry) {
        // Show micro-scalp entry if available
        const entryMin = data.microScalp.entry.min;
        const entryMax = data.microScalp.entry.max;
        const recommendedEntry = data.microScalp.direction === 'long' ? entryMin : entryMax;
        entryPriceDisplay = `$${parseFloat(recommendedEntry).toLocaleString()}`;
        entryHasSignal = true;
      }
      // If no valid signal, show "NO TRADE" in yellow-white
      
      // Determine coin name color based on SELECTED strategy's trade direction (templateSignal, not activeSignal)
      let coinNameColor = 'var(--color-yellow-75)';
      if (templateSignal && templateSignal.valid) {
        const isLong = templateSignal.direction === 'long' || templateSignal.direction === 'LONG';
        coinNameColor = isLong ? '#10b981' : '#ef4444';
      }
      
      row.innerHTML = `
        <td class="px-2" style="padding-top: 1.65rem; padding-bottom: 1.65rem; text-align: center;" data-label="">
          <div class="text-lg ${hasAnyTrade ? 'coin-name-has-trade' : ''}" style="color: ${coinNameColor};">${coinName}</div>
          <div class="entry-price-mobile" style="font-size: 0.9rem; color: var(--color-yellow-75); margin-top: 0.25rem;">${currentPriceDisplay}</div>
        </td>
        <td class="px-2 entry-price-desktop" style="padding-top: 1.65rem; padding-bottom: 1.65rem;" data-label="Price:">
          <div style="color: var(--color-yellow-75); font-size: 0.875rem;">${currentPriceDisplay}</div>
        </td>
        <td class="px-2 entry-cell" style="padding-top: 1.65rem; padding-bottom: 1.65rem; text-align: center;" data-label="Entry:">
          <div class="entry-label-mobile" style="font-size: 1.125rem; font-family: var(--font-mathias); font-weight: bold; color: var(--color-yellow-75);">ENTRY</div>
          <div class="entry-value" style="color: var(--color-yellow-75); font-size: 0.9rem; margin-top: 0.25rem; ${!entryHasSignal ? 'opacity: 0.7;' : ''}">${entryPriceDisplay}</div>
        </td>
        <td class="px-2" style="padding-top: 1.65rem; padding-bottom: 1.65rem;" data-label="EditTrades:">
          <div class="flex strategy-buttons-container" style="gap: 0;">
            <button 
              onclick="setStrategy('${symbol}', 0)"
              id="strategy-btn-${symbol}-0"
              class="px-2 py-1 text-xs font-mathias font-bold"
              style="border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md) 0 0 var(--radius-md); transition: all 0.3s; white-space: nowrap; min-width: 40px; cursor: pointer;"
            >
              4H
            </button>
            <button 
              onclick="setStrategy('${symbol}', 1)"
              id="strategy-btn-${symbol}-1"
              class="px-2 py-1 text-xs font-mathias font-bold"
              style="border: 2px solid var(--color-yellow-75); border-left: none; transition: all 0.3s; white-space: nowrap; min-width: 45px; cursor: pointer;"
            >
              Swing
            </button>
            <button 
              onclick="setStrategy('${symbol}', 2)"
              id="strategy-btn-${symbol}-2"
              class="px-2 py-1 text-xs font-mathias font-bold"
              style="border: 2px solid var(--color-yellow-75); border-left: none; transition: all 0.3s; white-space: nowrap; min-width: 42px; cursor: pointer;"
            >
              Scalp
            </button>
            <button 
              onclick="setStrategy('${symbol}', 3)"
              id="strategy-btn-${symbol}-3"
              class="px-2 py-1 text-xs font-mathias font-bold"
              style="border: 2px solid var(--color-yellow-75); border-left: none; border-radius: 0 var(--radius-md) var(--radius-md) 0; transition: all 0.3s; white-space: nowrap; min-width: 35px; font-size: 0.6rem; cursor: pointer;"
            >
              M-S
            </button>
          </div>
        </td>
        <td class="px-2" style="padding-top: 1.65rem; padding-bottom: 1.65rem;" data-label="Actions:">
          <div class="flex gap-1" style="justify-content: center; flex-wrap: wrap;">
            <button 
              onclick="toggleDetails('${symbol}')"
              class="px-3 py-1 text-xs font-mathias font-bold"
              style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s; min-width: 80px;"
              id="toggle-${symbol}"
            >
              DETAILS
            </button>
            <button 
              onclick="downloadCoinView('${symbol}')"
              class="px-3 py-1 text-xs font-mathias font-bold"
              style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s;"
            >
              DL DATA
            </button>
            <button 
              onclick="trackThisTrade('${symbol}')"
              class="px-3 py-1 text-xs font-mathias font-bold"
              style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s;"
            >
              TRACK
            </button>
          </div>
        </td>
      `;
      
      return row;
    }

    // Detect Stoch RSI curl direction
    function detectStochCurl(stochRSI) {
      if (!stochRSI || stochRSI.k === null || stochRSI.d === null) {
        return { direction: 'flat', text: ' Flat', color: 'status-neutral' };
      }
      
      const diff = stochRSI.k - stochRSI.d;
      
      if (diff > 5) {
        return { direction: 'up', text: ' Curling Up', color: 'status-long' };
      } else if (diff < -5) {
        return { direction: 'down', text: ' Curling Down', color: 'status-short' };
      } else {
        return { direction: 'flat', text: ' Flat', color: 'status-neutral' };
      }
    }
    
    // Get Stoch range/zone
    function getStochZone(k) {
      if (k === null || k === undefined) return 'UNKNOWN';
      if (k >= 80) return 'OVERBOUGHT';
      if (k <= 20) return 'OVERSOLD';
      if (k >= 50) return 'BULLISH ZONE';
      return 'BEARISH ZONE';
    }

    // Create details row with full timeframe breakdown
    function createDetailsRow(symbol, data) {
      const detailsRow = document.createElement('tr');
      detailsRow.className = 'details-row';
      detailsRow.id = `details-${symbol}`;
      
      // Create detailed timeframe cards - ALL TIMEFRAMES (1m first, 1 Month last)
      const timeframes = ['1m', '3m', '5m', '15m', '1h', '4h', '1d', '3d', '1w', '1M'];
      const tfCards = timeframes.map(tf => {
        const analysis = data.analysis?.[tf];
        if (!analysis || analysis.error || !analysis.indicators) {
          return `<div class="tf-card"><p class="text-sm font-bold mb-2">${tf.toUpperCase()}</p><p class="text-xs" style="color: var(--text-secondary);">No data</p></div>`;
        }
        
        const ind = analysis.indicators;
        const trend = ind.analysis?.trend || 'UNKNOWN';
        const trendClass = trend === 'UPTREND' ? 'uptrend' : 
                          trend === 'DOWNTREND' ? 'downtrend' : 'flat';
        const trendBadge = trend === 'UPTREND' ? 'UPTREND' : 
                          trend === 'DOWNTREND' ? 'DOWNTREND' : 'FLAT';
        
        // Stoch curl detection
        const stochCurl = detectStochCurl(ind.stochRSI);
        const stochZone = getStochZone(ind.stochRSI?.k);
        
        // Display name for timeframe (spell out Month, 3 Day)
        const tfDisplay = tf === '1M' ? '1 MONTH' : 
                         tf === '3d' ? '3 DAY' : 
                         tf.toUpperCase();
        
        return `
          <div class="tf-card ${trendClass}" style="font-family: var(--font-mathias);">
            <div class="flex items-center justify-between mb-3">
              <p class="text-sm font-bold" style="color: var(--color-yellow-75);">${tfDisplay}</p>
              <span class="text-xs px-2 py-0.5 rounded ${trend === 'UPTREND' ? 'status-long' : trend === 'DOWNTREND' ? 'status-short' : 'status-neutral'}" style="background-color: var(--bg-tertiary);">${trendBadge}</span>
          </div>

            <div class="space-y-2 text-xs">
                <div class="flex justify-between">
                <span style="color: var(--color-yellow-75); opacity: 0.6;">Current Price</span>
                <span class="font-bold" style="color: var(--color-yellow-75);">${ind.price?.current ? '$' + ind.price.current.toLocaleString() : 'N/A'}</span>
                </div>
              
                <div class="flex justify-between">
                <span style="color: var(--color-yellow-75); opacity: 0.6;">21 EMA</span>
                <span class="font-bold" style="color: var(--color-yellow-75);">${ind.ema?.ema21 ? '$' + ind.ema.ema21.toLocaleString() : 'N/A'}</span>
                </div>
              
                  <div class="flex justify-between">
                <span style="color: var(--color-yellow-75); opacity: 0.6;">200 EMA</span>
                <span class="font-bold" style="color: var(--color-yellow-75);">${ind.ema?.ema200 ? '$' + ind.ema.ema200.toLocaleString() : 'N/A'}</span>
                  </div>
              
              <div class="border-t pt-2" style="border-color: var(--border);">
                <div class="flex justify-between mb-1">
                  <span style="color: var(--color-yellow-75); opacity: 0.6;">Stoch RSI</span>
                  <span class="text-xs px-1 py-0.5 rounded ${getStochColor(ind.stochRSI?.condition)}" style="background-color: var(--bg-tertiary);">${ind.stochRSI?.condition || 'N/A'}</span>
              </div>
                <div class="flex justify-between mb-1">
                  <span class="text-xs" style="color: var(--color-yellow-75); opacity: 0.6;">${stochZone}</span>
                  <span class="${stochCurl.color} font-medium">${stochCurl.text}</span>
            </div>
                <div class="flex justify-between text-xs" style="color: var(--color-yellow-75); opacity: 0.6;">
                  <span>%K: ${ind.stochRSI?.k ? ind.stochRSI.k.toFixed(0) : 'N/A'}</span>
                  <span>%D: ${ind.stochRSI?.d ? ind.stochRSI.d.toFixed(0) : 'N/A'}</span>
                </div>
                </div>
              
              <div class="border-t pt-2" style="border-color: var(--border);">
                <div class="flex justify-between mb-1">
                  <span style="color: var(--color-yellow-75); opacity: 0.6;">Pullback State</span>
                  <span class="text-xs px-1 py-0.5 rounded ${getPullbackColor(ind.analysis?.pullbackState)}" style="background-color: var(--bg-tertiary);">${ind.analysis?.pullbackState || 'N/A'}</span>
                </div>
                ${ind.analysis?.distanceFrom21EMA !== null && ind.analysis?.distanceFrom21EMA !== undefined ? `
                  <div class="text-xs" style="color: var(--color-yellow-75); opacity: 0.6;">
                    Distance from 21 EMA: ${ind.analysis.distanceFrom21EMA.toFixed(2)}%
              </div>
                ` : ''}
            </div>

              ${analysis.structure?.swingHigh || analysis.structure?.swingLow ? `
                <div class="border-t pt-2" style="border-color: var(--border);">
                  ${analysis.structure.swingHigh ? `
                  <div class="flex justify-between">
                      <span style="color: var(--color-yellow-75); opacity: 0.6;">Swing High</span>
                      <span class="font-bold" style="color: var(--color-yellow-75);">$${analysis.structure.swingHigh.toLocaleString()}</span>
                  </div>
                ` : ''}
                  ${analysis.structure.swingLow ? `
                  <div class="flex justify-between">
                      <span style="color: var(--color-yellow-75); opacity: 0.6;">Swing Low</span>
                      <span class="font-bold" style="color: var(--color-yellow-75);">$${analysis.structure.swingLow.toLocaleString()}</span>
                  </div>
                ` : ''}
                  </div>
                ` : ''}
              </div>
            </div>
        `;
      }).join('');
      
      // Create formatted trade call output (text file format)
      // Check both original trade signal and active template signal
      const currentStrategyIndex = strategyStates[symbol] || 0;
      const currentStrategy = strategyOptions[currentStrategyIndex];  // Use strategyOptions, not tradeTemplates keys
      
      let templateSignal;
      if (currentStrategy === 'MicroScalp') {
        // For Micro-Scalp, use the microScalp signal from API if available
        if (data.microScalp && data.microScalp.valid) {
          templateSignal = {
            valid: true,
            direction: data.microScalp.direction,
            confidence: data.microScalp.confidence,
            entryZone: data.microScalp.entry,
            stopLoss: data.microScalp.stopLoss,
            targets: data.microScalp.targets,
            riskReward: data.microScalp.riskReward,
            invalidationLevel: data.microScalp.invalidation_level,
            setupType: 'MicroScalp',
            reason: data.microScalp.reason
          };
        } else {
          templateSignal = {
            valid: false,
            direction: 'NO_TRADE',
            reason: '1H/15m/5m conditions not met for micro-scalp',
            setupType: 'MicroScalp'
          };
        }
      } else {
        // Get backend strategy for current strategy
        templateSignal = getActiveSignal(symbol, currentStrategy);
      }
      
      // Use backend signal if available, otherwise fall back to legacy signal
      const tradeSignal = templateSignal || (data.signal || data.tradeSignal);
      let tradeCallHtml = '';
      
      if (tradeSignal && tradeSignal.valid) {
        const direction = tradeSignal.direction.toUpperCase();
        const setupType = tradeSignal.setupType ? tradeSignal.setupType.toUpperCase() : '4H';
        const confidence = normalizeConfidence(tradeSignal.confidence).toFixed(0);
        const directionIcon = direction === 'LONG' ? '' : direction === 'SHORT' ? '' : '';
        const directionColor = direction === 'LONG' ? '#22c55e' : direction === 'SHORT' ? '#ef4444' : '#9ca3af';
        
        // Handle both API format (entry_zone) and template format (entryZone)
        const entryZone = tradeSignal.entryZone || tradeSignal.entry_zone || {};
        const entryMin = entryZone.min ? `$${entryZone.min.toLocaleString()}` : 'N/A';
        const entryMax = entryZone.max ? `$${entryZone.max.toLocaleString()}` : 'N/A';
        
        const stopLoss = (tradeSignal.stopLoss || tradeSignal.stop_loss) ? 
          `$${(tradeSignal.stopLoss || tradeSignal.stop_loss).toLocaleString()}` : 'N/A';
        
        const invalidationLevel = tradeSignal.invalidationLevel || tradeSignal.invalidation_level;
        const invalidation = invalidationLevel ? `$${invalidationLevel.toLocaleString()}` : stopLoss;
        
        // Handle both array format and object format for targets
        const targets = tradeSignal.targets || {};
        const tp1 = (targets.tp1 || targets[0]) ? `$${(targets.tp1 || targets[0]).toLocaleString()}` : 'N/A';
        const tp2 = (targets.tp2 || targets[1]) ? `$${(targets.tp2 || targets[1]).toLocaleString()}` : 'N/A';
        const tp3 = (targets.tp3 || targets[2]) ? `$${(targets.tp3 || targets[2]).toLocaleString()}` : null;  // Swing trades have TP3
        
        const riskReward = tradeSignal.riskReward || tradeSignal.risk_reward || {};
        const rr1 = riskReward.tp1RR || 1.0;
        const rr2 = riskReward.tp2RR || 2.0;
        const rr3 = riskReward.tp3RR || null;  // Swing: 5.0, others: null
        
        const riskAmt = tradeSignal.riskAmount || tradeSignal.risk_amount;
        const riskAmount = riskAmt ? `$${riskAmt.toLocaleString()}` : 'N/A';
        
        const reason = tradeSignal.reason_summary || tradeSignal.reason || 'Trade setup detected';
        
        // Build confluence bullets
        const tf4h = data.analysis?.['4h'];
        const tf1h = data.analysis?.['1h'];
        
        const trendAlignment = tf4h && tf1h ? 
          `${tf4h.indicators?.analysis?.trend || 'UNKNOWN'} on 4H, ${tf1h.indicators?.analysis?.trend || 'UNKNOWN'} on 1H` : 
          'HTF trend analysis';
        
        const stochMomentum = tf4h?.indicators?.stochRSI?.condition || 'N/A';
        const pullbackState = tf4h?.indicators?.analysis?.pullbackState || 'N/A';
        const distanceFrom21 = tf4h?.indicators?.analysis?.distanceFrom21EMA ? 
          `${Math.abs(tf4h.indicators.analysis.distanceFrom21EMA).toFixed(2)}% from 21 EMA` : 
          'Price positioning';
        
        // Conditions required
        const conditionsRequired = [];
        if (setupType === 'SWING') {
          conditionsRequired.push(' 3D stoch oversold/overbought pivot');
          conditionsRequired.push(' 1D reclaim/rejection of key level');
          conditionsRequired.push(' 4H trend supportive');
          conditionsRequired.push(' Price in ENTRY_ZONE on 15m/5m');
        } else if (setupType === 'SCALP') {
          conditionsRequired.push(' 4H trend clear (not FLAT)');
          conditionsRequired.push(' 1H aligned with 4H');
          conditionsRequired.push(' 15m & 5m stoch curl in direction');
          conditionsRequired.push(' Price in ENTRY_ZONE');
          conditionsRequired.push(' 1m confirms (noise filter)');
        } else if (setupType === 'MICROSCALP') {
          conditionsRequired.push(' 1H trending (not FLAT)');
          conditionsRequired.push(' 1H pullback in ENTRY_ZONE or RETRACING');
          conditionsRequired.push(' 15m within 0.25% of 21 EMA');
          conditionsRequired.push(' 5m within 0.25% of 21 EMA');
          conditionsRequired.push(' Stoch aligned on both 15m & 5m');
          conditionsRequired.push(' Disregards 4H trend - independent strategy');
        } else {
          conditionsRequired.push(' 4H trend clear (not FLAT)');
          conditionsRequired.push(' 1H confirmation');
          conditionsRequired.push(' Price near 21 EMA');
          conditionsRequired.push(' Stoch aligned');
        }
        
        const riskPercent = tradeSignal.risk_amount || riskAmt ? 
          ((tradeSignal.risk_amount || riskAmt) / (entryZone.min || 1) * 100).toFixed(2) : 'N/A';
        const rewardPercent1 = rr1 * parseFloat(riskPercent);
        const rewardPercent2 = rr2 * parseFloat(riskPercent);
        
        // Get entry type (pullback or breakout)
        const entryType = tradeSignal.entryType || 'pullback';
        const entryTypeBadge = entryType === 'breakout' 
          ? '<span style="background-color: rgba(59, 130, 246, 0.2); border: 1px solid #3b82f6; border-radius: var(--radius-sm); padding: 0.25rem 0.5rem; font-size: 0.75rem; color: #3b82f6; margin-left: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">BREAKOUT ENTRY</span>'
          : '<span style="background-color: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; border-radius: var(--radius-sm); padding: 0.25rem 0.5rem; font-size: 0.75rem; color: #22c55e; margin-left: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">PULLBACK ENTRY</span>';
        
        tradeCallHtml = `
          <div class="trade-call-output" style="margin-bottom: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); font-family: var(--font-system); backdrop-filter: blur(10px); border-left: 4px solid ${directionColor};">
            <!-- Header -->
            <div style="margin-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 1rem;">
              <h2 style="font-size: clamp(1.25rem, 4vw, 1.75rem); font-weight: bold; color: var(--color-yellow-75); margin-bottom: 0.75rem; letter-spacing: 0.05em; text-transform: uppercase; font-family: var(--font-mathias);">
                ${symbol.replace('USDT', '')}  ${direction} (${setupType})${entryTypeBadge}
              </h2>
              <!-- Key Metrics Grid -->
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Confidence</div>
                  <div style="color: ${directionColor}; font-size: 1.5rem; font-weight: bold;">${confidence}%</div>
                </div>
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Direction</div>
                  <div style="color: ${directionColor}; font-size: 1.25rem; font-weight: bold;">${directionIcon} ${direction}</div>
                </div>
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Setup Type</div>
                  <div style="color: var(--color-yellow-75); font-size: 1rem; font-weight: bold;">${
                    setupType === 'SWING' ? 'Swing Trade' :
                    setupType === 'SCALP' ? '1H Scalp' :
                    setupType === 'MICROSCALP' ? 'Micro Scalp' :
                    setupType === '4H' ? '4H Trend Play' :
                    '4H Trend Play'
                  }</div>
                </div>
              </div>
            </div>
            
            <!-- Editorial Grid Layout -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
              <!-- Left Column: Entry & Risk -->
              <div style="display: flex; flex-direction: column; gap: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Entry</div>
                  <div style="color: var(--color-yellow-75); font-size: 1.125rem; font-weight: bold; line-height: 1.2;">${entryMin}  ${entryMax}</div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Stop Loss</div>
                  <div style="color: ${direction === 'LONG' ? '#ef4444' : '#22c55e'}; font-size: 1.125rem; font-weight: bold;">${stopLoss}</div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Risk / Reward</div>
                  <div style="color: #22c55e; font-size: 1rem; font-weight: bold; line-height: 1.4;">
                    ${rr1}R to ${rr2}R${tp3 ? ` to ${rr3}R` : ''}
                    <div style="color: var(--color-yellow-75); font-size: 0.875rem; margin-top: 0.25rem;">${riskPercent}% risk  ${rewardPercent1.toFixed(1)}% reward</div>
                  </div>
                </div>
              </div>
              
              <!-- Right Column: Targets & Analysis -->
              <div style="display: flex; flex-direction: column; gap: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase;">Targets</div>
                  <div style="color: var(--color-yellow-75); font-size: 0.875rem; font-weight: bold; line-height: 1.6;">
                    <div>TP1 (${rr1}R): ${tp1}</div>
                    <div style="margin-top: 0.25rem;">TP2 (${rr2}R): ${tp2}</div>
                    ${tp3 ? `<div style="margin-top: 0.25rem;">TP3 (${rr3}R): ${tp3}</div>` : ''}
                  </div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase;">Invalidation</div>
                  <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.5;">
                    <div style="margin-bottom: 0.5rem;">
                      ${setupType === 'SWING' ? 'HTF invalidation indicates macro trend shifted.' : 
                        setupType === 'SCALP' ? 'LTF invalidation means scalp failed.' : 
                        setupType === 'MICROSCALP' ? 'Exit immediately if wrong - high risk countertrend.' :
                        'Structure break invalidates setup.'}
                    </div>
                    <div><strong>Level:</strong> ${invalidation} (${direction === 'LONG' ? 'close below' : 'close above'})</div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Full Width: Confluence Analysis -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Why This Trade</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8;">
                <div style="margin-bottom: 0.5rem; color: rgba(255, 255, 255, 0.85);">Clear explanation of confluence:</div>
                <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Trend alignment: ${trendAlignment}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Stoch momentum: ${stochMomentum}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Pullback state: ${pullbackState}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Liquidity zones: ${distanceFrom21}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> HTF confirmation: ${tf4h?.indicators?.analysis?.trend || 'N/A'} 4H trend${setupType === 'MICROSCALP' ? ' (disregarded for micro-scalp)' : ''}</div>
                </div>
              </div>
            </div>
            
            <!-- Full Width: Conditions -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Conditions Required</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.5rem;">
                ${conditionsRequired.map(cond => `<div style="color: rgba(255, 255, 255, 0.7);">${cond}</div>`).join('')}
              </div>
            </div>
            
            <!-- Full Width: Time Horizon -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">How Long to Hold This Setup</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.6;">
                ${setupType === 'SWING' ? 'This is a multi-day swing play. Expect movement within 15 days. Requires waiting for daily/4H closes to confirm progression.' :
                  setupType === 'SCALP' ? 'Short-duration 1H4H play. Expect movement within 28 hours. Monitor 1H and 4H closes.' :
                  setupType === 'MICROSCALP' ? 'Ultra-short 15m1H scalp. Expect movement within 15 minutes to 2 hours. Watch candle-by-candle.' :
                  'Standard 4H trend play. Expect movement within 412 hours. Check every 1H or 4H close.'}
              </div>
            </div>
            
            <!-- Full Width: Monitoring Requirement -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">How Close It Must Be Monitored</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.6;">
                ${setupType === 'SWING' ? 'Low-touch swing setup  can be checked every 412 hours unless invalidation is close. Set alerts for key levels.' :
                  setupType === 'SCALP' ? 'Normal risk  check every 1530 minutes during active hours. Tighten stops if momentum stalls.' :
                  setupType === 'MICROSCALP' ? 'High-risk scalp  must be watched candle-to-candle on 15m or 5m. Use tight stops and quick exits.' :
                  'Standard monitoring  check every 12 hours during active sessions. Adjust if 4H shows weakness.'}
              </div>
            </div>
            
            <!-- Full Width: Chop Guidance -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Recommended Action If Price Chops</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.6;">
                ${setupType === 'SWING' ? 'Cut early if daily stoch flips against trend or if 4H loses key structure. Do not hold through major macro shifts.' :
                  setupType === 'SCALP' ? 'Exit early if 1H stoch flips against trend or if we lose EMA21 with momentum. Do not hold if liquidity sweeps both sides.' :
                  setupType === 'MICROSCALP' ? 'Cut immediately if 15m breaks entry zone or if stoch crosses against you. Do not wait  this is a precision scalp.' :
                  'Exit if 4H closes against trend or if 1H momentum stalls. Cut early if liquidity sweeps both sides.'}
              </div>
            </div>
            
            <!-- Trade Execution Section -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid ${directionColor};">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 1rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Execute Trade</div>
              
              <!-- Trade Type Selector -->
              <div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <label style="color: var(--color-yellow-75); font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                  <input type="radio" name="tradeType-${symbol}" value="spot" checked style="accent-color: ${directionColor};" data-symbol="${symbol}" onchange="handleTradeTypeChange('${symbol}')">
                  <span>Spot Swap</span>
                </label>
                <label style="color: var(--color-yellow-75); font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                  <input type="radio" name="tradeType-${symbol}" value="perp" style="accent-color: ${directionColor};" data-symbol="${symbol}" onchange="handleTradeTypeChange('${symbol}')">
                  <span>Perpetual</span>
                </label>
              </div>
              
              <!-- Perp-Specific Fields (hidden by default) -->
              <div id="perpFields-${symbol}" style="display: none; margin-bottom: 1rem; padding: 1rem; background-color: rgba(0, 0, 0, 0.3); border-radius: var(--radius-sm); border: 1px solid rgba(255, 255, 255, 0.1);">
                <!-- Leverage Selector -->
                <div style="margin-bottom: 1rem;">
                  <label style="color: var(--color-yellow-75); font-size: 0.75rem; display: block; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">Leverage</label>
                  <select id="leverage-${symbol}" style="width: 100%; max-width: 200px; padding: 0.5rem; background-color: rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: var(--radius-sm); color: var(--color-yellow-75); font-size: 0.875rem;" onchange="updateMarginDisplay('${symbol}')">
                    <option value="1">1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                    <option value="10">10x</option>
                    <option value="20">20x</option>
                    <option value="50">50x</option>
                    <option value="100">100x</option>
                    <option value="200">200x</option>
                  </select>
                  <div id="leverageWarning-${symbol}" style="display: none; color: #ef4444; font-size: 0.75rem; margin-top: 0.25rem;"> High leverage increases risk of liquidation</div>
                </div>
                
                <!-- Margin Display -->
                <div style="margin-bottom: 1rem;">
                  <label style="color: var(--color-yellow-75); font-size: 0.75rem; display: block; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">Margin Required</label>
                  <div id="marginDisplay-${symbol}" style="color: var(--color-yellow-75); font-size: 0.875rem; font-weight: bold;">$0.00 USD</div>
                  <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-top: 0.25rem;">Position Size  Leverage</div>
                </div>
                
                <!-- Liquidation Price (placeholder) -->
                <div style="margin-bottom: 1rem;">
                  <label style="color: var(--color-yellow-75); font-size: 0.75rem; display: block; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">Estimated Liquidation Price</label>
                  <div id="liquidationPrice-${symbol}" style="color: var(--color-yellow-75); font-size: 0.875rem;">Calculated after position opens</div>
                </div>
                
                <!-- Funding Rate (placeholder) -->
                <div>
                  <label style="color: var(--color-yellow-75); font-size: 0.75rem; display: block; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">Funding Rate</label>
                  <div id="fundingRate-${symbol}" style="color: var(--color-yellow-75); font-size: 0.875rem;">Loading...</div>
                </div>
              </div>
              
              <!-- Trade Amount Input -->
              <div style="margin-bottom: 1rem;">
                <label style="color: var(--color-yellow-75); font-size: 0.75rem; display: block; margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em;">
                  <span id="amountLabel-${symbol}">Trade Amount (USD)</span>
                </label>
                <input type="number" id="tradeAmount-${symbol}" value="0.25" min="0.25" max="1000" step="0.05" placeholder="0.25-1000"
                  style="width: 100%; max-width: 200px; padding: 0.5rem; background-color: rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: var(--radius-sm); color: var(--color-yellow-75); font-size: 0.875rem;"
                  data-symbol="${symbol}" oninput="updateMarginDisplay('${symbol}')">
                <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-top: 0.25rem;">
                  <span id="amountHint-${symbol}">Min: $0.25 USD | Default: $0.25 USD</span>
                </div>
              </div>
              
              <!-- Auto-Execution Toggle -->
              <div style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="autoExec-${symbol}" data-symbol="${symbol}"
                  style="accent-color: ${directionColor}; width: 18px; height: 18px; cursor: pointer;">
                <label for="autoExec-${symbol}" style="color: var(--color-yellow-75); font-size: 0.875rem; cursor: pointer;">
                  Auto-execute when entry price is hit
                </label>
              </div>
              
              <!-- TRADE Button -->
              <button id="tradeBtn-${symbol}" 
                data-symbol="${symbol}"
                onclick="handleTradeButtonClick('${symbol}')"
                style="width: 100%; padding: 1rem; background: linear-gradient(135deg, ${directionColor} 0%, ${direction === 'LONG' ? '#16a34a' : '#dc2626'} 100%); border: none; border-radius: var(--radius-md); color: white; font-size: 1rem; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; cursor: pointer; transition: all 0.3s ease; font-family: var(--font-mathias);"
                onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';"
                onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                 Execute ${direction} Trade
              </button>
              
              <!-- Trade Status Display -->
              <div id="tradeStatus-${symbol}" style="margin-top: 1rem; display: none; padding: 0.75rem; background-color: rgba(0, 0, 0, 0.5); border-radius: var(--radius-sm); border-left: 3px solid ${directionColor};">
                <div style="color: var(--color-yellow-75); font-size: 0.875rem; font-weight: bold; margin-bottom: 0.5rem;">Trade Status</div>
                <div id="tradeStatusText-${symbol}" style="color: rgba(255, 255, 255, 0.9); font-size: 0.875rem; line-height: 1.6;"></div>
                <a id="tradeExplorerLink-${symbol}" href="#" target="_blank" style="color: ${directionColor}; font-size: 0.75rem; text-decoration: underline; margin-top: 0.5rem; display: none;">View on Solscan </a>
                <button id="trackTradeBtn-${symbol}" onclick="trackExecutedTrade('${symbol}')" style="display: none; margin-top: 0.75rem; padding: 0.5rem 1rem; background: linear-gradient(135deg, ${directionColor} 0%, ${direction === 'LONG' ? '#16a34a' : '#dc2626'} 100%); border: none; border-radius: var(--radius-sm); color: white; font-size: 0.75rem; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);"> Track Trade</button>
              </div>
            </div>
          </div>
        `;
      } else if (tradeSignal && !tradeSignal.valid) {
        // Show NO TRADE format with ALL sections (full format)
        const reason = tradeSignal.reason_summary || tradeSignal.reason || 'Setup requirements not met';
        const setupType = tradeSignal.setupType ? tradeSignal.setupType.toUpperCase() : currentStrategy.toUpperCase();
        const confidence = tradeSignal.confidence || 0;
        
        // Get current timeframe data for context
        const tf4h = data.analysis?.['4h'];
        const tf1h = data.analysis?.['1h'];
        const tf15m = data.analysis?.['15m'];
        const tf5m = data.analysis?.['5m'];
        
        const trend4h = tf4h?.indicators?.analysis?.trend || 'UNKNOWN';
        const trend1h = tf1h?.indicators?.analysis?.trend || 'UNKNOWN';
        const stoch4h = tf4h?.indicators?.stochRSI?.condition || 'NEUTRAL';
        const stoch1h = tf1h?.indicators?.stochRSI?.condition || 'NEUTRAL';
        const pullback4h = tf4h?.indicators?.analysis?.pullbackState || 'UNKNOWN';
        const distanceFrom21 = tf4h?.indicators?.analysis?.distanceFrom21EMA ? 
          `${tf4h.indicators.analysis.distanceFrom21EMA.toFixed(2)}%` : 'N/A';
        
        // Conditions that would need to be met - use API data if available, otherwise default
        let conditionsRequired = tradeSignal.conditionsRequired || [];
        
        // Fallback conditions if not provided by API
        if (conditionsRequired.length === 0) {
          if (setupType === 'auto' || setupType === 'AUTO') {
            conditionsRequired = [
              ' Awaiting clean setup',
              ' Swing: Needs 3D/1D/4H structure (4H not FLAT)',
              ' 4H Trend: Needs 4H trending (UP or DOWN)',
              ' 1H Scalp: Needs 1H trending + 15m pullback + stoch aligned',
              ' Micro-Scalp: Needs 1H trending + 15m/5m within 0.25% of EMA21'
            ];
          } else if (setupType === 'SWING' || setupType === 'swing') {
            conditionsRequired = [
              ' 3D stoch oversold/overbought pivot',
              ' 1D reclaim/rejection of key level',
              ' 4H trend supportive (not FLAT)',
              ' Price in ENTRY_ZONE on 15m/5m'
            ];
          } else if (setupType === 'SCALP' || setupType === '1hScalp') {
            conditionsRequired = [
              ' 1H trend clear (UPTREND or DOWNTREND)',
              ' Price near 21 EMA on 1H (2%) and 15m (1.5%)',
              ' 15m Stoch aligned with 1H trend',
              ' 4H disregarded (scalp uses 1H bias)'
            ];
          } else if (setupType === 'MicroScalp' || setupType === 'microScalp') {
            conditionsRequired = [
              ' 1H trending (not FLAT)',
              ' 15m within 0.25% of 21 EMA',
              ' 5m within 0.25% of 21 EMA',
              ' Stoch aligned on both 15m & 5m',
              ' Disregards 4H trend entirely'
            ];
          } else if (setupType === 'AGGRO_SCALP_1H') {
            conditionsRequired = [
              ' AGGRESSIVE MODE: Counter-trend scalp with reduced size',
              ' 1H trend UPTREND/DOWNTREND or FLAT (allows FLAT)',
              ' 15m within 2.5% of EMA21 (wider than standard)',
              ' 15m stoch supportive (not extreme)',
              ' Position size: 0.5% risk (half of standard)',
              ' Exit immediately if wrong - tight invalidation'
            ];
          } else if (setupType === 'AGGRO_MICRO_SCALP') {
            conditionsRequired = [
              ' AGGRESSIVE MODE: LTF counter-scalp with minimal size',
              ' 1H trending',
              ' 15m within 0.75% of EMA21 (3x standard band)',
              ' 5m within 0.75% of EMA21',
              ' At least one stoch oversold/overbought',
              ' Position size: 0.33% risk (1/3 of standard)'
            ];
          } else {
            conditionsRequired = [
              ' 4H trend clear (UPTREND or DOWNTREND)',
              ' 1H confirmation',
              ' Price near 21 EMA',
              ' Stoch aligned'
            ];
          }
        }
        
        tradeCallHtml = `
          <div class="trade-call-output" style="margin-bottom: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); font-family: var(--font-system); backdrop-filter: blur(10px); border-left: 4px solid #9ca3af;">
            <!-- Header -->
            <div style="margin-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 1rem;">
              <h2 style="font-size: clamp(1.25rem, 4vw, 1.75rem); font-weight: bold; color: #6b7280; margin-bottom: 0.75rem; letter-spacing: 0.05em; text-transform: uppercase; font-family: var(--font-mathias);">
                ${symbol.replace('USDT', '')}  NO TRADE (${setupType})
              </h2>
              <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.875rem;">
                NO VALID SETUP AT THIS TIME
              </div>
              <!-- Key Metrics Grid -->
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Confidence</div>
                  <div style="color: #6b7280; font-size: 1.5rem; font-weight: bold;">${confidence}%</div>
                </div>
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Direction</div>
                  <div style="color: #6b7280; font-size: 1.25rem; font-weight: bold;"> NO TRADE</div>
                </div>
              </div>
            </div>
            
            <!-- Reason Section -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.05); border-radius: var(--radius-md); border-left: 3px solid #6b7280;">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase;">Reason</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.6;">${reason}</div>
            </div>
            
            <!-- Current Market Analysis -->
            <div style="margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase;">Current Market Analysis</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> 4H Trend: ${trend4h}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> 1H Trend: ${trend1h}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> 4H Stoch: ${stoch4h}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> 1H Stoch: ${stoch1h}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Pullback: ${pullback4h}</div>
                  <div><span style="color: rgba(255, 255, 255, 0.5);"></span> Zone: ${distanceFrom21}</div>
                </div>
              </div>
            </div>
            
            <!-- Conditions Required -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase;">Conditions Required Before Entry</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.5rem;">
                ${conditionsRequired.map(cond => `<div style="color: rgba(255, 255, 255, 0.7);">${cond}</div>`).join('')}
              </div>
            </div>
          </div>
        `;
      } else if (data.microScalp && data.microScalp.valid) {
        // Show MICRO-SCALP trade call (LTF mean-reversion setup)
        const direction = data.microScalp.direction.toUpperCase();
        const directionColor = direction === 'LONG' ? '#22c55e' : direction === 'SHORT' ? '#ef4444' : '#9ca3af';
        const directionIcon = direction === 'LONG' ? '' : '';
        const confidence = data.microScalp.confidence;
        const entryMin = `$${data.microScalp.entry.min.toLocaleString()}`;
        const entryMax = `$${data.microScalp.entry.max.toLocaleString()}`;
        const stopLoss = `$${data.microScalp.stopLoss.toLocaleString()}`;
        const tp1 = `$${data.microScalp.targets.tp1.toLocaleString()}`;
        const tp2 = `$${data.microScalp.targets.tp2.toLocaleString()}`;
        const rr1 = data.microScalp.riskReward.tp1RR;
        const rr2 = data.microScalp.riskReward.tp2RR;
        const invalidation = `$${data.microScalp.invalidation_level.toLocaleString()}`;
        const reason = data.microScalp.reason;
        
        tradeCallHtml = `
          <div class="trade-call-output" style="margin-bottom: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); font-family: var(--font-system); backdrop-filter: blur(10px); border-left: 4px solid ${directionColor};">
            <!-- Header -->
            <div style="margin-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 1rem;">
              <h2 style="font-size: clamp(1.25rem, 4vw, 1.75rem); font-weight: bold; color: ${directionColor}; margin-bottom: 0.75rem; letter-spacing: 0.05em; text-transform: uppercase; font-family: var(--font-mathias);">
                ${symbol.replace('USDT', '')}  ${direction} (MICRO-SCALP)
              </h2>
              <div style="background-color: rgba(255, 193, 7, 0.15); border: 1px solid #ffc107; border-radius: var(--radius-sm); padding: 0.75rem; margin-top: 0.75rem;">
                <p style="color: #ffc107; font-size: 0.875rem; margin: 0; letter-spacing: 0.02em;"> LOWER TIMEFRAME TRADE  Quick scalp when 4H is FLAT</p>
              </div>
              <!-- Key Metrics Grid -->
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Confidence</div>
                  <div style="color: ${directionColor}; font-size: 1.5rem; font-weight: bold;">${confidence}%</div>
                </div>
                <div>
                  <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Direction</div>
                  <div style="color: ${directionColor}; font-size: 1.25rem; font-weight: bold;">${directionIcon} ${direction}</div>
                </div>
              </div>
            </div>
            
            <!-- Editorial Grid Layout -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
              <!-- Left Column: Entry & Risk -->
              <div style="display: flex; flex-direction: column; gap: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Entry</div>
                  <div style="color: var(--color-yellow-75); font-size: 1.125rem; font-weight: bold; line-height: 1.2;">${entryMin}  ${entryMax}</div>
                  <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-top: 0.25rem;">Avg 15m & 5m EMA21</div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Stop Loss</div>
                  <div style="color: ${direction === 'LONG' ? '#ef4444' : '#22c55e'}; font-size: 1.125rem; font-weight: bold;">${stopLoss}</div>
                  <div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-top: 0.25rem;">${direction === 'LONG' ? 'Below' : 'Above'} 15m/5m swings</div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Risk / Reward</div>
                  <div style="color: #22c55e; font-size: 1rem; font-weight: bold;">${rr1}R to ${rr2}R targets</div>
                </div>
              </div>
              
              <!-- Right Column: Targets & Analysis -->
              <div style="display: flex; flex-direction: column; gap: 1rem;">
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase;">Targets</div>
                  <div style="color: var(--color-yellow-75); font-size: 0.875rem; font-weight: bold; line-height: 1.6;">
                    <div>TP1 (${rr1}R): ${tp1}</div>
                    <div style="margin-top: 0.25rem;">TP2 (${rr2}R): ${tp2}</div>
                  </div>
                </div>
                
                <div>
                  <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase;">Invalidation</div>
                  <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.5;">
                    ${data.microScalp.invalidation_description}
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Full Width: Why This Trade -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Why This Trade</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.7;">
                ${reason}
              </div>
            </div>
            
            <!-- Full Width: Conditions -->
            <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase;">Conditions Met</div>
              <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.5rem;">
                <div style="color: rgba(255, 255, 255, 0.7);"> 1H trending (not FLAT)</div>
                <div style="color: rgba(255, 255, 255, 0.7);"> 1H pullback near entry zone</div>
                <div style="color: rgba(255, 255, 255, 0.7);"> 15m & 5m within 0.25% of EMA21</div>
                <div style="color: rgba(255, 255, 255, 0.7);"> 15m & 5m stoch aligned</div>
                <div style="color: rgba(255, 255, 255, 0.7);"> Tight confluence for quick scalp</div>
              </div>
            </div>
          </div>
        `;
      }
      
      detailsRow.innerHTML = `
        <td colspan="5">
          <div class="details-content-wrapper">
            <!-- Trade Call Output - FIRST -->
            ${tradeCallHtml}
            
            <!-- AI Reasoning Agent Section - SECOND -->
            <div id="ai-review-section-${symbol}" style="margin-top: 1.5rem; margin-bottom: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); font-family: var(--font-system); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1);">
              <div id="ai-review-content-${symbol}">
                <!-- Loading state (will be replaced by AI response) -->
                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 2rem; justify-content: center;">
                  <img src="/logos/load.gif" alt="Loading" style="width: 140px; height: auto;">
                  <span style="color: var(--color-yellow-75); font-size: 0.875rem; opacity: 0.7;">Analyzing Call</span>
                </div>
              </div>
            </div>
            
            <style>
              @keyframes spin {
                to { transform: rotate(360deg); }
              }
            </style>
            
            <!-- Market Data Section - THIRD: Spread, Bid/Ask, Volume Quality, Order Book, Recent Trades -->
            ${(function() {
              // Debug: Log data structure
              console.log(`[Market Data] ${symbol} - data.marketData:`, !!data.marketData, data.marketData);
              console.log(`[Market Data] ${symbol} - data.richSymbol?.marketData:`, !!data.richSymbol?.marketData, data.richSymbol?.marketData);
              console.log(`[Market Data] ${symbol} - data keys:`, Object.keys(data || {}));
              
              const marketDataInfo = data.richSymbol?.marketData || data.marketData;
              
              // Always show Market Data section, even if no data - show all line items
              const spread = (marketDataInfo?.spread !== undefined && marketDataInfo?.spread !== null) ? '$' + marketDataInfo.spread.toFixed(2) : 'N/A';
              const spreadPercent = (marketDataInfo?.spreadPercent !== undefined && marketDataInfo?.spreadPercent !== null) ? marketDataInfo.spreadPercent.toFixed(4) + '%' : '0.000%';
              const bid = (marketDataInfo?.bid !== undefined && marketDataInfo?.bid !== null) ? '$' + marketDataInfo.bid.toLocaleString() : 'N/A';
              const ask = (marketDataInfo?.ask !== undefined && marketDataInfo?.ask !== null) ? '$' + marketDataInfo.ask.toLocaleString() : 'N/A';
              const bidAskImbalance = (marketDataInfo?.bidAskImbalance !== undefined && marketDataInfo?.bidAskImbalance !== null) ? marketDataInfo.bidAskImbalance.toFixed(1) + '%' : 'N/A';
              const bidAskImbalanceColor = marketDataInfo?.bidAskImbalance > 0 ? '#22c55e' : marketDataInfo?.bidAskImbalance < 0 ? '#ef4444' : '#9ca3af';
              const bidAskImbalanceArrow = marketDataInfo?.bidAskImbalance > 0 ? '' : marketDataInfo?.bidAskImbalance < 0 ? '' : '';
              const volumeQuality = marketDataInfo?.volumeQuality || 'N/A';
              const volumeQualityColor = volumeQuality === 'HIGH' ? '#22c55e' : volumeQuality === 'MEDIUM' ? '#f59e0b' : volumeQuality === 'LOW' ? '#ef4444' : '#9ca3af';
              const tradeCount24h = (marketDataInfo?.tradeCount24h !== undefined && marketDataInfo?.tradeCount24h !== null && marketDataInfo.tradeCount24h > 0) ? marketDataInfo.tradeCount24h.toLocaleString() : 'N/A';
              
              // Order Book Depth - always show, even if no data
              const ob = marketDataInfo?.orderBook || {};
              const bidLiquidity = (ob.bidLiquidity !== undefined && ob.bidLiquidity !== null) ? ob.bidLiquidity.toLocaleString() : 'N/A';
              const askLiquidity = (ob.askLiquidity !== undefined && ob.askLiquidity !== null) ? ob.askLiquidity.toLocaleString() : 'N/A';
              const obImbalance = (ob.imbalance !== undefined && ob.imbalance !== null) ? ob.imbalance.toFixed(1) + '%' : 'N/A';
              const obImbalanceColor = ob.imbalance > 0 ? '#22c55e' : ob.imbalance < 0 ? '#ef4444' : '#9ca3af';
              
              // Recent Trades Flow - always show, even if no data
              const rt = marketDataInfo?.recentTrades || {};
              const overallFlow = rt.overallFlow || 'N/A';
              const flowColor = overallFlow === 'BUY' ? '#22c55e' : overallFlow === 'SELL' ? '#ef4444' : '#9ca3af';
              const buyPressure = (rt.buyPressure !== undefined && rt.buyPressure !== null) ? rt.buyPressure.toFixed(1) + '%' : 'N/A';
              const sellPressure = (rt.sellPressure !== undefined && rt.sellPressure !== null) ? rt.sellPressure.toFixed(1) + '%' : 'N/A';
              const volumeImbalance = (rt.volumeImbalance !== undefined && rt.volumeImbalance !== null) ? rt.volumeImbalance.toFixed(1) + '%' : 'N/A';
              const imbalanceColor = rt.volumeImbalance > 0 ? '#22c55e' : rt.volumeImbalance < 0 ? '#ef4444' : '#9ca3af';
              
              // Add Chart Analysis data to Market Data section (NEW)
              const chartAnalysisHtml = (function() {
                // Check multiple possible data paths
                const analysis4h = data.analysis?.['4h'] || data.richSymbol?.analysis?.['4h'];
                const analysis1h = data.analysis?.['1h'] || data.richSymbol?.analysis?.['1h'];
                const momentumData = data.momentum || data.richSymbol?.momentum;
                
                // Debug logging
                console.log(`[Chart Analysis] ${symbol} - analysis4h:`, !!analysis4h, 'analysis1h:', !!analysis1h, 'momentum:', !!momentumData);
                console.log(`[Chart Analysis] ${symbol} - data.analysis:`, !!data.analysis, 'data.richSymbol:', !!data.richSymbol);
                
                if (!analysis4h && !analysis1h && !momentumData) {
                  console.log(`[Chart Analysis] ${symbol} - No chart analysis data available`);
                  return '';
                }
                
                let html = '<div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">' +
                  '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Chart Analysis</div>';
                
                // 4H Chart Analysis - ALWAYS SHOW ALL FIELDS (even if null/N/A)
                html += '<div style="margin-bottom: 1rem; padding: 0.75rem; background-color: rgba(255, 255, 255, 0.03); border-radius: var(--radius-sm);">' +
                  '<div style="color: rgba(255, 255, 255, 0.7); font-size: 0.75rem; margin-bottom: 0.5rem; font-weight: bold;">4H Timeframe</div>';
                
                // Log the full structure for debugging
                console.log(`[Chart Analysis] ${symbol} 4H - analysis4h exists:`, !!analysis4h);
                console.log(`[Chart Analysis] ${symbol} 4H - analysis4h.indicators exists:`, !!analysis4h?.indicators);
                if (analysis4h?.indicators) {
                  console.log(`[Chart Analysis] ${symbol} 4H full indicators:`, analysis4h.indicators);
                  console.log(`[Chart Analysis] ${symbol} 4H indicators keys:`, Object.keys(analysis4h.indicators || {}));
                }
                
                // Always show a grid with ALL fields, even if data is missing
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem; font-size: 0.75rem;">';
                
                // 1. Candlestick Pattern - ALWAYS SHOW
                const patterns = analysis4h?.indicators?.candlestickPatterns;
                if (patterns && patterns.current) {
                  const patternColor = patterns.bullish ? '#22c55e' : patterns.bearish ? '#ef4444' : '#9ca3af';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Pattern</div><div style="color: ' + patternColor + '; font-weight: bold;">' + patterns.current + '</div></div>';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Pattern Confidence</div><div style="color: var(--color-yellow-75);">' + ((patterns.confidence || 0) * 100).toFixed(0) + '%</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Pattern</div><div style="color: #9ca3af;">N/A</div></div>';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Pattern Confidence</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                // 2. ADX (Trend Strength) - ALWAYS SHOW
                const trendStrength = analysis4h?.indicators?.trendStrength || analysis4h?.indicators?.analysis?.trendStrength;
                if (trendStrength && trendStrength.adx !== null && trendStrength.adx !== undefined) {
                  const adxColor = trendStrength.strong ? '#22c55e' : trendStrength.weak ? '#ef4444' : '#f59e0b';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">ADX</div><div style="color: ' + adxColor + '; font-weight: bold;">' + trendStrength.adx.toFixed(1) + '</div></div>';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Trend Strength</div><div style="color: ' + adxColor + '; font-size: 0.7rem;">' + (trendStrength.category || trendStrength.state || 'N/A') + '</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">ADX</div><div style="color: #9ca3af;">N/A</div></div>';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Trend Strength</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                // 3. RSI - ALWAYS SHOW
                const rsi = analysis4h?.indicators?.rsi;
                if (rsi && (rsi.value !== null && rsi.value !== undefined)) {
                  const rsiValue = typeof rsi === 'number' ? rsi : rsi.value;
                  const rsiColor = rsiValue > 70 ? '#ef4444' : rsiValue < 30 ? '#22c55e' : '#9ca3af';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">RSI</div><div style="color: ' + rsiColor + '; font-weight: bold;">' + rsiValue.toFixed(1) + '</div></div>';
                } else if (typeof rsi === 'number') {
                  const rsiColor = rsi > 70 ? '#ef4444' : rsi < 30 ? '#22c55e' : '#9ca3af';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">RSI</div><div style="color: ' + rsiColor + '; font-weight: bold;">' + rsi.toFixed(1) + '</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">RSI</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                // 4. Wick Analysis - ALWAYS SHOW
                const wick = analysis4h?.indicators?.wickAnalysis;
                const candleMetrics = analysis4h?.indicators?.candleMetrics || analysis4h?.candle;
                const wickDominance = wick?.wickDominance || candleMetrics?.wickDominance;
                
                if (wickDominance && wickDominance.dominance) {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Wick Dominance</div><div style="color: #9ca3af; font-size: 0.7rem;">' + wickDominance.dominance + '</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Wick Dominance</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                if (wickDominance && wickDominance.upper !== undefined) {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Upper Wick</div><div style="color: #9ca3af;">' + wickDominance.upper.toFixed(1) + '%</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Upper Wick</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                if (wickDominance && wickDominance.lower !== undefined) {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Lower Wick</div><div style="color: #9ca3af;">' + wickDominance.lower.toFixed(1) + '%</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Lower Wick</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                // 5. Exhaustion Signal - ALWAYS SHOW
                const exhaustion = wick?.exhaustionSignal || wick?.exhaustionSignals?.exhaustionSignal || candleMetrics?.exhaustionSignals?.exhaustionSignal;
                if (exhaustion && exhaustion !== 'NONE') {
                  const exhaustionColor = exhaustion.includes('LOWER') ? '#22c55e' : exhaustion.includes('UPPER') ? '#ef4444' : '#9ca3af';
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Exhaustion Signal</div><div style="color: ' + exhaustionColor + '; font-size: 0.7rem;">' + exhaustion.replace(/_/g, ' ') + '</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Exhaustion Signal</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                // 6. Body Strength - ALWAYS SHOW
                const bodyStrength = candleMetrics?.bodyStrength || wick?.bodyStrength;
                if (bodyStrength && bodyStrength.strength) {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Body Strength</div><div style="color: #9ca3af; font-size: 0.7rem;">' + bodyStrength.strength + '</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Body Strength</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                if (bodyStrength && bodyStrength.bodyToRangeRatio !== undefined) {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Body/Range Ratio</div><div style="color: #9ca3af;">' + bodyStrength.bodyToRangeRatio.toFixed(1) + '%</div></div>';
                } else {
                  html += '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem; margin-bottom: 0.25rem;">Body/Range Ratio</div><div style="color: #9ca3af;">N/A</div></div>';
                }
                
                html += '</div>'; // Close grid
                html += '</div>'; // Close 4H timeframe div
                
                // Momentum Alignment
                if (momentumData && momentumData.alignment) {
                  const momentumColor = momentumData.alignment.includes('BULLISH') ? '#22c55e' : 
                                       momentumData.alignment.includes('BEARISH') ? '#ef4444' : '#9ca3af';
                  html += '<div style="padding: 0.75rem; background-color: rgba(255, 255, 255, 0.03); border-radius: var(--radius-sm);">' +
                    '<div style="color: rgba(255, 255, 255, 0.7); font-size: 0.75rem; margin-bottom: 0.5rem; font-weight: bold;">Multi-Timeframe Momentum</div>' +
                    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem; font-size: 0.75rem;">' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem;">Alignment</div><div style="color: ' + momentumColor + '; font-weight: bold; text-transform: uppercase;">' + momentumData.alignment.replace(/_/g, ' ') + '</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem;">Score</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + momentumData.alignmentScore.toFixed(1) + '%</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem;">Bullish TFs</div><div style="color: #22c55e;">' + momentumData.bullishCount + '</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.7rem;">Bearish TFs</div><div style="color: #ef4444;">' + momentumData.bearishCount + '</div></div>' +
                    '</div>' +
                    '</div>';
                }
                
                html += '</div>';
                return html;
              })();
              
              // Add Prediction Markets to the same Market Data section - ALWAYS SHOW
              const dflowData = data.richSymbol?.dflowData || data.dflowData;
              let predictionMarketsHtml = '';
              
              // Debug logging
              console.log(`[Frontend] ${symbol} dflowData:`, dflowData);
              
              if (dflowData && !dflowData.error && dflowData.markets && Array.isArray(dflowData.markets) && dflowData.markets.length > 0) {
                const markets = dflowData.markets || [];
                let marketsHtml = '';
                markets.slice(0, 5).forEach(function(market) {
                  const yesProb = market.yesProbability !== null && market.yesProbability !== undefined ? market.yesProbability.toFixed(1) : 'N/A';
                  const noProb = market.noProbability !== null && market.noProbability !== undefined ? market.noProbability.toFixed(1) : 'N/A';
                  const yesPrice = market.yesPrice !== null && market.yesPrice !== undefined ? market.yesPrice.toFixed(4) : 'N/A';
                  const noPrice = market.noPrice !== null && market.noPrice !== undefined ? market.noPrice.toFixed(4) : 'N/A';
                  const volume = market.volume ? market.volume.toLocaleString() : '0';
                  const liquidity = market.liquidity ? market.liquidity.toLocaleString() : '0';
                  const hoursToExpiry = market.hoursToExpiry !== null && market.hoursToExpiry !== undefined ? market.hoursToExpiry : 'N/A';
                  let expiryText = 'N/A';
                  if (hoursToExpiry !== 'N/A' && typeof hoursToExpiry === 'number') {
                    expiryText = hoursToExpiry < 0 ? 'Expired' : hoursToExpiry < 24 ? hoursToExpiry + 'h' : Math.floor(hoursToExpiry / 24) + 'd';
                  }
                  const statusColor = market.status === 'active' ? '#22c55e' : market.status === 'resolved' ? '#3b82f6' : '#9ca3af';
                  const eventTitle = market.eventTitle || 'Unknown Event';
                  const marketStatus = market.status || 'N/A';
                  
                  let mintsHtml = '';
                  if (market.outcomeMints && (market.outcomeMints.yes || market.outcomeMints.no)) {
                    mintsHtml = '<div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1);"><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Outcome Mints</div><div style="font-size: 0.7rem; color: rgba(255, 255, 255, 0.6); word-break: break-all;">' + 
                      (market.outcomeMints.yes ? 'YES: ' + market.outcomeMints.yes.substring(0, 20) + '...' : '') +
                      (market.outcomeMints.no ? '<br>NO: ' + market.outcomeMints.no.substring(0, 20) + '...' : '') +
                      '</div></div>';
                  }
                  
                  marketsHtml += '<div style="padding: 1rem; background-color: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm); margin-bottom: 1rem; border-left: 3px solid var(--color-yellow-75);">' +
                    '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.875rem; margin-bottom: 0.75rem; font-family: var(--font-mathias);">' + eventTitle + '</div>' +
                    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.875rem;">' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">YES Price</div><div style="color: #22c55e; font-weight: bold;">' + yesPrice + '</div><div style="color: rgba(255, 255, 255, 0.7); font-size: 0.75rem; margin-top: 0.25rem;">' + yesProb + '% prob</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">NO Price</div><div style="color: #ef4444; font-weight: bold;">' + noPrice + '</div><div style="color: rgba(255, 255, 255, 0.7); font-size: 0.75rem; margin-top: 0.25rem;">' + noProb + '% prob</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Volume</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + volume + '</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Liquidity</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + liquidity + '</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Time to Expiry</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + expiryText + '</div></div>' +
                      '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Status</div><div style="color: ' + statusColor + '; font-weight: bold; text-transform: uppercase;">' + marketStatus + '</div></div>' +
                    '</div>' +
                    mintsHtml +
                    '</div>';
                });
                
                predictionMarketsHtml = '<div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">' +
                  '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Prediction Markets</div>' +
                  '<div style="color: rgba(255, 255, 255, 0.7); font-size: 0.875rem; margin-bottom: 1rem;">' +
                    markets.length + ' active prediction market' + (markets.length !== 1 ? 's' : '') + ' found for ' + symbol.replace('USDT', '') +
                  '</div>' +
                  marketsHtml +
                  '</div>';
              } else {
                // Always show Prediction Markets section, even if no data
                const errorMsg = dflowData?.error ? ' (' + dflowData.error + ')' : '';
                predictionMarketsHtml = '<div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">' +
                  '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Prediction Markets</div>' +
                  '<div style="color: rgba(255, 255, 255, 0.5); font-size: 0.875rem;">No prediction market data available for ' + symbol.replace('USDT', '') + errorMsg + '</div>' +
                  '</div>';
              }
              
              return '<div style="margin-top: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); border: 1px solid rgba(255, 255, 255, 0.1);">' +
                '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 1rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">MARKET DATA</div>' +
                '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.875rem; margin-bottom: 1rem;">' +
                  '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Spread</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + spread + ' (' + spreadPercent + ')</div></div>' +
                  '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Bid / Ask</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + bid + ' / ' + ask + '</div></div>' +
                  '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Bid/Ask Imbalance</div><div style="color: ' + bidAskImbalanceColor + '; font-weight: bold;">' + bidAskImbalance + ' ' + bidAskImbalanceArrow + '</div></div>' +
                  '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Volume Quality</div><div style="color: ' + volumeQualityColor + '; font-weight: bold;">' + volumeQuality + '</div></div>' +
                  '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Trade Count (24h)</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + tradeCount24h + '</div></div>' +
                '</div>' +
                '<div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">' +
                  '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Order Book Depth</div>' +
                  '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.875rem;">' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Bid Liquidity</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + bidLiquidity + '</div></div>' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Ask Liquidity</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + askLiquidity + '</div></div>' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Imbalance</div><div style="color: ' + obImbalanceColor + '; font-weight: bold;">' + obImbalance + '</div></div>' +
                  '</div>' +
                '</div>' +
                '<div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">' +
                  '<div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Recent Trades Flow</div>' +
                  '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.875rem;">' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Overall Flow</div><div style="color: ' + flowColor + '; font-weight: bold; text-transform: uppercase;">' + overallFlow + '</div></div>' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Buy Pressure</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + buyPressure + '</div></div>' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Sell Pressure</div><div style="color: var(--color-yellow-75); font-weight: bold;">' + sellPressure + '</div></div>' +
                    '<div><div style="color: rgba(255, 255, 255, 0.5); font-size: 0.75rem; margin-bottom: 0.25rem;">Volume Imbalance</div><div style="color: ' + imbalanceColor + '; font-weight: bold;">' + volumeImbalance + '</div></div>' +
                  '</div>' +
                '</div>' +
                chartAnalysisHtml +
                predictionMarketsHtml +
                '</div>';
            })()}
            
            <!-- Timeframe Grid - FOURTH -->
            <div class="tf-grid" style="margin-top: 1.5rem;">
              ${tfCards}
          </div>
        </div>
        </td>
      `;
      
      // Log and verify trade amount input attributes after HTML insertion
      setTimeout(() => {
        const tradeAmountInput = document.getElementById(`tradeAmount-${symbol}`);
        if (tradeAmountInput) {
          console.log(`[TradeAmount]  Input field found for ${symbol}`);
          console.log(`[TradeAmount]   - min attribute:`, tradeAmountInput.getAttribute('min'));
          console.log(`[TradeAmount]   - max attribute:`, tradeAmountInput.getAttribute('max'));
          console.log(`[TradeAmount]   - step attribute:`, tradeAmountInput.getAttribute('step'));
          console.log(`[TradeAmount]   - value attribute:`, tradeAmountInput.getAttribute('value'));
          console.log(`[TradeAmount]   - placeholder:`, tradeAmountInput.getAttribute('placeholder'));
          console.log(`[TradeAmount]   - Current value:`, tradeAmountInput.value);
          console.log(`[TradeAmount]   - Min property:`, tradeAmountInput.min);
          console.log(`[TradeAmount]   - Max property:`, tradeAmountInput.max);
          
          // Verify min is 1
          if (tradeAmountInput.min !== '1' || tradeAmountInput.getAttribute('min') !== '1') {
            console.error(`[TradeAmount]  ERROR: min is not 1! Actual:`, tradeAmountInput.min);
          } else {
            console.log(`[TradeAmount]  VERIFIED: min is correctly set to 1`);
          }
        } else {
          console.warn(`[TradeAmount]   Input field not found for ${symbol}`);
        }
      }, 100);
      
      return detailsRow;
    }

    // Helper functions for styling
    function getStochColor(condition) {
      const colors = {
        'OVERBOUGHT': 'status-short',
        'OVERSOLD': 'status-long',
        'BULLISH': 'status-long',
        'BEARISH': 'status-short',
        'NEUTRAL': 'status-neutral'
      };
      return colors[condition] || 'status-neutral';
    }

    function getPullbackColor(state) {
      const colors = {
        'ENTRY_ZONE': 'status-long',
        'OVEREXTENDED': 'style="color: #f59e0b;"',
        'RETRACING': 'style="color: #3b82f6;"',
        'UNKNOWN': 'status-neutral'
      };
      return colors[state] || 'status-neutral';
    }

    // Toggle details row
    function toggleDetails(symbol) {
      const detailsRow = document.getElementById(`details-${symbol}`);
      const button = document.getElementById(`toggle-${symbol}`);
      
      if (detailsRow.classList.contains('expanded')) {
        detailsRow.classList.remove('expanded');
        button.textContent = 'DETAILS';
      } else {
        detailsRow.classList.add('expanded');
        button.textContent = 'HIDE';
      }
    }


    // Track this trade automatically - UNIFIED: Trade + Full Signal Snapshot
    async function trackThisTrade(symbol) {
      console.log(` Tracking trade for ${symbol}...`);
      
      // Determine current mode
      const currentMode = aggressiveMode ? 'AGGRESSIVE' : 'STANDARD';
      
      // Fetch full rich symbol snapshot (all strategies, all timeframes, htfBias)
      let signalSnapshot = null;
      try {
        console.log(`  Fetching full snapshot for ${symbol} (${currentMode})...`);
        const response = await fetch(`/api/analyze-full?symbol=${symbol}&mode=${currentMode}`);
        if (response.ok) {
          signalSnapshot = await response.json();
          console.log(`   Got snapshot from API: bestSignal=${signalSnapshot.bestSignal || 'null'}`);
        } else {
          throw new Error(`API returned ${response.status}`);
        }
      } catch (error) {
        console.warn(`   API failed, using fallback:`, error.message);
        // Fallback to building from scanResults
        signalSnapshot = buildRichSymbolFromScanResults(symbol, currentMode);
        if (!signalSnapshot) {
          alert(`No data available for ${symbol}. Please wait for scan to complete.`);
          return;
        }
        console.log(`   Built snapshot from fallback: bestSignal=${signalSnapshot.bestSignal || 'null'}`);
      }
      
      // Pick the strategy to trade (use bestSignal or user-selected strategy)
      const selectedStrategyIndex = strategyStates[symbol] || 0;
      const strategyOptions = ['4h', 'Swing', 'TrendRider', 'Scalp', 'MicroScalp'];
      const strategyMap = { '4h': 'TREND_4H', 'Swing': 'SWING', 'TrendRider': 'TREND_RIDER', 'Scalp': 'SCALP_1H', 'MicroScalp': 'MICRO_SCALP' };
      const selectedStrategyKey = strategyOptions[selectedStrategyIndex];
      const strategyName = strategyMap[selectedStrategyKey] || signalSnapshot.bestSignal || 'TREND_4H';
      
      const strategy = signalSnapshot.strategies[strategyName];
      
      if (!strategy || !strategy.valid) {
        alert(`No valid ${strategyName} signal for ${symbol.replace('USDT', '')}. Cannot track without a valid signal.`);
        return;
      }
      
      // Extract trade details from the selected strategy
      const direction = (strategy.direction || 'long').toUpperCase();
      const entryZone = strategy.entryZone || { min: null, max: null };
      const entryMin = entryZone.min || 0;
      const entryMax = entryZone.max || 0;
      const entryAverage = entryMin > 0 && entryMax > 0 ? (entryMin + entryMax) / 2 : signalSnapshot.currentPrice || 0;
      
      const stopLoss = strategy.stopLoss || 0;
      const targets = Array.isArray(strategy.targets) ? strategy.targets : [];
      const tp1 = targets[0] || null;
      const tp2 = targets[1] || null;
      const invalidationLevel = strategy.invalidationLevel || stopLoss;
      
      // Determine status (PENDING if price not in entry zone, ACTIVE if in zone)
      const currentPrice = signalSnapshot.currentPrice || 0;
      let status = 'PENDING';
      
      if (currentPrice > 0 && entryMin > 0 && entryMax > 0) {
        if (direction === 'LONG' && currentPrice >= entryMin && currentPrice <= entryMax) {
          status = 'ACTIVE';
        } else if (direction === 'SHORT' && currentPrice >= entryMin && currentPrice <= entryMax) {
          status = 'ACTIVE';
        }
      }
      
      // Build unified trade object (trade fields + full signalSnapshot)
      const trackedTrade = {
        id: Date.now(),
        symbol: symbol,
        mode: signalSnapshot.mode, // SAFE / AGGRESSIVE
        strategyName: strategyName, // e.g., "TREND_4H"
        direction: direction,
        entry: parseFloat(entryAverage.toFixed(2)),
        entryZone: {
          min: entryMin,
          max: entryMax
        },
        stopLoss: stopLoss,
        invalidationLevel: invalidationLevel,
        target1: tp1,
        target2: tp2,
        strategy: strategyName, // Keep for backward compatibility
        playbook: `${strategyName} ${direction}`, // e.g., "TREND_4H LONG"
        riskPercent: 1,
        confidence: strategy.confidence || 0,
        notes: `Auto-tracked from ${symbol.replace('USDT', '')} ${strategyName} signal`,
        journal: `Auto-tracked from ${symbol.replace('USDT', '')} signal\n\nSetup: ${strategyName}\nConfidence: ${strategy.confidence || 0}%\nReason: ${strategy.reason || 'No reason provided'}`,
        imageUrl: null,
        trackedAt: Date.now(),
        entryTime: new Date().toISOString(),
        status: status,
        exitPrice: null,
        exitTime: null,
        outcome: null,
        autoTracked: true,
        //  THE BIG ONE: Full signal snapshot (entire symbol object with all strategies, timeframes, htfBias)
        signalSnapshot: signalSnapshot,
        review: {
          whatWentRight: '',
          whatWentWrong: '',
          performanceSummary: ''
        },
        monitorZones: {
          invalidation: invalidationLevel,
          entryMin: entryMin,
          entryMax: entryMax
        },
        // Initialize hit tracking for TP/SL detection
        hitTracking: {
          firstHit: null,
          hitTime: null,
          hitPrice: null,
          hitTarget: null,
          slHit: false,
          tp1Hit: false,
          tp2Hit: false
        }
      };
      
      // Store in localStorage for tracker to pick up
      try {
        const tradeJSON = JSON.stringify(trackedTrade);
        const dataSize = new Blob([tradeJSON]).size;
        console.log(` Trade data size: ${(dataSize / 1024).toFixed(2)} KB`);
        
        if (dataSize > 500 * 1024) { // 500KB warning
          console.warn(' Trade data is large, signal snapshot may be big');
        }
        
        localStorage.setItem('pendingTradeToTrack', tradeJSON);
        console.log(' Unified trade object (trade + snapshot):', trackedTrade);
        console.log(' Stored in localStorage');
        
        // Redirect to tracker
        console.log(' Redirecting to tracker with autoTrack=true');
        window.location.href = '/tracker.html?autoTrack=true';
      } catch (error) {
        if (error.name === 'QuotaExceededError') {
          console.error(' localStorage quota exceeded when tracking trade');
          alert(' Storage quota exceeded. Please clean up old trades in the tracker, then try again.');
        } else {
          console.error(' Error storing trade:', error);
          alert(`Error tracking trade: ${error.message}. Please try again.`);
        }
      }
    }

    // Copy to clipboard - synchronous for mobile compatibility
    function copyToClipboardSync(text) {
      // Try Clipboard API first - must be called synchronously in user gesture
      if (navigator.clipboard && navigator.clipboard.writeText) {
        // Fire and forget - works on desktop, may fail on mobile but we have fallback
        navigator.clipboard.writeText(text).then(() => {
          return { success: true };
        }).catch(() => {
          // Fall through to execCommand
        });
        // Optimistically return success for desktop
        return { success: true };
      }
      
      // Fallback: execCommand with textarea (works on mobile when clipboard API fails)
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '0';
      textArea.style.top = '0';
      textArea.style.width = '2px';
      textArea.style.height = '2px';
      textArea.style.opacity = '0';
      textArea.style.pointerEvents = 'none';
      textArea.style.zIndex = '-1';
      document.body.appendChild(textArea);
      
      // For iOS
      if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
        textArea.contentEditable = true;
        textArea.readOnly = false;
        const range = document.createRange();
        range.selectNodeContents(textArea);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, text.length);
        } else {
        textArea.focus();
        textArea.select();
      }
      
      try {
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        return { success: successful };
      } catch (err) {
        document.body.removeChild(textArea);
        return { success: false, error: err.message };
      }
    }

    // Download single coin view - UNIFIED: Trade + Full Signal Snapshot (ONE COIN ONLY)
    function downloadCoinView(symbol) {
      console.log(` Downloading ${symbol}...`);
      
      // Try to get data from scanResults first (faster, preserves user gesture)
      const currentMode = aggressiveMode ? 'AGGRESSIVE' : 'STANDARD';
      const results = currentMode === 'STANDARD' ? scanResultsSafe : scanResultsAggressive;
      const scanData = results[symbol];
      
      // Check if we have richSymbol with full analysis object
      const richSymbol = scanData?.richSymbol || scanData;
      
      let signalSnapshot;
      if (richSymbol && richSymbol.analysis) {
        // Use richSymbol directly if it has the full analysis object
        console.log(` Using richSymbol with full analysis for ${symbol}`);
        signalSnapshot = richSymbol;
      } else {
        // Fallback to building from scanResults (but this won't have advanced modules)
        console.log(` Building from scanResults (may be missing advanced modules) for ${symbol}`);
        signalSnapshot = buildRichSymbolFromScanResults(symbol, currentMode);
      }
      
      if (!signalSnapshot) {
        alert(`No data available for ${symbol}. Please wait for scan to complete.`);
        return;
      }
      
      // Ensure analysis object is included if it exists in richSymbol
      if (richSymbol?.analysis && !signalSnapshot.analysis) {
        signalSnapshot.analysis = richSymbol.analysis;
        console.log(` Added analysis object to signalSnapshot for ${symbol}`);
      }
      
      //  CRITICAL: Merge advanced modules from analysis into timeframes
      if (signalSnapshot.analysis && signalSnapshot.timeframes) {
        for (const [tf, tfData] of Object.entries(signalSnapshot.analysis)) {
          if (tfData && signalSnapshot.timeframes[tf]) {
            // Add advanced modules to timeframes object with structured fallbacks
            signalSnapshot.timeframes[tf].marketStructure = tfData.marketStructure || {
              currentStructure: 'unknown',
              lastSwings: [],
              lastBos: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null },
              lastChoch: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null }
            };
            signalSnapshot.timeframes[tf].volatility = tfData.volatility || { atr: null, atrPctOfPrice: null, state: 'normal' };
            signalSnapshot.timeframes[tf].volumeProfile = tfData.volumeProfile || {
              highVolumeNodes: [],
              lowVolumeNodes: [],
              valueAreaHigh: null,
              valueAreaLow: null
            };
            signalSnapshot.timeframes[tf].liquidityZones = Array.isArray(tfData.liquidityZones) ? tfData.liquidityZones : [];
            signalSnapshot.timeframes[tf].fairValueGaps = Array.isArray(tfData.fairValueGaps) ? tfData.fairValueGaps : [];
            signalSnapshot.timeframes[tf].divergences = Array.isArray(tfData.divergences) ? tfData.divergences : [];
            
            // Add volume metrics from analysis object (always structured)
            signalSnapshot.timeframes[tf].volume = tfData.volume || { current: 0, avg20: 0, trend: 'flat' };
          }
        }
        console.log(` Merged advanced modules into timeframes for ${symbol}`);
      }
      
      // Pick the strategy (use bestSignal or user-selected)
      const selectedStrategyIndex = strategyStates[symbol] || 0;
      const strategyOptions = ['4h', 'Swing', 'TrendRider', 'Scalp', 'MicroScalp'];
      const strategyMap = { '4h': 'TREND_4H', 'Swing': 'SWING', 'TrendRider': 'TREND_RIDER', 'Scalp': 'SCALP_1H', 'MicroScalp': 'MICRO_SCALP' };
      const selectedStrategyKey = strategyOptions[selectedStrategyIndex];
      const strategyName = strategyMap[selectedStrategyKey] || signalSnapshot.bestSignal || 'TREND_4H';
      
      const strategy = signalSnapshot.strategies[strategyName];
      
      // Build unified payload: trade fields + full signalSnapshot
      // Matches the exact structure: symbol, mode, htfBias, strategies, bestSignal, currentPrice, generatedAt, timeframes
      const unifiedPayload = {
        // Core symbol data (ONE COIN ONLY)
        symbol: signalSnapshot.symbol,
        mode: signalSnapshot.mode, // SAFE / AGGRESSIVE
        currentPrice: signalSnapshot.currentPrice,
        htfBias: signalSnapshot.htfBias,
        timeframes: signalSnapshot.timeframes,
        strategies: signalSnapshot.strategies,
        bestSignal: signalSnapshot.bestSignal, // Currently null if no valid strategy
        schemaVersion: signalSnapshot.schemaVersion || '1.0.0',
        generatedAt: signalSnapshot.generatedAt,
        
        // Trade fields (from selected strategy, if valid)
        strategyName: strategyName,
        direction: strategy?.direction || 'NO_TRADE',
        entryZone: strategy?.entryZone || { min: null, max: null },
        stopLoss: strategy?.stopLoss || null,
        targets: strategy?.targets || [],
        confidence: normalizeConfidence(strategy?.confidence || 0),
        reason: strategy?.reason || 'No trade available',
        
        // Full signal snapshot for journaling/analytics (self-reference for convenience)
        signalSnapshot: signalSnapshot
      };
      
      const jsonString = JSON.stringify(unifiedPayload, null, 2);
      
      // Create blob and download as .txt file
      const blob = new Blob([jsonString], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      a.download = `${symbol.replace('USDT', '').toLowerCase()}-data-${timestamp}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log(` ${symbol} data downloaded successfully!`);
    }

    // Convert rich symbol from /api/analyze-full to legacy format for backward compatibility
    function convertRichSymbolToLegacy(richSymbol) {
      if (!richSymbol) return null;
      
      // Extract best signal strategy
      const bestStrategy = richSymbol.bestSignal 
        ? richSymbol.strategies[richSymbol.bestSignal]
        : null;
      
      // Build legacy signal format
      const legacySignal = bestStrategy && bestStrategy.valid ? {
        valid: true,
        direction: bestStrategy.direction,
        confidence: bestStrategy.confidence,
        reason: bestStrategy.reason,
        entryZone: bestStrategy.entryZone,
        stopLoss: bestStrategy.stopLoss,
        invalidationLevel: bestStrategy.invalidationLevel,
        targets: bestStrategy.targets,
        riskReward: bestStrategy.riskReward,
        setupType: richSymbol.bestSignal === 'TREND_4H' ? '4h' :
                   richSymbol.bestSignal === 'SWING' ? 'Swing' :
                   richSymbol.bestSignal === 'SCALP_1H' ? 'Scalp' :
                   richSymbol.bestSignal === 'MICRO_SCALP' ? 'MicroScalp' : 'auto'
      } : {
        valid: false,
        direction: 'NO_TRADE',
        confidence: 0,
        reason: 'No valid strategy available'
      };
      
      // Build analysis structure from timeframes
      // IMPORTANT: We need to get the FULL indicators from the original analysis object
      // The richSymbol.timeframes is a summary, but we need the full data from richSymbol.analysis
      const analysis = {};
      
      // First, try to get full analysis from richSymbol.analysis (if it exists)
      if (richSymbol.analysis) {
        // Use the full analysis object directly - it has all the chart analysis data
        for (const [tf, tfData] of Object.entries(richSymbol.analysis)) {
          analysis[tf] = tfData; // Use full data structure
        }
      } else if (richSymbol.timeframes) {
        // Fallback: Build from timeframes summary (but include chart analysis if available)
        for (const [tf, tfData] of Object.entries(richSymbol.timeframes)) {
          analysis[tf] = {
            indicators: {
              analysis: {
                trend: tfData.trend || 'UNKNOWN',
                pullbackState: tfData.pullback?.state || 'UNKNOWN',
                distanceFrom21EMA: tfData.pullback?.distanceFrom21EMA || null
              },
              ema: {
                ema21: tfData.ema21 || null,
                ema200: tfData.ema200 || null
              },
              stochRSI: tfData.stochRsi || null,
              // Include chart analysis data if available in timeframes
              candlestickPatterns: tfData.candlestickPatterns || null,
              wickAnalysis: tfData.wickAnalysis || null,
              trendStrength: tfData.trendStrength || null,
              rsi: tfData.rsi || null
            },
            structure: tfData.structure || null
          };
        }
      }
      
      return {
        symbol: richSymbol.symbol,
        currentPrice: richSymbol.currentPrice,
        signal: legacySignal,
        tradeSignal: legacySignal,
        htfBias: richSymbol.htfBias,
        analysis: analysis,
        strategies: richSymbol.strategies,
        bestSignal: richSymbol.bestSignal,
        marketData: richSymbol.marketData, // Preserve market data
        dflowData: richSymbol.dflowData, // Preserve dFlow data
        richSymbol: richSymbol // Keep reference to full rich symbol
      };
    }

    // Build rich symbol object from existing scanResults data (fallback)
    function buildRichSymbolFromScanResults(symbol, mode) {
      const originalScanResults = scanResults;
      const results = mode === 'STANDARD' ? scanResultsSafe : scanResultsAggressive;
      scanResults = results; // Temporarily set for evaluateTemplateSignal
      
      const data = results[symbol];
      if (!data) {
        scanResults = originalScanResults;
        return null;
      }
      
      const strategies = {
        SWING: null,
        TREND_4H: null,
        TREND_RIDER: null,
        SCALP_1H: null,
        MICRO_SCALP: null
      };
      
      // Evaluate all strategies using existing frontend logic
      const strategyKeys = ['Swing', '4h', 'TrendRider', 'Scalp', 'MicroScalp'];
      const strategyNames = ['SWING', 'TREND_4H', 'TREND_RIDER', 'SCALP_1H', 'MICRO_SCALP'];
      
      strategyKeys.forEach((key, idx) => {
        // Get backend strategy directly (NO template evaluation) - this is fallback only
        const strategyMap = {
          '4h': 'TREND_4H',
          'Swing': 'SWING',
          'TrendRider': 'TREND_RIDER',
          'Scalp': 'SCALP_1H',
          'MicroScalp': 'MICRO_SCALP'
        };
        const backendStrategyName = strategyMap[key];
        const richSymbol = data?.richSymbol || data;
        const backendStrategy = richSymbol?.strategies?.[backendStrategyName];
        
        // Use backend strategy if available, otherwise fall back to template evaluation (legacy)
        const signal = backendStrategy ? {
          valid: backendStrategy.valid || false,
          direction: backendStrategy.direction || 'NO_TRADE',
          confidence: typeof backendStrategy.confidence === 'number'
            ? backendStrategy.confidence
            : 0,
          reason: backendStrategy.reason || 'No trade setup available',
          entryZone: backendStrategy.entryZone || { min: null, max: null },
          stopLoss: backendStrategy.stopLoss || null,
          invalidationLevel: backendStrategy.invalidationLevel || null,
          targets: backendStrategy.targets || [],
          riskReward: backendStrategy.riskReward || { tp1RR: null, tp2RR: null }
        } : evaluateTemplateSignal(symbol, key); // Legacy fallback only
        
        if (signal) {
          strategies[strategyNames[idx]] = {
            valid: signal.valid || false,
            direction: signal.direction || 'NO_TRADE',
            confidence: normalizeConfidence(signal.confidence),
            reason: signal.reason || 'No trade setup available',
            entryZone: signal.entryZone || { min: null, max: null },
            stopLoss: signal.stopLoss || null,
            invalidationLevel: signal.invalidationLevel || null,
            targets: signal.targets 
              ? (Array.isArray(signal.targets) 
                  ? signal.targets.filter(t => t !== null && t !== undefined)
                  : signal.targets.tp1 ? [signal.targets.tp1, signal.targets.tp2].filter(t => t !== null) : [])
              : [],
            riskReward: signal.riskReward || { tp1RR: null, tp2RR: null },
            validationErrors: []
          };
        } else {
          strategies[strategyNames[idx]] = {
            valid: false,
            direction: 'NO_TRADE',
            confidence: 0,
            reason: 'Strategy evaluation returned null',
            entryZone: { min: null, max: null },
            stopLoss: null,
            invalidationLevel: null,
            targets: [],
            riskReward: { tp1RR: null, tp2RR: null },
            validationErrors: []
          };
        }
      });
      
      // Find best signal
      const validStrategies = Object.entries(strategies)
        .filter(([_, s]) => s && s.valid === true)
        .map(([name, s]) => ({ name, confidence: s.confidence }));
      
      const bestSignal = validStrategies.length > 0
        ? validStrategies.sort((a, b) => b.confidence - a.confidence)[0].name
        : null;
      
      // Build htfBias from data
      const htfBias = data.htfBias || { direction: 'neutral', confidence: 0, source: 'none' };
      
      // Build timeframes summary - INCLUDE ALL ADVANCED MODULES
      const timeframes = {};
      if (data.analysis) {
        for (const [tf, tfData] of Object.entries(data.analysis)) {
          if (tfData && tfData.indicators) {
            const stoch = tfData.indicators.stochRSI || {};
            let stochState = 'neutral';
            if (stoch.k > 80 && stoch.d > 80) stochState = 'overbought';
            else if (stoch.k < 20 && stoch.d < 20) stochState = 'oversold';
            
            // Get volume metrics from analysis object (calculated in backend)
            const volume = tfData.volume || null;
            
            timeframes[tf] = {
              trend: (tfData.indicators.analysis?.trend || 'UNKNOWN').toLowerCase(),
              ema21: tfData.indicators.ema?.ema21 || null,
              ema200: tfData.indicators.ema?.ema200 || null,
              stochRsi: {
                k: stoch.k || null,
                d: stoch.d || null,
                state: stochState
              },
              // Chart-based analysis
              candlestickPatterns: tfData.indicators?.candlestickPatterns || null,
              wickAnalysis: tfData.indicators?.wickAnalysis || null,
              trendStrength: tfData.indicators?.trendStrength || null,
              rsi: tfData.indicators?.rsi || null,
              //  ADVANCED MODULES - Include all from analysis object with structured fallbacks
              marketStructure: tfData.marketStructure || {
                currentStructure: 'unknown',
                lastSwings: [],
                lastBos: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null },
                lastChoch: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null }
              },
              volatility: tfData.volatility || { atr: null, atrPctOfPrice: null, state: 'normal' },
              volume: volume || { current: 0, avg20: 0, trend: 'flat' }, // Always structured object
              volumeProfile: tfData.volumeProfile || {
                highVolumeNodes: [],
                lowVolumeNodes: [],
                valueAreaHigh: null,
                valueAreaLow: null
              },
              liquidityZones: Array.isArray(tfData.liquidityZones) ? tfData.liquidityZones : [],
              fairValueGaps: Array.isArray(tfData.fairValueGaps) ? tfData.fairValueGaps : [],
              divergences: Array.isArray(tfData.divergences) ? tfData.divergences : [],
              confluenceScore: null,
              structureSummary: '',
              notes: ''
            };
          }
        }
      }
      
      scanResults = originalScanResults;
      
      // Get market data and dFlow data from richSymbol if available
      const marketDataInfo = data.richSymbol?.marketData || data.marketData || null;
      const dflowData = data.richSymbol?.dflowData || data.dflowData || null;
      
      // Get momentum alignment data (NEW)
      const momentumData = data.momentum || null;
      
      // Get full analysis object from richSymbol if available (includes advanced modules)
      const fullAnalysis = data.richSymbol?.analysis || data.analysis || null;
      
      return {
        symbol,
        mode: mode === 'STANDARD' ? 'SAFE' : 'AGGRESSIVE',
        currentPrice: data.currentPrice || null,
        htfBias: {
          direction: htfBias.direction || 'neutral',
          confidence: normalizeConfidence(htfBias.confidence),
          source: htfBias.source || 'none'
        },
        timeframes,
        analysis: fullAnalysis, //  CRITICAL: Include full analysis object with advanced modules
        strategies,
        bestSignal,
        marketData: marketDataInfo, // Include market data (spread, bid/ask, etc.)
        dflowData: dflowData, // Include prediction market data
        momentum: momentumData, // Include multi-timeframe momentum alignment (NEW)
        schemaVersion: '1.0.0',
        jsonVersion: '0.10', // Incremented - now includes all advanced modules in timeframes
        generatedAt: new Date().toISOString()
      };
    }

    // Copy all coins with ALL strategies from BOTH modes (RICH FORMAT)
    // Download all coins data as .txt file
    function downloadAllCoins() {
      console.log(' Downloading all trades with rich format (all strategies included)...');
      
      const allViews = {
        SAFE_MODE: {},
        AGGRESSIVE_MODE: {}
      };
      
      const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
      const modes = ['STANDARD', 'AGGRESSIVE'];
      
      // Use existing scanResults data - NO ASYNC FETCH (preserves user gesture for mobile)
      for (const symbol of symbols) {
        for (const mode of modes) {
            const richSymbol = buildRichSymbolFromScanResults(symbol, mode);
            if (richSymbol) {
              //  CRITICAL: Merge advanced modules from analysis into timeframes for downloadAllCoins
              if (richSymbol.analysis && richSymbol.timeframes) {
                for (const [tf, tfData] of Object.entries(richSymbol.analysis)) {
                  if (tfData && richSymbol.timeframes[tf]) {
                    richSymbol.timeframes[tf].marketStructure = tfData.marketStructure || {
                      currentStructure: 'unknown',
                      lastSwings: [],
                      lastBos: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null },
                      lastChoch: { type: 'none', direction: 'none', fromSwing: null, toSwing: null, price: null, timestamp: null }
                    };
                    richSymbol.timeframes[tf].volatility = tfData.volatility || { atr: null, atrPctOfPrice: null, state: 'normal' };
                    richSymbol.timeframes[tf].volumeProfile = tfData.volumeProfile || {
                      highVolumeNodes: [],
                      lowVolumeNodes: [],
                      valueAreaHigh: null,
                      valueAreaLow: null
                    };
                    richSymbol.timeframes[tf].liquidityZones = Array.isArray(tfData.liquidityZones) ? tfData.liquidityZones : [];
                    richSymbol.timeframes[tf].fairValueGaps = Array.isArray(tfData.fairValueGaps) ? tfData.fairValueGaps : [];
                    richSymbol.timeframes[tf].divergences = Array.isArray(tfData.divergences) ? tfData.divergences : [];
                    richSymbol.timeframes[tf].volume = tfData.volume || { current: 0, avg20: 0, trend: 'flat' };
                  }
                }
              }
              
              const modeKey = mode === 'STANDARD' ? 'SAFE_MODE' : 'AGGRESSIVE_MODE';
              allViews[modeKey][symbol] = richSymbol;
            } else {
              // Last resort: create structure with NO_TRADE for all strategies
              const modeKey = mode === 'STANDARD' ? 'SAFE_MODE' : 'AGGRESSIVE_MODE';
              allViews[modeKey][symbol] = {
                symbol,
                mode: mode === 'STANDARD' ? 'SAFE' : 'AGGRESSIVE',
                currentPrice: null,
                htfBias: { direction: 'neutral', confidence: 0, source: 'none' },
                timeframes: {},
                strategies: {
                  SWING: { valid: false, direction: 'NO_TRADE', confidence: 0, reason: 'No data available', entryZone: { min: null, max: null }, stopLoss: null, invalidationLevel: null, targets: [], riskReward: { tp1RR: null, tp2RR: null }, validationErrors: [] },
                  TREND_4H: { valid: false, direction: 'NO_TRADE', confidence: 0, reason: 'No data available', entryZone: { min: null, max: null }, stopLoss: null, invalidationLevel: null, targets: [], riskReward: { tp1RR: null, tp2RR: null }, validationErrors: [] },
                  SCALP_1H: { valid: false, direction: 'NO_TRADE', confidence: 0, reason: 'No data available', entryZone: { min: null, max: null }, stopLoss: null, invalidationLevel: null, targets: [], riskReward: { tp1RR: null, tp2RR: null }, validationErrors: [] },
                  MICRO_SCALP: { valid: false, direction: 'NO_TRADE', confidence: 0, reason: 'No data available', entryZone: { min: null, max: null }, stopLoss: null, invalidationLevel: null, targets: [], riskReward: { tp1RR: null, tp2RR: null }, validationErrors: [] }
                },
                bestSignal: null,
                schemaVersion: '1.0.0',
                generatedAt: new Date().toISOString()
              };
              console.log(`   ${symbol} (${mode}): Created empty structure (no data available)`);
          }
        }
      }
      
      // Verify we have data
      const hasData = Object.keys(allViews.SAFE_MODE).length > 0 || Object.keys(allViews.AGGRESSIVE_MODE).length > 0;
      if (!hasData) {
        console.error(' No data collected for any symbol!');
        alert('No data available to download. Please wait for scan to complete.');
        return;
      }
      
      const jsonString = JSON.stringify(allViews, null, 2);
      
      // Create blob and download as .txt file
      const blob = new Blob([jsonString], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      a.download = `tradingview-data-${timestamp}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success message
      const btn = document.getElementById('dataCopyBtn');
      if (btn) {
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span style="font-weight: bold;"> DOWNLOADED</span>';
        setTimeout(() => {
          btn.innerHTML = originalText;
        }, 2000);
      }
      
      console.log(' Data downloaded successfully!');
    }

    // Generate formatted trade call text (matches text file format exactly)
    function generateFormattedTradeCallText(data, signal) {
      const symbol = data.symbol.replace('USDT', '');
      const direction = signal.direction;
      const setupType = signal.setupType.toUpperCase();
      const confidence = signal.confidence;
      const directionIcon = direction === 'long' ? '' : direction === 'short' ? '' : '';
      
      const setupLabel = setupType === 'auto' || setupType === 'AUTO' ? 'Auto (No Trade)' :
                         setupType === 'swing' || setupType === 'SWING' ? 'Swing Trade' :
                         setupType === '4hTrend' || setupType === '4H' ? '4H Trend Play' :
                         setupType === '1hScalp' || setupType === 'SCALP' ? '1H Scalp' :
                         setupType === 'microScalp' || setupType === 'MicroScalp' || setupType === 'MICROSCALP' ? 'Micro Scalp' :
                         setupType === 'AGGRO_SCALP_1H' ? 'Aggressive 1H Scalp' :
                         setupType === 'AGGRO_MICRO_SCALP' ? 'Aggressive Micro Scalp' :
                         '4H Trend Play';
      
      let text = `${symbol}  ${direction.toUpperCase()}${direction === 'NO_TRADE' ? '' : ' ('+setupType+')'}\n\n`;
      text += `Confidence: ${confidence}%\n`;
      text += `Direction: ${directionIcon} ${direction.toUpperCase()}\n`;
      text += `Setup Type: ${setupLabel}\n\n`;
      
      if (signal.valid && signal.entryZone) {
        text += `ENTRY:\n$${signal.entryZone.min?.toLocaleString()}  $${signal.entryZone.max?.toLocaleString()}\n\n`;
        text += `STOP LOSS:\n$${signal.stopLoss?.toLocaleString()}\n\n`;
        
        // TARGETS: Include TP3 for Swing trades (3R, 4R, 5R)
        text += `TARGETS:\nTP1: $${signal.targets.tp1?.toLocaleString()}\nTP2: $${signal.targets.tp2?.toLocaleString()}`;
        if (signal.targets.tp3) {
          text += `\nTP3: $${signal.targets.tp3.toLocaleString()}`;
        }
        text += `\n\n`;
        
        // RISK/REWARD: Include tp3RR for Swing trades
        if (signal.riskReward.tp3RR) {
          text += `RISK / REWARD:\n${signal.riskReward.tp1RR}R to ${signal.riskReward.tp2RR}R to ${signal.riskReward.tp3RR}R\n\n`;
        } else {
          text += `RISK / REWARD:\n${signal.riskReward.tp1RR}R to ${signal.riskReward.tp2RR}R\n\n`;
        }
      } else {
        text += `ENTRY:\nNo valid entry zone at this time\n\n`;
        text += `STOP LOSS:\nN/A\n\n`;
        text += `TARGETS:\nTP1: N/A\nTP2: N/A\nTP3: N/A\n\n`;
        text += `RISK / REWARD:\nN/A\n\n`;
      }
      
      text += `INVALIDATION:\n${signal.invalidation.description}\n`;
      if (signal.invalidation.level) {
        text += `Level: $${signal.invalidation.level.toLocaleString()}\n`;
      }
      text += `\n`;
      
      text += `WHY THIS TRADE:\nClear short explanation of confluence:\n`;
      text += ` Trend alignment: ${signal.confluence.trendAlignment}\n`;
      text += ` Stoch momentum: ${signal.confluence.stochMomentum}\n`;
      text += ` Pullback state: ${signal.confluence.pullbackState}\n`;
      text += ` Liquidity zones: ${signal.confluence.liquidityZones}\n`;
      text += ` HTF confirmation: ${signal.confluence.htfConfirmation}\n\n`;
      
      text += `CONDITIONS REQUIRED:\n`;
      signal.conditionsRequired.forEach(cond => {
        text += `${cond}\n`;
      });
      
      return text;
    }
    
    // Get AI Review for a specific symbol and setup type
    // NOTE: This uses the individual trade analysis endpoint (not Market Pulse Intelligence)
    // It receives the same rich context data structure but uses strategy-specific prompts
    async function getAIReview(symbol, isAutoTrigger = false) {
      const data = scanResults[symbol];
      if (!data) {
        console.error('No data for symbol:', symbol);
        return;
      }
      
      // Get current strategy for this symbol
      const currentStrategyIndex = strategyStates[symbol] || 0;
      const setupType = strategyOptions[currentStrategyIndex];
      
      // Get content div to show loading/results
      const contentDiv = document.getElementById(`ai-review-content-${symbol}`);
      
      if (!contentDiv) return;
      
      // Show loading state
      if (!isAutoTrigger) {
        contentDiv.innerHTML = `
          <div style="display: flex; align-items: center; gap: 0.75rem; padding: 2rem; justify-content: center;">
            <img src="/logos/load.gif" alt="Loading" style="width: 140px; height: auto;">
            <span style="color: var(--color-yellow-75); font-size: 0.875rem; opacity: 0.7;">Analyzing Call</span>
          </div>
        `;
      }
      
      try {
        // Create the dashboard view (same JSON that COPY TRADE exports)
        // This includes all the new context: htfBias, timeframes, marketData, dflowData
        const marketSnapshot = createDashboardView(data);
        
        // Calculate tone for this symbol using tone interpolation module
        const scores = calculateToneScores(data, symbol);
        const symbolTone = getInterpolatedTone({
          riskScore: scores.riskScore,
          trendScore: scores.trendScore,
          signalScore: scores.signalScore,
          overrideTone: null,
          allowOverride: true
        });
        
        console.log(` [getAIReview] ${symbol}: Tone: ${symbolTone.finalTone} (weight: ${symbolTone.weight.toFixed(2)})`);
        
        // Verify new context is included (for debugging)
        console.log(` [getAIReview] ${symbol}: Context includes htfBias:`, !!marketSnapshot.htfBias);
        console.log(` [getAIReview] ${symbol}: Context includes timeframes:`, !!marketSnapshot.timeframes);
        console.log(` [getAIReview] ${symbol}: Context includes marketData:`, !!data.richSymbol?.marketData || !!data.marketData);
        console.log(` [getAIReview] ${symbol}: Context includes dflowData:`, !!data.richSymbol?.dflowData || !!data.dflowData);
        
        // Add tone information to market snapshot for backend
        marketSnapshot.toneWeight = symbolTone;
        
        // Call the agent API (individual trade analysis mode)
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            symbol,
            setupType,
            marketSnapshot // Contains all new context: htfBias, timeframes, marketData, dflowData, toneWeight
          })
        });
        
        if (!response.ok) {
          throw new Error(`API returned ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        // Store AI response in scanResults for JSON export
        if (!scanResults[symbol].aiReviews) {
          scanResults[symbol].aiReviews = {};
        }
        scanResults[symbol].aiReviews[setupType] = {
          priority: result.priority,
          formattedText: result.formattedText,
          timestamp: result.timestamp
        };
        
        // Display the formatted response
        const priorityColor = 
          result.priority === 'A+' ? '#22c55e' :
          result.priority === 'A' ? '#3b82f6' :
          result.priority === 'B' ? '#f59e0b' : '#6b7280';
        
        // Parse AI response and format in 2x2 grid layout
        const priorityBadgeColor = priorityColor;
        
        // Extract sections from AI response
        const sections = result.formattedText.split('\n\n');
        const mainAnalysis = sections.find(s => s.includes('AGENT ANALYSIS') || s.length > 200) || sections[sections.length - 1] || result.formattedText;
        
        contentDiv.innerHTML = `
          <!-- Full-Width Analysis Paragraph (Top) -->
          <div style="margin-bottom: 1.5rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.03); border-radius: var(--radius-md); border-left: 3px solid ${priorityBadgeColor};">
            <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8;">
              ${mainAnalysis.replace('AGENT ANALYSIS:', '').trim()}
            </div>
          </div>
          
        `;
        
      } catch (error) {
        console.error('AI Review error:', error);
        contentDiv.innerHTML = `
          <div style="padding: 2rem; text-align: center; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: var(--radius-md); background-color: rgba(239, 68, 68, 0.1);">
            <div style="color: #ef4444; font-size: 1rem; font-weight: bold; margin-bottom: 0.75rem;">
               AI Analysis Failed
            </div>
            <div style="color: var(--color-yellow-75); font-size: 0.875rem; opacity: 0.7; line-height: 1.6;">
              ${error.message}
            </div>
            <div style="color: var(--color-yellow-75); font-size: 0.75rem; opacity: 0.5; margin-top: 0.75rem;">
              The AI agent will retry automatically when you change strategies or refresh the page.
            </div>
          </div>
        `;
      }
    }
    
    // Create compact dashboard view
    function createDashboardView(data) {
      const htfBias = data.htfBias || { direction: 'neutral', confidence: 0, source: 'none' };
      
      const view = {
        symbol: data.symbol,
        price: data.currentPrice || data.price,
        change24h: data.priceChange24h,
        htfBias: htfBias,  // HTF Bias at root level
        signal: null,
        timeframes: {}
      };
      
      // Signal - ALWAYS INCLUDES ALL FORMATTED FIELDS (even if no valid trade)
      const tradeSignal = data.signal || data.tradeSignal;
      // htfBias already declared at top of function
      
      if (tradeSignal) {
        const setupType = tradeSignal.setupType || '4h';
        const selectedStrategy = tradeSignal.selectedStrategy || setupType.toUpperCase();
        const strategiesChecked = tradeSignal.strategiesChecked || [];
        const tf4h = data.analysis?.['4h'];
        const tf1h = data.analysis?.['1h'];
        
        view.signal = {
          valid: tradeSignal.valid,
          direction: tradeSignal.direction || 'NO_TRADE',
          setupType: setupType,
          selectedStrategy: selectedStrategy,
          strategiesChecked: strategiesChecked,
          confidence: normalizeConfidence(tradeSignal.confidence),
          reason: tradeSignal.reason_summary || tradeSignal.reason,
          
          // Entry/SL/Targets - include even if null (shows structure)
          entryZone: tradeSignal.entry_zone ? {
            min: tradeSignal.entry_zone.min,
            max: tradeSignal.entry_zone.max
          } : null,
          stopLoss: tradeSignal.stop_loss || null,
          invalidationLevel: tradeSignal.invalidation_level || null,
          targets: {
            tp1: tradeSignal.targets?.[0] || null,
            tp2: tradeSignal.targets?.[1] || null,
            tp3: tradeSignal.targets?.[2] || null
          },
          riskReward: {
            tp1RR: tradeSignal.risk_reward?.tp1RR || 1.0,
            tp2RR: tradeSignal.risk_reward?.tp2RR || 2.0,
            tp3RR: tradeSignal.risk_reward?.tp3RR || null
          },
          riskAmount: tradeSignal.risk_amount || null,
          entryType: tradeSignal.entryType || 'pullback', // 'pullback' or 'breakout'
          
          // Formatted trade call fields - ALWAYS INCLUDED
          invalidation: tradeSignal.invalidation || {
            level: tradeSignal.invalidation_level || null,
            description: setupType === 'Swing' ? 
              '3D/1D swing level. HTF invalidation indicates macro trend has shifted.' : 
              setupType === 'Scalp' || selectedStrategy === 'SCALP_1H' ? 
              '1H/15m swing level. LTF invalidation means the scalp setup has failed.' : 
              setupType === 'MicroScalp' ?
              '5m swing level. Exit immediately if wrong - tight invalidation.' :
              '4H swing level. Structure break invalidates the setup.'
          },
          
          confluence: tradeSignal.confluence || {
            trendAlignment: tf4h && tf1h ? 
              `${tf4h.indicators?.analysis?.trend || 'UNKNOWN'} on 4H, ${tf1h.indicators?.analysis?.trend || 'UNKNOWN'} on 1H` : 
              'HTF trend analysis',
            stochMomentum: tf4h?.indicators?.stochRSI?.condition || 'N/A',
            pullbackState: tf4h?.indicators?.analysis?.pullbackState || 'N/A',
            liquidityZones: tf4h?.indicators?.analysis?.distanceFrom21EMA ? 
              `${Math.abs(tf4h.indicators.analysis.distanceFrom21EMA).toFixed(2)}% from 21 EMA` : 
              'Price positioning',
            htfConfirmation: `${htfBias.confidence}% confidence (${htfBias.source})`
          },
          
          conditionsRequired: tradeSignal.conditionsRequired || (
            setupType === 'Swing' ? [
              ' 3D stoch oversold/overbought pivot',
              ' 1D reclaim/rejection of key level',
              ' 4H trend supportive (not FLAT)',
              ' Price in ENTRY_ZONE on 15m/5m'
            ] : selectedStrategy === 'SCALP_1H' ? [
              ' 1H trend clear (UPTREND or DOWNTREND)',
              ' 4H disregarded (scalp uses 1H bias)',
              ' Price near 21 EMA on 1H (2%) and 15m (1%)',
              ' 15m Stoch aligned with 1H trend'
            ] : setupType === 'MicroScalp' ? [
              ' 1H trending (not FLAT)',
              ' 15m within 0.25% of 21 EMA',
              ' 5m within 0.25% of 21 EMA',
              ' Stoch aligned on both 15m & 5m',
              ' Disregards 4H trend entirely'
            ] : selectedStrategy === 'NO_TRADE' ? [
              ' Awaiting clean setup',
              ' Swing: 3D/1D/4H structure needed',
              ' 4H Trend: 4H trending (not FLAT) needed',
              ' 1H Scalp: 1H trending + 15m pullback needed',
              ' Micro-Scalp: Tight LTF confluence needed'
            ] : [
              ' 4H trend clear (UPTREND or DOWNTREND)',
              ' 1H confirmation',
              ' Price near 21 EMA',
              ' Stoch aligned'
            ]
          )
        };
      } else {
        // No trade signal - still provide structure with analysis data
        const tf4h = data.analysis?.['4h'];
        const tf1h = data.analysis?.['1h'];
        
        view.signal = {
          valid: false,
          direction: 'NO_TRADE',
          setupType: '4h',
          confidence: 0,
          reason: 'No trade signal available',
          entryZone: null,
          stopLoss: null,
          invalidationLevel: null,
          targets: { tp1: null, tp2: null, tp3: null },
          riskReward: { tp1RR: 1.0, tp2RR: 2.0, tp3RR: null },
          riskAmount: null,
          invalidation: {
            level: null,
            description: '4H swing level. Structure break invalidates the setup.'
          },
          confluence: {
            trendAlignment: tf4h && tf1h ? 
              `${tf4h.indicators?.analysis?.trend || 'UNKNOWN'} on 4H, ${tf1h.indicators?.analysis?.trend || 'UNKNOWN'} on 1H` : 
              'HTF trend analysis',
            stochMomentum: tf4h?.indicators?.stochRSI?.condition || 'N/A',
            pullbackState: tf4h?.indicators?.analysis?.pullbackState || 'N/A',
            liquidityZones: tf4h?.indicators?.analysis?.distanceFrom21EMA ? 
              `${Math.abs(tf4h.indicators.analysis.distanceFrom21EMA).toFixed(2)}% from 21 EMA` : 
              'Price positioning',
            htfConfirmation: '0% confidence'
          },
          conditionsRequired: [
            ' 4H trend clear (not FLAT)',
            ' 1H confirmation',
            ' Price near 21 EMA',
            ' Stoch aligned'
          ]
        };
      }
      
      // Store formatted trade call for easy GPT consumption
      view.formattedTradeCall = generateFormattedTradeCallText(data, view.signal);
      
      // Timeframes - Includes all fetched intervals (1M, 1w, 3d, 1d, 4h, 1h, 15m, 5m, 3m, 1m)
      if (data.analysis) {
        for (const [interval, analysis] of Object.entries(data.analysis)) {
          if (analysis.error || !analysis.indicators) {
            view.timeframes[interval] = { error: analysis.error || 'No data' };
            continue;
          }
          
          const ind = analysis.indicators;
          view.timeframes[interval] = {
            trend: ind.analysis?.trend || 'UNKNOWN',
            ema21: ind.ema?.ema21 ? parseFloat(ind.ema.ema21.toFixed(2)) : null,
            ema200: ind.ema?.ema200 ? parseFloat(ind.ema.ema200.toFixed(2)) : null,
            stoch: {
              k: ind.stochRSI?.k ? parseFloat(ind.stochRSI.k.toFixed(1)) : null,
              d: ind.stochRSI?.d ? parseFloat(ind.stochRSI.d.toFixed(1)) : null,
              condition: ind.stochRSI?.condition || 'UNKNOWN'
            },
            pullback: {
              state: ind.analysis?.pullbackState || 'UNKNOWN',
              distanceFrom21EMA: ind.analysis?.distanceFrom21EMA ? 
                parseFloat(ind.analysis.distanceFrom21EMA.toFixed(2)) : null
            },
            swingHigh: analysis.structure?.swingHigh ? 
              parseFloat(analysis.structure.swingHigh.toFixed(2)) : null,
            swingLow: analysis.structure?.swingLow ? 
              parseFloat(analysis.structure.swingLow.toFixed(2)) : null
          };
        }
      }
      
      // Micro-Scalp Override fields (new in v2.0)
      view.microScalpEligible = data.microScalpEligible || false;
      view.microScalp = data.microScalp ? {
        valid: data.microScalp.valid,
        direction: data.microScalp.direction,
        setupType: data.microScalp.setupType,
        confidence: data.microScalp.confidence,
        entry: data.microScalp.entry,
        stopLoss: data.microScalp.stopLoss,
        targets: data.microScalp.targets,
        riskReward: data.microScalp.riskReward,
        invalidation_level: data.microScalp.invalidation_level,
        invalidation_description: data.microScalp.invalidation_description,
        reason: data.microScalp.reason,
        currentPrice: data.microScalp.currentPrice,
        timestamp: data.microScalp.timestamp
      } : null;
      
      view.timestamp = data.timestamp;
      
      // Include AI Reviews (if available for any strategy)
      if (data.aiReviews && Object.keys(data.aiReviews).length > 0) {
        view.aiReviews = data.aiReviews;
      }
      
      return view;
    }

    // Show copy success toast
    function showCopySuccess(message) {
      const container = document.getElementById('copyToastContainer');
      
      // Create simple text toast matching signals-count exactly
      const toast = document.createElement('span');
      toast.style.fontWeight = 'bold';
      toast.style.color = 'var(--color-yellow-75)';
      toast.style.fontFamily = 'var(--font-mathias)';
      toast.style.fontSize = '0.75rem';
      toast.style.opacity = '1';
      toast.style.transition = 'opacity 0.3s';
      toast.textContent = message;
      
      // Clear any existing toasts
      container.innerHTML = '';
      container.appendChild(toast);
      
      // Fade out after 1.5 seconds
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          container.innerHTML = '';
        }, 300);
      }, 1500);
    }

    // Show error
    function showError(message) {
      document.getElementById('errorMessage').textContent = message;
      document.getElementById('errorState').classList.remove('hidden');
    }

    // Show toast notification
    function showToast(message, type = 'info') {
      // Try to use copy toast container if available
      const container = document.getElementById('copyToastContainer');
      if (container) {
        const toast = document.createElement('span');
        toast.style.fontWeight = 'bold';
        toast.style.color = type === 'error' ? '#ef4444' : 'var(--color-yellow-75)';
        toast.style.fontFamily = 'var(--font-mathias)';
        toast.style.fontSize = '0.75rem';
        toast.style.opacity = '1';
        toast.style.transition = 'opacity 0.3s';
        toast.textContent = message;
        
        container.innerHTML = '';
        container.appendChild(toast);
        
        setTimeout(() => {
          toast.style.opacity = '0';
          setTimeout(() => {
            container.innerHTML = '';
          }, 300);
        }, 3000);
        return;
      }
      
      // Fallback to console if container not found
      console.log(`[Toast] ${message}`);
    }

    // ============================================
    // Trade Execution Functions
    // ============================================
    
    // Track active auto-execution signals
    const autoExecutionSignals = new Map(); // { symbol: { signal, tradeType, amount } }
    
    /**
     * Handle trade button click
     * @param {string} symbol - Trading symbol
     */
    function handleTradeButtonClick(symbol) {
      const data = scanResults[symbol];
      if (!data) {
        showToast(`No data found for ${symbol}`);
        return;
      }
      
      // Get signal from data
      const signal = data.signal || data.tradeSignal || data.bestSignal;
      if (!signal || !signal.valid) {
        showToast(`No valid signal for ${symbol}`);
        return;
      }
      
      // Add symbol to signal if not present
      if (!signal.symbol) {
        signal.symbol = symbol;
      }
      
      executeTrade(symbol, signal);
    }
    
    /**
     * Handle trade type change (spot/perp toggle)
     * @param {string} symbol - Trading symbol
     */
    function handleTradeTypeChange(symbol) {
      const tradeTypeRadio = document.querySelector(`input[name="tradeType-${symbol}"]:checked`);
      const tradeType = tradeTypeRadio ? tradeTypeRadio.value : 'spot';
      const perpFields = document.getElementById(`perpFields-${symbol}`);
      const amountLabel = document.getElementById(`amountLabel-${symbol}`);
      const amountHint = document.getElementById(`amountHint-${symbol}`);
      
      if (tradeType === 'perp') {
        perpFields.style.display = 'block';
        amountLabel.textContent = 'Position Size (USD)';
        amountHint.textContent = 'Min: $0.25 USD | This is the notional position size';
        updateMarginDisplay(symbol);
      } else {
        perpFields.style.display = 'none';
        amountLabel.textContent = 'Trade Amount (USD)';
        amountHint.textContent = 'Min: $0.25 USD | Default: $0.25 USD';
      }
    }
    
    /**
     * Update margin display when amount or leverage changes
     * @param {string} symbol - Trading symbol
     */
    function updateMarginDisplay(symbol) {
      const tradeTypeRadio = document.querySelector(`input[name="tradeType-${symbol}"]:checked`);
      const tradeType = tradeTypeRadio ? tradeTypeRadio.value : 'spot';
      
      if (tradeType !== 'perp') return;
      
      const amountInput = document.getElementById(`tradeAmount-${symbol}`);
      const leverageSelect = document.getElementById(`leverage-${symbol}`);
      const marginDisplay = document.getElementById(`marginDisplay-${symbol}`);
      const leverageWarning = document.getElementById(`leverageWarning-${symbol}`);
      
      const amount = amountInput ? parseFloat(amountInput.value) : 0.25;
      const leverage = leverageSelect ? parseFloat(leverageSelect.value) : 1;
      
      if (amount && leverage) {
        const marginRequired = amount / leverage;
        marginDisplay.textContent = `$${marginRequired.toFixed(2)} USD`;
        
        // Show warning for high leverage
        if (leverage > 10) {
          leverageWarning.style.display = 'block';
        } else {
          leverageWarning.style.display = 'none';
        }
      }
    }
    
    /**
     * Execute a trade via Jupiter Swap API or Perpetuals API
     * @param {string} symbol - Trading symbol
     * @param {Object} signal - Strategy signal object
     */
    async function executeTrade(symbol, signal) {
      try {
        console.log('[Frontend] Executing trade for', symbol);
        console.log('[Frontend] Signal:', signal);
        
        // Get trade type and amount
        const tradeTypeRadio = document.querySelector(`input[name="tradeType-${symbol}"]:checked`);
        const tradeType = tradeTypeRadio ? tradeTypeRadio.value : 'spot';
        const amountInput = document.getElementById(`tradeAmount-${symbol}`);
        const amount = amountInput ? parseFloat(amountInput.value) : 0.25;
        
        // Get leverage for perp trades
        let leverage = 1;
        if (tradeType === 'perp') {
          const leverageSelect = document.getElementById(`leverage-${symbol}`);
          leverage = leverageSelect ? parseFloat(leverageSelect.value) : 1;
        }
        
        // Validate amount
        if (!amount || amount < 0.25 || amount > 1000) {
          showToast('Trade amount must be between $0.25 and $1000');
          return;
        }
        
        // Get button and status elements
        const tradeBtn = document.getElementById(`tradeBtn-${symbol}`);
        const statusDiv = document.getElementById(`tradeStatus-${symbol}`);
        const statusText = document.getElementById(`tradeStatusText-${symbol}`);
        const explorerLink = document.getElementById(`tradeExplorerLink-${symbol}`);
        
        // Disable button and show loading
        tradeBtn.disabled = true;
        tradeBtn.textContent = ' Executing...';
        statusDiv.style.display = 'block';
        statusText.innerHTML = ' Preparing trade transaction...';
        
        // Call API
        const requestBody = {
          symbol,
          signal,
          tradeType,
          amount,
        };
        
        // Add leverage for perp trades
        if (tradeType === 'perp') {
          requestBody.leverage = leverage;
        }
        
        console.log('[Frontend] Request body:', requestBody);
        
        const response = await fetch('/api/execute-trade', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error || result.message || 'Trade execution failed');
        }
        
        if (!result.success) {
          throw new Error(result.error || 'Trade execution failed');
        }
        
        // Success!
        console.log('[Frontend] Trade executed successfully:', result);
        tradeBtn.textContent = ' Trade Executed';
        tradeBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
        
        // Display results based on trade type
        let statusHTML = `
          <div style="color: #22c55e; font-weight: bold; margin-bottom: 0.5rem;"> Trade Executed Successfully</div>
          <div style="margin-bottom: 0.25rem;"><strong>Direction:</strong> ${result.direction.toUpperCase()}</div>
          <div style="margin-bottom: 0.25rem;"><strong>Type:</strong> ${result.tradeType.toUpperCase()}</div>
        `;
        
        if (result.tradeType === 'spot') {
          // Spot swap display
          const inputAmountUSD = parseFloat(result.inputAmount) / 1000000; // USDC has 6 decimals
          const tokenDecimals = symbol.includes('SOL') ? 9 : 8;
          const outputAmountTokens = parseFloat(result.outputAmount) / Math.pow(10, tokenDecimals);
          const entryPrice = inputAmountUSD / outputAmountTokens;
          
          statusHTML += `
            <div style="margin-bottom: 0.25rem;"><strong>Input Amount:</strong> $${inputAmountUSD.toFixed(2)} USDC</div>
            <div style="margin-bottom: 0.25rem;"><strong>Output Amount:</strong> ${outputAmountTokens.toFixed(8)} tokens</div>
            <div style="margin-bottom: 0.25rem;"><strong>Entry Price:</strong> $${entryPrice.toFixed(2)}</div>
            ${result.priceImpact ? `<div style="margin-bottom: 0.25rem;"><strong>Price Impact:</strong> ${result.priceImpact}%</div>` : ''}
          `;
        } else if (result.tradeType === 'perp') {
          // Perpetual position display
          statusHTML += `
            <div style="margin-bottom: 0.25rem;"><strong>Position ID:</strong> ${result.positionId || 'N/A'}</div>
            <div style="margin-bottom: 0.25rem;"><strong>Leverage:</strong> ${result.leverage}x</div>
            <div style="margin-bottom: 0.25rem;"><strong>Position Size:</strong> $${parseFloat(result.size || 0).toFixed(2)} USD</div>
            <div style="margin-bottom: 0.25rem;"><strong>Margin Required:</strong> $${parseFloat(result.marginRequired || 0).toFixed(2)} USD</div>
            ${result.liquidationPrice ? `<div style="margin-bottom: 0.25rem;"><strong>Liquidation Price:</strong> $${parseFloat(result.liquidationPrice).toFixed(2)}</div>` : ''}
            ${result.stopLoss ? `<div style="margin-bottom: 0.25rem;"><strong>Stop Loss:</strong> $${parseFloat(result.stopLoss).toFixed(2)}</div>` : ''}
            ${result.takeProfit ? `<div style="margin-bottom: 0.25rem;"><strong>Take Profit:</strong> $${parseFloat(result.takeProfit).toFixed(2)}</div>` : ''}
          `;
        }
        
        statusHTML += `
          <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); word-break: break-all;"><strong>Transaction:</strong> ${result.signature}</div>
          </div>
        `;
        
        statusText.innerHTML = statusHTML;
        
        // Show explorer link
        if (result.explorerUrl) {
          explorerLink.href = result.explorerUrl;
          explorerLink.style.display = 'block';
        }
        
        // Show track trade button
        const trackBtn = document.getElementById(`trackTradeBtn-${symbol}`);
        if (trackBtn) {
          trackBtn.style.display = 'block';
          // Store trade result data for tracking
          const tradeData = {
            symbol,
            signal,
            result,
            executedAt: new Date().toISOString()
          };
          trackBtn.setAttribute('data-trade-data', JSON.stringify(tradeData));
          
          // AUTO-TRACK: Automatically track the trade immediately after execution
          console.log('[Frontend] Auto-tracking executed trade...');
          setTimeout(() => {
            trackExecutedTrade(symbol);
          }, 1500); // Wait 1.5 seconds for UI to update
        }
        
        // Start polling for transaction status
        pollTradeStatus(symbol, result.signature);
        
        showToast(` Trade executed! Transaction: ${result.signature.substring(0, 16)}...`);
        
      } catch (error) {
        console.error('[Frontend] Trade execution error:', error);
        
        const tradeBtn = document.getElementById(`tradeBtn-${symbol}`);
        const statusDiv = document.getElementById(`tradeStatus-${symbol}`);
        const statusText = document.getElementById(`tradeStatusText-${symbol}`);
        
        tradeBtn.disabled = false;
        tradeBtn.textContent = ' Execute Trade';
        statusDiv.style.display = 'block';
        statusText.innerHTML = `
          <div style="color: #ef4444; font-weight: bold;"> Trade Failed</div>
          <div style="margin-top: 0.5rem; color: rgba(255, 255, 255, 0.8);">${error.message}</div>
        `;
        
        showToast(`Trade failed: ${error.message}`);
      }
    }
    
    /**
     * Poll transaction status
     * @param {string} symbol - Trading symbol
     * @param {string} signature - Transaction signature
     */
    async function pollTradeStatus(symbol, signature) {
      const maxAttempts = 30; // Poll for up to 5 minutes (10s intervals)
      let attempts = 0;
      
      const interval = setInterval(async () => {
        attempts++;
        
        try {
          const response = await fetch(`/api/trade-status/${signature}`);
          const result = await response.json();
          
          const statusText = document.getElementById(`tradeStatusText-${symbol}`);
          
          if (result.status && result.status.confirmed) {
            clearInterval(interval);
            statusText.innerHTML += `<div style="color: #22c55e; margin-top: 0.5rem; font-weight: bold;"> Transaction Confirmed</div>`;
            return;
          }
          
          if (result.status && result.status.err) {
            clearInterval(interval);
            statusText.innerHTML += `<div style="color: #ef4444; margin-top: 0.5rem; font-weight: bold;"> Transaction Failed: ${JSON.stringify(result.status.err)}</div>`;
            return;
          }
          
          if (attempts >= maxAttempts) {
            clearInterval(interval);
            statusText.innerHTML += `<div style="color: #f59e0b; margin-top: 0.5rem;"> Status check timeout - transaction may still be processing</div>`;
            return;
          }
          
        } catch (error) {
          console.error('[Frontend] Error polling status:', error);
          if (attempts >= maxAttempts) {
            clearInterval(interval);
          }
        }
      }, 10000); // Poll every 10 seconds
    }
    
    /**
     * Enable auto-execution for a signal
     * @param {string} symbol - Trading symbol
     * @param {Object} signal - Strategy signal
     */
    function enableAutoExecution(symbol, signal) {
      const checkbox = document.getElementById(`autoExec-${symbol}`);
      if (!checkbox) return;
      
      if (checkbox.checked) {
        const tradeTypeRadio = document.querySelector(`input[name="tradeType-${symbol}"]:checked`);
        const tradeType = tradeTypeRadio ? tradeTypeRadio.value : 'spot';
        const amountInput = document.getElementById(`tradeAmount-${symbol}`);
        const amount = amountInput ? parseFloat(amountInput.value) : 1;
        
        autoExecutionSignals.set(symbol, { signal, tradeType, amount });
        console.log('[Frontend] Auto-execution enabled for', symbol);
        showToast(`Auto-execution enabled for ${symbol}`);
      } else {
        autoExecutionSignals.delete(symbol);
        console.log('[Frontend] Auto-execution disabled for', symbol);
        showToast(`Auto-execution disabled for ${symbol}`);
      }
    }
    
    /**
     * Check if entry price is hit and execute if auto-execution is enabled
     * This should be called periodically or when price updates
     */
    async function checkAutoExecution(symbol, currentPrice) {
      const autoExec = autoExecutionSignals.get(symbol);
      if (!autoExec) return;
      
      const { signal, tradeType, amount } = autoExec;
      const entryZone = signal.entryZone || signal.entry_zone;
      
      if (!entryZone || !entryZone.min || !entryZone.max) return;
      
      // Check if price is in entry zone
      const inZone = currentPrice >= entryZone.min && currentPrice <= entryZone.max;
      
      if (inZone) {
        console.log('[Frontend] Entry zone hit for', symbol, 'at', currentPrice);
        // Disable auto-execution to prevent multiple executions
        autoExecutionSignals.delete(symbol);
        const checkbox = document.getElementById(`autoExec-${symbol}`);
        if (checkbox) checkbox.checked = false;
        
        // Execute trade
        await executeTrade(symbol, signal);
      }
    }
    
    /**
     * Track an executed trade
     * @param {string} symbol - Trading symbol
     */
    window.trackExecutedTrade = function(symbol) {
      try {
        console.log('[Frontend] Tracking executed trade for', symbol);
        
        const trackBtn = document.getElementById(`trackTradeBtn-${symbol}`);
        if (!trackBtn) {
          showToast('Trade data not found');
          return;
        }
        
        const tradeDataStr = trackBtn.getAttribute('data-trade-data');
        if (!tradeDataStr) {
          showToast('Trade data not available');
          return;
        }
        
        const tradeData = JSON.parse(tradeDataStr);
        const { signal, result } = tradeData;
        
        console.log('[Frontend] Trade data:', tradeData);
        
        // Get current price from signal or calculate from result
        const entryPrice = signal.entryZone ? 
          (signal.entryZone.min + signal.entryZone.max) / 2 : 
          parseFloat(result.inputAmount) / parseFloat(result.outputAmount);
        
        // Calculate actual entry from swap result
        // For long: we spent inputAmount USDC and got outputAmount tokens
        // Entry price = inputAmount / outputAmount (in human-readable units)
        const inputAmountUSD = parseFloat(result.inputAmount) / 1000000; // USDC has 6 decimals
        
        // Get token decimals based on symbol (SOL=9, BTC/ETH=8)
        const tokenDecimals = symbol.includes('SOL') ? 9 : 8;
        const outputAmountTokens = parseFloat(result.outputAmount) / Math.pow(10, tokenDecimals);
        const actualEntryPrice = inputAmountUSD / outputAmountTokens;
        
        console.log('[Frontend] Trade execution details:');
        console.log('[Frontend]   - Input (USDC):', inputAmountUSD);
        console.log('[Frontend]   - Output (tokens):', outputAmountTokens);
        console.log('[Frontend]   - Entry Price:', actualEntryPrice);
        console.log('[Frontend]   - Transaction:', result.signature);
        console.log('[Frontend]   - Explorer:', result.explorerUrl);
        
        // Get signal snapshot from current scan results
        const signalSnapshot = scanResults[symbol];
        
        // Build trade object for tracker
        const trackedTrade = {
          id: Date.now(),
          symbol: symbol,
          direction: result.direction.toUpperCase(),
          entry: parseFloat(actualEntryPrice.toFixed(2)),
          entryZone: signal.entryZone || { min: actualEntryPrice * 0.99, max: actualEntryPrice * 1.01 },
          stopLoss: signal.stopLoss || null,
          target1: signal.targets && signal.targets[0] ? signal.targets[0] : null,
          target2: signal.targets && signal.targets[1] ? signal.targets[1] : null,
          strategy: signal.strategyName || 'EXECUTED',
          playbook: `${signal.strategyName || 'EXECUTED'} ${result.direction.toUpperCase()}`,
          riskPercent: 1,
          confidence: signal.confidence || 0,
          notes: `Executed via Jupiter Swap\nTransaction: ${result.signature.substring(0, 16)}...\nInput: ${inputAmountUSD.toFixed(2)} USDC\nOutput: ${outputAmountTokens.toFixed(8)} tokens`,
          journal: `Trade executed via Jupiter Swap\n\nTransaction Signature: ${result.signature}\nExplorer: ${result.explorerUrl}\nInput Amount: ${inputAmountUSD.toFixed(2)} USDC\nOutput Amount: ${outputAmountTokens.toFixed(8)} tokens\nPrice Impact: ${result.priceImpact || 'N/A'}%\nEntry Price: ${actualEntryPrice.toFixed(2)}`,
          imageUrl: null,
          trackedAt: Date.now(),
          entryTime: new Date().toISOString(),
          status: 'ACTIVE',
          exitPrice: null,
          exitTime: null,
          outcome: null,
          autoTracked: false,
          executedTrade: true, // Flag to indicate this was an executed trade
          executionData: {
            signature: result.signature,
            explorerUrl: result.explorerUrl,
            inputAmount: result.inputAmount,
            outputAmount: result.outputAmount,
            priceImpact: result.priceImpact,
            tradeType: result.tradeType,
            executedAt: tradeData.executedAt
          },
          signalSnapshot: signalSnapshot || null,
          review: {
            whatWentRight: '',
            whatWentWrong: '',
            performanceSummary: ''
          }
        };
        
        console.log('[Frontend] Tracked trade object:', trackedTrade);
        
        // Store in localStorage for tracker to pick up
        const tradeJSON = JSON.stringify(trackedTrade);
        localStorage.setItem('pendingTradeToTrack', tradeJSON);
        
        // Update button to show success
        trackBtn.textContent = ' Trade Tracked';
        trackBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
        trackBtn.disabled = true;
        
        showToast(` Trade tracked! Opening tracker...`);
        
        // Automatically open tracker (don't ask)
        setTimeout(() => {
          window.open('/tracker.html?autoTrack=true', '_blank');
        }, 500);
        
      } catch (error) {
        console.error('[Frontend] Error tracking trade:', error);
        showToast(`Error tracking trade: ${error.message}`);
      }
    }
    
    // Set up auto-execution checkbox listeners
    document.addEventListener('change', (e) => {
      if (e.target.id && e.target.id.startsWith('autoExec-')) {
        const symbol = e.target.dataset.symbol;
        const data = scanResults[symbol];
        if (data && data.signal && data.signal.valid) {
          enableAutoExecution(symbol, data.signal);
        }
      }
    });
  </script>

  <!-- Particles.js Library -->
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    // Initialize particle system
    particlesJS('particles-js', {
      particles: {
        number: {
          value: 500,
          density: {
            enable: true,
            value_area: 800
          }
        },
        color: {
          value: '#ffffff'
        },
        shape: {
          type: 'circle'
        },
        opacity: {
          value: 0.5,
          random: true,
          anim: {
            enable: true,
            speed: 1,
            opacity_min: 0.1,
            sync: false
          }
        },
        size: {
          value: 2,
          random: true,
          anim: {
            enable: false
          }
        },
        line_linked: {
          enable: false
        },
        move: {
          enable: true,
          speed: 0.5,
          direction: 'none',
          random: true,
          straight: false,
          out_mode: 'out',
          bounce: false
        }
      },
      interactivity: {
        detect_on: 'canvas',
        events: {
          onhover: {
            enable: true,
            mode: 'grab'
          },
          onclick: {
            enable: false
          },
          resize: true
        },
        modes: {
          grab: {
            distance: 140,
            line_linked: {
              opacity: 0.3
            }
          }
        }
      },
      retina_detect: true
    });
  </script>

</body>
</html>
