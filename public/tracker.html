<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trade Tracker - EditTrades</title>
  
  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="EditTrades">
  <meta property="og:description" content="EditTrades">
  <meta property="og:image" content="/logos/og_img.jpg">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="EditTrades">
  <meta name="twitter:description" content="EditTrades">
  <meta name="twitter:image" content="/logos/og_img.jpg">
  
  <!-- External Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Styles -->
  <link rel="stylesheet" href="/edittrax-styles.css">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
  
  <style>
    /* Font Strategy: Mathias for labels/headings, System font for content */
    h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-mathias);
    }
    
    p, ul, li, .card p, .card ul, .card li, input, select, textarea {
      font-family: var(--font-system);
    }
    
    /* Strong tags in content should use Mathias for emphasis */
    li strong, p strong {
      font-family: var(--font-mathias);
    }

    body {
      background-color: #000000;
      position: relative;
      min-height: 100vh;
    }
    
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 0;
    }
    
    header, main {
      position: relative;
      z-index: 1;
    }
    
    .form-group {
      margin-bottom: 1rem;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    
    .grid {
      width: 100%;
      box-sizing: border-box;
    }
    
    .form-label {
      display: block;
      font-family: var(--font-mathias);
      font-size: 0.875rem;
      font-weight: bold;
      color: var(--color-yellow-75);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .form-input, .form-select {
      width: 100%;
      padding: 0.75rem;
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid var(--color-yellow-75);
      border-radius: 0.5rem;
      color: var(--color-yellow-75);
      font-size: 1rem;
      font-family: var(--font-system);
      box-sizing: border-box;
      max-width: 100%;
    }
    
    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: var(--color-yellow-75);
      box-shadow: 0 0 0 3px rgba(230, 233, 224, 0.1);
    }
    
    .details-row {
      display: none;
    }
    
    .details-row.expanded {
      display: table-row;
    }
    
    /* Details row - fill table width */
    .details-row.expanded td {
      width: 100% !important;
      max-width: 100% !important;
      padding: 1rem !important;
      box-sizing: border-box !important;
    }
    
    .details-content-wrapper {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* Details content wrapper should stretch full width */
    .details-content-wrapper {
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      margin: 0 auto;
    }
    
    /* Table row styling */
    .coin-row {
      position: relative;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      background-color: transparent;
    }
    
    /* Static glow background for LONG trades */
    .coin-row.has-trade-long {
      background: radial-gradient(
        ellipse at 0% 50%,
        rgba(34, 197, 94, 0.2) 0%,
        rgba(34, 197, 94, 0.12) 30%,
        rgba(34, 197, 94, 0.06) 60%,
        rgba(34, 197, 94, 0.02) 100%
      );
    }
    
    /* Static glow background for SHORT trades */
    .coin-row.has-trade-short {
      background: radial-gradient(
        ellipse at 0% 50%,
        rgba(239, 68, 68, 0.2) 0%,
        rgba(239, 68, 68, 0.12) 30%,
        rgba(239, 68, 68, 0.06) 60%,
        rgba(239, 68, 68, 0.02) 100%
      );
    }
    
    /* Static glow background for PENDING trades */
    .coin-row.has-trade-pending {
      background: radial-gradient(
        ellipse at 0% 50%,
        rgba(255, 165, 0, 0.2) 0%,
        rgba(255, 165, 0, 0.12) 30%,
        rgba(255, 165, 0, 0.06) 60%,
        rgba(255, 165, 0, 0.02) 100%
      );
    }
    
    /* All table cells */
    .coin-row > td {
      background-color: transparent;
      position: relative;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Desktop column widths */
    @media (min-width: 769px) {
      .table-edittrax th,
      .table-edittrax td {
        padding: var(--spacing-2) var(--spacing-2);
      }
      
      /* Set fixed column widths */
      .table-edittrax thead th:nth-child(1),
      .table-edittrax tbody td:nth-child(1) { 
        width: 150px; 
        min-width: 150px;
        max-width: 150px;
        white-space: nowrap;
        text-align: center;
      } /* TRADE */
      
      .table-edittrax thead th:nth-child(2),
      .table-edittrax tbody td:nth-child(2) { 
        width: 100px; 
        min-width: 100px;
        max-width: 100px;
        white-space: nowrap;
        text-align: left;
        padding-left: 1rem;
      } /* P&L */
      
      .table-edittrax thead th:nth-child(3),
      .table-edittrax tbody td:nth-child(3) { 
        width: auto;
        text-align: left;
        padding-left: 1rem;
      } /* STATUS - fills remaining space */
      
      .table-edittrax thead th:nth-child(4),
      .table-edittrax tbody td:nth-child(4) { 
        width: 120px;
        min-width: 120px;
        max-width: 120px;
        white-space: nowrap;
        text-align: center;
      } /* DETAILS */
      
      .coin-row {
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
    }
    
    /* Mobile Styles */
    @media (max-width: 768px) {
      .max-w-6xl.mx-auto.pt-3 {
        padding-left: 5px !important;
        padding-right: 5px !important;
      }
      
      main.max-w-6xl.mx-auto {
        padding-left: 5px !important;
        padding-right: 5px !important;
      }
      
      #tradesContainer {
        padding-left: 5px !important;
        padding-right: 5px !important;
      }
      
      .header-edittrax > div > div[style*="position: absolute"][style*="left: 0"] {
        left: calc(5px + 8px) !important;
        font-size: 0.6rem !important;
      }
      
      .header-edittrax > div > div[style*="position: absolute"][style*="right: 0"] {
        right: 5px !important;
        font-size: 0.6rem !important;
      }
      
      /* Hide table header on mobile */
      .table-edittrax thead {
        display: none;
      }
      
      /* Mobile table adjustments */
      .coin-row {
        display: block !important;
        padding: 0 0.5rem 1rem 0.5rem;
        border-bottom: 2px solid var(--color-yellow-75);
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      
      .table-edittrax tbody {
        display: block !important;
      }
      
      .table-edittrax tbody tr.coin-row {
        display: block !important;
      }
      
      /* Keep details row hidden unless expanded */
      .table-edittrax tbody tr.details-row {
        display: none !important;
      }
      
      .table-edittrax tbody tr.details-row.expanded {
        display: block !important;
      }
      
      .table-edittrax tbody tr.details-row.expanded td {
        display: block !important;
        width: 100% !important;
        padding: 1rem !important;
      }
      
      .table-edittrax tbody tr.details-row.expanded .details-content-wrapper {
        width: 100% !important;
        max-width: 100% !important;
      }
      
      /* Create flex container for rows */
      .coin-row::after {
        content: "";
        display: table;
        clear: both;
      }
      
      .coin-row td {
        padding: 1.65rem 0 !important;
        border: none;
        text-align: left !important;
        max-width: 100%;
        box-sizing: border-box;
        display: block;
      }
      
      .coin-row td:before {
        content: attr(data-label);
        font-weight: bold;
        display: block;
        margin-bottom: 0.25rem;
        color: var(--color-yellow-75);
        font-family: var(--font-mathias);
        font-size: 0.75rem;
      }
      
      /* Trade name and P&L on same row */
      .coin-row td:first-child,
      .coin-row td:nth-child(2) {
        display: inline-block;
        vertical-align: top;
      }
      
      .coin-row td:first-child {
        width: auto;
        max-width: 50%;
        font-size: 1.25rem;
        padding-right: 0.5rem !important;
        padding-left: 0 !important;
        text-align: left !important;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        box-sizing: border-box;
      }
      
      .coin-row td:first-child > div {
        align-items: flex-start !important;
        justify-content: flex-start !important;
      }
      
      .coin-row td:first-child > div > div {
        text-align: left !important;
        font-size: 1.25rem !important;
      }
      
      .coin-row td:first-child:before {
        display: none;
      }
      
      .coin-row td:nth-child(2) {
        width: auto;
        float: right;
        text-align: right;
        padding-left: 0.5rem !important;
      }
      
      .coin-row td:nth-child(2):before {
        display: none;
      }
      
      /* Make P&L text larger on mobile to match signal size on homepage */
      .coin-row td:nth-child(2) > div {
        font-size: 1.25rem !important;
        text-align: right !important;
      }
      
      /* Status on its own row */
      .coin-row td:nth-child(3) {
        display: block;
        clear: both;
        width: 100%;
      }
      
      /* Details button on its own row */
      /* Hide TIME header on mobile */
      .time-header {
        display: none !important;
      }
      
      /* TIME cell on mobile - display inline with status */
      .time-cell {
        display: inline-block !important;
        width: auto !important;
        min-width: 0 !important;
        max-width: none !important;
        padding-right: 1rem !important;
      }
      
      .coin-row td:nth-child(5) {
        display: block !important;
        width: 100% !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        max-width: 100% !important;
      }
      
      .coin-row td:nth-child(5):before {
        display: none !important;
      }
      
      /* Make buttons full width on mobile */
      .coin-row .details-button-cell {
        display: block !important;
        width: 100% !important;
      }
      
      .coin-row .details-button,
      .coin-row td:nth-child(5) button,
      .coin-row .details-button-cell button {
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        display: block !important;
      }
      
      /* Mobile modal adjustments */
      #addTradeModal {
        padding: 0.75rem !important;
      }
      
      #addTradeModal > div {
        padding: 1rem !important;
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 !important;
      }
    }
  </style>
</head>
<body>
  <!-- Particles Background -->
  <div id="particles-js"></div>
  
  <!-- Color Bar -->
  <img 
    src="/logos/color_bar.png" 
    alt="Color Bar" 
    style="position: fixed; top: 0; left: 0; width: 100%; height: 5px; max-height: 5px; z-index: 9999; pointer-events: none; display: block; object-fit: cover;"
  >

  <!-- Header -->
  <header class="header-edittrax text-white" style="overflow: visible; position: relative;">
    <div class="max-w-6xl mx-auto pt-3" style="width: 100%; box-sizing: border-box; padding-left: 1rem; padding-right: 1rem; position: relative;">
      
      <!-- Top Left: Timers -->
      <div style="position: absolute; top: 25px; left: 0; display: flex; flex-direction: column; gap: 6px; z-index: 50; font-family: var(--font-mathias); color: var(--color-yellow-75); font-size: 0.75rem; font-weight: bold;">
        <!-- 1M Candle Timer -->
        <div id="1m-timer-container" style="display: flex; align-items: center; gap: 8px;">
          <span>1M</span>
          <div style="width: 50px; height: 3px; background-color: rgba(230, 233, 224, 0.2); border-radius: 2px; overflow: hidden;">
            <div id="candle-timer-bar" style="width: 100%; height: 100%; background-color: var(--color-yellow-75); transition: width 0.5s linear;"></div>
          </div>
        </div>
        <!-- 4H Candle Timer -->
        <div id="4h-timer-container" style="display: flex; align-items: center; gap: 8px;">
          <span>4H</span>
          <div style="width: 50px; height: 3px; background-color: rgba(230, 233, 224, 0.2); border-radius: 2px; overflow: hidden;">
            <div id="4h-timer-bar" style="width: 100%; height: 100%; background-color: var(--color-yellow-75); transition: width 0.5s linear;"></div>
          </div>
        </div>
      </div>
      
      <!-- Top Right Actions -->
      <div style="position: absolute; top: 25px; right: 0; display: flex; flex-direction: column; gap: 17px; align-items: flex-end; z-index: 50; font-family: var(--font-mathias); font-size: 0.75rem;">
        <!-- Home -->
        <a 
          href="/"
          style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem; text-decoration: none;"
          title="Back to Home"
        >
          <span style="font-weight: bold;">‚Üê HOME</span>
        </a>
      </div>
      
      <div class="flex flex-col items-center gap-3 w-full">
        <div class="logo-container flex flex-col items-center gap-2">
          <img src="/logos/load.gif" alt="Loading Animation" style="width: 140px; height: auto;">
          <img src="/logos/et_horizontal.png" alt="EditTrades Logo" class="logo-img">
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="max-w-6xl mx-auto pb-4" style="width: 100%; box-sizing: border-box;overflow: visible; position: relative;">
    
    <!-- Add New Trade Button -->
    <div style="padding: 1rem; display: flex; justify-content: center; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
      <button 
        onclick="document.getElementById('addTradeModal').style.display='flex'"
        class="btn-base btn-secondary text-xs sm:text-sm rounded text-center whitespace-nowrap"
        style="padding: 0.5rem 1rem; transition: all 0.3s ease;"
      >
        + ADD NEW TRADE
      </button>
      <button 
        onclick="refreshTrades()"
        class="btn-base btn-secondary text-xs sm:text-sm rounded text-center whitespace-nowrap"
        style="padding: 0.5rem 1rem; transition: all 0.3s ease; display: inline-flex; align-items: center; gap: 8px;"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
        </svg>
        <span>REFRESH</span>
      </button>
    </div>
    
    <!-- Trades Table (Exact copy of homepage table structure) -->
    <div id="tradesContainer" style="padding-left: 1rem; padding-right: 1rem;">
      <div class="card-edittrax rounded-lg mb-4" style="overflow: hidden; border: 2px solid var(--color-yellow-75); max-width: 100%; box-sizing: border-box;">
        <div class="table-container" style="width: 100%; overflow-x: auto; margin: 0; padding: 0; border: none; box-sizing: border-box;">
          <table class="table-edittrax" style="border: none; margin: 0; border-collapse: collapse; width: 100%; max-width: 100%; table-layout: fixed; box-sizing: border-box;">
            <thead style="background-color: var(--color-yellow-75); border: none; border-left: none; border-right: none;">
              <tr style="border: none; border-left: none; border-right: none;">
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; text-align: center; border: none; border-left: none; width: 150px; min-width: 150px; max-width: 150px;">TRADE</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; text-align: left; width: 100px; min-width: 100px; max-width: 100px;">P&L</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; text-align: left;">STATUS</th>
                <th class="px-2 time-header" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; text-align: left; width: 90px; min-width: 90px; max-width: 90px;">TIME</th>
                <th class="px-2" style="padding-top: 0.9rem; padding-bottom: 0.9rem; color: black; width: 120px; min-width: 120px; max-width: 120px;"></th>
              </tr>
            </thead>
            <tbody id="tradesTable">
              <!-- Trade rows will be populated here -->
            </tbody>
          </table>
        </div>
        
        <!-- Legend -->
        <div style="padding: 0.75rem 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
          <a 
            href="/strategy.html"
            style="display: inline-flex; align-items: center; gap: 8px; background: transparent; border: none; color: var(--color-yellow-75); cursor: pointer; padding: 4px 8px; font-family: var(--font-mathias); font-size: 0.75rem; text-decoration: none;"
            title="Proof of Strategy"
          >
            <span style="font-weight: bold;">PROOF OF STRATEGY</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          </a>
        </div>
      </div>
      
      <!-- Stats Panel (moved below table, collapsed by default) -->
      <div id="statsPanel" style="margin-top: 2rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); border: 2px solid var(--color-yellow-75);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;" onclick="toggleStatsPanel()">
          <h2 style="font-family: var(--font-mathias); font-size: 1.25rem; font-weight: bold; color: var(--color-yellow-75); text-transform: uppercase; margin: 0;">
            Trade Analytics
          </h2>
          <span id="statsToggleIcon" style="color: var(--color-yellow-75); font-size: 1.5rem;">‚ñ∂</span>
        </div>
        <div id="statsContent" style="display: none;">
          <div id="statsDisplay" style="font-family: var(--font-system); font-size: 0.875rem; color: var(--text-secondary);">
            <p>Loading statistics...</p>
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <!-- Add Trade Modal -->
  <div id="addTradeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; padding: 2rem; box-sizing: border-box; overflow-x: hidden;">
    <div class="card rounded-lg" style="max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; overflow-x: hidden; border: 2px solid var(--color-yellow-75); background-color: #000000; padding: 2rem; box-sizing: border-box;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
        <h2 class="text-2xl font-bold">Add New Trade</h2>
        <button 
          onclick="document.getElementById('addTradeModal').style.display='none'"
          style="background: transparent; border: none; color: var(--color-yellow-75); font-size: 1.5rem; cursor: pointer; padding: 0; width: 30px; height: 30px;"
        >
          √ó
        </button>
      </div>
      
      <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1.5rem;">
        Enter your trade details - we'll auto-calculate targets and track your P&L in real-time.
      </p>
      
      <form id="addTradeForm" style="overflow-x: hidden; width: 100%; box-sizing: border-box;">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div class="form-group">
            <label class="form-label">Symbol</label>
            <select id="symbol" class="form-select" required>
              <option value="BTCUSDT">Bitcoin (BTC)</option>
              <option value="ETHUSDT">Ethereum (ETH)</option>
              <option value="SOLUSDT">Solana (SOL)</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">Direction</label>
            <select id="direction" class="form-select" required>
              <option value="">Select Direction</option>
              <option value="LONG">Long (Buy)</option>
              <option value="SHORT">Short (Sell)</option>
            </select>
          </div>
          
          <div class="form-group" style="grid-column: 1 / -1;">
            <label class="form-label">Entry Price</label>
            <input type="number" id="entry" class="form-input" step="0.01" placeholder="e.g. 42000" required>
          </div>
        </div>
        
        <div id="tradePreview" style="display: none; margin-top: 1rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.05); border-radius: 0.5rem; border: 1px solid rgba(255, 255, 255, 0.1);">
          <p style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.875rem; font-weight: bold; margin-bottom: 0.5rem;">AUTO-CALCULATED:</p>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.875rem;">
            <div>
              <span style="color: var(--text-secondary);">Direction:</span>
              <span id="previewDirection" style="color: var(--color-yellow-75); font-weight: bold; margin-left: 0.25rem;"></span>
            </div>
            <div>
              <span style="color: var(--text-secondary);">Stop:</span>
              <span id="previewStop" style="color: #ef4444; font-weight: bold; margin-left: 0.25rem;"></span>
            </div>
            <div>
              <span style="color: var(--text-secondary);">TP1:</span>
              <span id="previewTP1" style="color: #22c55e; font-weight: bold; margin-left: 0.25rem;"></span>
            </div>
            <div>
              <span style="color: var(--text-secondary);">TP2:</span>
              <span id="previewTP2" style="color: #22c55e; font-weight: bold; margin-left: 0.25rem;"></span>
            </div>
          </div>
        </div>
        
        <div class="form-group mt-4">
          <label class="form-label">Stop Loss</label>
          <input type="number" id="stopLoss" class="form-input" step="0.01" placeholder="e.g. 41000" required>
        </div>
        
        <div class="form-group mt-4">
          <label class="form-label">Journal / Notes (Optional)</label>
          <textarea 
            id="journal" 
            class="form-input" 
            rows="4" 
            placeholder="Add your trade thesis, setup notes, or any observations..."
            style="resize: vertical; min-height: 100px;"
          ></textarea>
          <small style="color: rgba(230, 233, 224, 0.6); font-size: 0.75rem; margin-top: 0.25rem; display: block;">
            Document your reasoning, market conditions, or anything relevant to this trade.
          </small>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr; gap: 0.75rem; margin-top: 1rem;">
          <button 
            type="submit" 
            class="btn-base btn-secondary px-4 py-2 text-sm rounded"
            style="width: 100%; background-color: var(--color-yellow-75); color: black; font-weight: bold; transition: all 0.3s ease;"
          >
            ADD TRADE
          </button>
          
          <label for="uploadTrade" style="width: 100%; cursor: pointer; display: block; box-sizing: border-box;">
            <input 
              type="file" 
              id="uploadTrade" 
              accept="image/*,.pdf,.csv"
              style="display: none;"
              onchange="handleFileUpload(event)"
            >
            <div class="btn-base btn-secondary px-4 py-2 text-sm rounded" style="width: 100%; max-width: 100%; text-align: center; font-family: var(--font-mathias); font-weight: bold; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 0.5rem; box-sizing: border-box;">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
              <span>UPLOAD TRADE</span>
            </div>
          </label>
        </div>
      </form>
    </div>
  </div>

  <!-- Scripts -->
  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBbelW2KJhS6d9XjlfeNVBmWMIRLlPJt18",
      authDomain: "edittrades-fd451.firebaseapp.com",
      projectId: "edittrades-fd451",
      storageBucket: "edittrades-fd451.firebasestorage.app",
      messagingSenderId: "19886833588",
      appId: "1:19886833588:web:321896aa22c76f5184bce1",
      measurementId: "G-0DCF1KBHMG"
    };
    
    // Initialize Firebase
    let db, storage;
    console.log('üî• INITIALIZING FIREBASE...');
    console.log('üî• firebaseConfig:', firebaseConfig);
    try {
      console.log('üî• Calling firebase.initializeApp()...');
      firebase.initializeApp(firebaseConfig);
      console.log('üî• Getting Firestore instance...');
      db = firebase.firestore();
      console.log('üî• Getting Storage instance...');
      storage = firebase.storage();
      console.log('‚úÖ FIREBASE INITIALIZED SUCCESSFULLY');
      console.log('‚úÖ db exists?', !!db);
      console.log('‚úÖ storage exists?', !!storage);
    } catch (error) {
      console.error('‚ùå FIREBASE INITIALIZATION ERROR:', error);
      console.error('‚ùå Error message:', error.message);
      console.error('‚ùå Error stack:', error.stack);
      console.log('‚ö†Ô∏è Falling back to localStorage');
    }
    
    // Trade storage
    let trades = [];
    let priceCache = {};
    
    console.log('üì¶ Loading trades from Firebase...');
    
    // 1-minute candle timer
    function updateCandleTimer() {
      const now = new Date();
      const seconds = now.getSeconds();
      const msIntoSecond = now.getMilliseconds();
      const percentComplete = (seconds + msIntoSecond / 1000) / 60;
      const percentRemaining = 1 - percentComplete;
      
      const bar = document.getElementById('candle-timer-bar');
      if (bar) {
        bar.style.width = `${percentRemaining * 100}%`;
      }
    }
    
    // 4-hour candle timer
    function update4HTimer() {
      const now = new Date();
      const fourHoursMs = 4 * 60 * 60 * 1000;
      const msInto4H = now.getTime() % fourHoursMs;
      const percentComplete = msInto4H / fourHoursMs;
      const percentRemaining = 1 - percentComplete;
      
      const bar = document.getElementById('4h-timer-bar');
      if (bar) {
        bar.style.width = `${percentRemaining * 100}%`;
      }
    }
    
    // Start timers
    function startCandleTimers() {
      updateCandleTimer();
      update4HTimer();
      
      setInterval(updateCandleTimer, 500);
      setInterval(update4HTimer, 1000);
    }
    
    // Auto-calculate trade parameters
    let calculatedTrade = null;
    
    async function updateTradePreview() {
      const symbol = document.getElementById('symbol').value;
      const entryInput = document.getElementById('entry').value;
      const directionInput = document.getElementById('direction').value;
      const stopLossInput = document.getElementById('stopLoss').value;
      
      console.log('üîÑ Preview update:', { symbol, entry: entryInput, direction: directionInput, stopLoss: stopLossInput });
      
      if (!entryInput || parseFloat(entryInput) <= 0 || !directionInput || !stopLossInput || parseFloat(stopLossInput) <= 0) {
        console.log('‚ö†Ô∏è Missing inputs, hiding preview');
        document.getElementById('tradePreview').style.display = 'none';
        return;
      }
      
      const entry = parseFloat(entryInput);
      const direction = directionInput;
      const stopLoss = parseFloat(stopLossInput);
      
      // Validate stop loss is on correct side
      if (direction === 'LONG' && stopLoss >= entry) {
        document.getElementById('tradePreview').style.display = 'none';
        return;
      }
      if (direction === 'SHORT' && stopLoss <= entry) {
        document.getElementById('tradePreview').style.display = 'none';
        return;
      }
      
      // Calculate risk
      const risk = Math.abs(entry - stopLoss);
      
      // Calculate targets (1R and 2R)
      const target1 = direction === 'LONG' ?
        entry + risk : // 1R above entry
        entry - risk;  // 1R below entry
      
      const target2 = direction === 'LONG' ?
        entry + (risk * 2) : // 2R above entry
        entry - (risk * 2);  // 2R below entry
      
      // Auto-detect strategy based on current timeframe analysis
      let strategy = 'SCALP'; // Default
      try {
        const response = await fetch(`/api/analyze/${symbol}?intervals=4h,1h,15m`);
        const data = await response.json();
        const signal = data.signal || data.tradeSignal;
        if (signal && signal.setupType) {
          const setupType = signal.setupType.toUpperCase();
          if (setupType.includes('4H')) strategy = '4H';
          else if (setupType.includes('SWING')) strategy = 'SWING';
          else if (setupType.includes('MICRO')) strategy = 'MICROSCALP';
          else strategy = 'SCALP';
        }
      } catch (error) {
        console.log('Could not auto-detect strategy, using default');
      }
      
      // Store calculated trade
      calculatedTrade = {
        direction,
        stopLoss,
        target1,
        target2,
        strategy,
        riskPercent: 1 // Default 1% risk
      };
      
      // Update preview
      document.getElementById('previewDirection').textContent = direction;
      document.getElementById('previewDirection').style.color = direction === 'LONG' ? '#22c55e' : '#ef4444';
      document.getElementById('previewStop').textContent = `$${stopLoss.toFixed(2)}`;
      document.getElementById('previewTP1').textContent = `$${target1.toFixed(2)}`;
      document.getElementById('previewTP2').textContent = `$${target2.toFixed(2)}`;
      document.getElementById('previewRisk').textContent = `${((risk / entry) * 100).toFixed(2)}%`;
      
      document.getElementById('tradePreview').style.display = 'block';
    }
    
    // Initialize on page load
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('üöÄ PAGE LOADED - DOMContentLoaded fired');
      startCandleTimers();
      
      // Load trades from Firebase
      console.log('üì• STEP 1: Calling loadTrades()...');
      await loadTrades();
      console.log('üì• STEP 1 COMPLETE: loadTrades() finished. Trades array:', trades);
      
      // Check if auto-tracking a trade from homepage
      const urlParams = new URLSearchParams(window.location.search);
      console.log('üîç URL Params:', window.location.search);
      console.log('üîç autoTrack param:', urlParams.get('autoTrack'));
      
      // If autoTrack=true, automatically add the trade (don't open modal)
      if (urlParams.get('autoTrack') === 'true') {
        const pendingTradeData = localStorage.getItem('pendingTradeToTrack');
        console.log('üîç Pending trade data from localStorage:', pendingTradeData);
        
        if (pendingTradeData) {
          try {
            const tradeToAdd = JSON.parse(pendingTradeData);
            console.log('üéØ Auto-tracking trade from homepage:', tradeToAdd);
            console.log('üîç Current trades array length before add:', trades.length);
            
            // Ensure new fields exist for backward compatibility
            if (!tradeToAdd.signalSnapshot) {
              // Try to reconstruct from available data
              tradeToAdd.signalSnapshot = {
                symbol: tradeToAdd.symbol,
                price: tradeToAdd.entry || 0,
                htfBias: { direction: 'neutral', confidence: 0, source: 'none' },
                timeframes: {},
                signal: {
                  valid: true,
                  direction: tradeToAdd.direction,
                  setupType: tradeToAdd.strategy,
                  selectedStrategy: tradeToAdd.strategy,
                  strategiesChecked: [],
                  confidence: tradeToAdd.confidence / 100 || 0,
                  reason: 'Auto-tracked trade',
                  entryZone: tradeToAdd.entryZone || { min: tradeToAdd.entry, max: tradeToAdd.entry },
                  stopLoss: tradeToAdd.stopLoss,
                  invalidationLevel: tradeToAdd.invalidationLevel,
                  targets: [tradeToAdd.target1, tradeToAdd.target2],
                  riskReward: { tp1RR: null, tp2RR: null }
                },
                meta: {
                  scanTime: new Date().toISOString(),
                  mode: 'STANDARD'
                }
              };
            }
            
            // Ensure review object exists
            if (!tradeToAdd.review) {
              tradeToAdd.review = {
                whatWentRight: '',
                whatWentWrong: '',
                performanceSummary: ''
              };
            }
            
            // Ensure playbook exists
            if (!tradeToAdd.playbook) {
              tradeToAdd.playbook = `${tradeToAdd.strategy} ${tradeToAdd.direction}`;
            }
            
            // Add to trades array
            trades.push(tradeToAdd);
            console.log('üîç Current trades array length after add:', trades.length);
            console.log('üîç All trades:', trades);
            
            // Save to Firebase
            await saveTrades();
            console.log('üíæ Trade saved to Firebase');
            
            // Clear the pending trade and signal snapshot (prevent modal from opening)
            localStorage.removeItem('pendingTradeToTrack');
            localStorage.removeItem('pendingSignal'); // Clear signal snapshot too
            
            // Remove autoTrack param from URL (clean URL)
            window.history.replaceState({}, document.title, window.location.pathname);
            
            console.log('‚úÖ Trade auto-tracked successfully!');
            
            // IMPORTANT: Re-render trades immediately so the new trade appears
            console.log('üîÑ Re-rendering trades to show new trade...');
            await renderTrades();
            console.log('‚úÖ Trades re-rendered with new trade');
          } catch (error) {
            console.error('‚ùå Error auto-tracking trade:', error);
            console.error('Stack trace:', error.stack);
          }
        } else {
          console.warn('‚ö†Ô∏è No pending trade data found in localStorage');
        }
      }
      
      // Fetch prices immediately for all trades before rendering
      console.log('üí∞ STEP 2: Fetching initial prices for all trades...');
      const allTradesToPrice = trades.filter(t => t.status === 'ACTIVE' || t.status === 'PENDING');
      const uniqueSymbols = [...new Set(allTradesToPrice.map(t => t.symbol))];
      console.log(`üí∞ Fetching prices for ${uniqueSymbols.length} unique symbols:`, uniqueSymbols);
      
      let anyStatusChanged = false;
      for (const symbol of uniqueSymbols) {
        try {
          const price = await fetchPrice(symbol);
          if (price > 0) {
            priceCache[symbol] = price;
            console.log(`  ‚úÖ ${symbol}: $${price.toLocaleString()}`);
            
            // Check status for all trades with this symbol
            const tradesForSymbol = allTradesToPrice.filter(t => t.symbol === symbol);
            tradesForSymbol.forEach(trade => {
              const oldStatus = trade.status;
              checkTradeStatus(trade, price);
              if (trade.status !== oldStatus) {
                anyStatusChanged = true;
              }
            });
          }
        } catch (error) {
          console.error(`  ‚ùå Failed to fetch price for ${symbol}:`, error);
        }
      }
      
      // Save if any trades changed status (checkTradeStatus already saves individual changes, but this ensures batch save)
      if (anyStatusChanged) {
        await saveTrades();
      }
      
      console.log('üí∞ STEP 2 COMPLETE: Initial prices fetched and trade statuses checked');
      
      console.log('üé® STEP 3: Calling renderTrades()...');
      await renderTrades();
      console.log('üé® STEP 3 COMPLETE: renderTrades() finished');
      
      console.log('‚è±Ô∏è STEP 4: Starting price updates...');
      startPriceUpdates();
      console.log('‚è±Ô∏è STEP 5: Starting timer updates...');
      startTimerUpdates();
      console.log('‚úÖ ALL INITIALIZATION COMPLETE');
      
      // Add event listeners for auto-preview
      document.getElementById('symbol').addEventListener('change', updateTradePreview);
      document.getElementById('direction').addEventListener('change', updateTradePreview);
      document.getElementById('entry').addEventListener('input', updateTradePreview);
      document.getElementById('stopLoss').addEventListener('input', updateTradePreview);
    });
    
    // Add trade form submission
    document.getElementById('addTradeForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const symbol = document.getElementById('symbol').value;
      const direction = document.getElementById('direction').value;
      const entry = parseFloat(document.getElementById('entry').value);
      const stopLoss = parseFloat(document.getElementById('stopLoss').value);
      const notes = document.getElementById('tradeNotes')?.value || '';
      const journal = document.getElementById('journal').value || '';
      const uploadedImageUrl = document.getElementById('uploadedImageUrl')?.value || null;
      
      console.log('üìù Form submitted:', { symbol, direction, entry, stopLoss, journal, imageUrl: uploadedImageUrl });
      
      // Validate inputs
      if (!symbol || !direction || !entry || !stopLoss) {
        alert('Please fill in all required fields');
        return;
      }
      
      // Validate stop loss
      if (direction === 'LONG' && stopLoss >= entry) {
        alert('Stop loss must be below entry price for LONG trades');
        return;
      }
      if (direction === 'SHORT' && stopLoss <= entry) {
        alert('Stop loss must be above entry price for SHORT trades');
        return;
      }
      
      // Calculate targets
      const risk = Math.abs(entry - stopLoss);
      const target1 = direction === 'LONG' ? entry + risk : entry - risk;
      const target2 = direction === 'LONG' ? entry + (risk * 2) : entry - (risk * 2);
      
      // Auto-detect strategy
      let strategy = 'SCALP';
      try {
        const response = await fetch(`/api/analyze/${symbol}?intervals=4h,1h,15m`);
        const data = await response.json();
        const signal = data.signal || data.tradeSignal;
        if (signal && signal.setupType) {
          const setupType = signal.setupType.toUpperCase();
          if (setupType.includes('4H')) strategy = '4H';
          else if (setupType.includes('SWING')) strategy = 'SWING';
          else if (setupType.includes('MICRO')) strategy = 'MICROSCALP';
        }
      } catch (error) {
        console.log('Could not auto-detect strategy, using SCALP');
      }
      
      // Build playbook from strategy and direction
      const playbook = `${strategy} ${direction}`;
      
      // Create minimal signal snapshot for manually added trades
      const signalSnapshot = {
        symbol: symbol,
        price: entry,
        htfBias: { direction: 'neutral', confidence: 0, source: 'none' },
        timeframes: {},
        signal: {
          valid: true,
          direction: direction.toLowerCase(),
          setupType: strategy,
          selectedStrategy: strategy,
          strategiesChecked: [],
          confidence: 0,
          reason: 'Manually added trade',
          entryZone: { min: entry, max: entry },
          stopLoss: stopLoss,
          invalidationLevel: stopLoss,
          targets: [target1, target2],
          riskReward: { tp1RR: null, tp2RR: null }
        },
        meta: {
          scanTime: new Date().toISOString(),
          mode: 'STANDARD',
          currentPrice: entry
        }
      };
      
      const trade = {
        id: Date.now(),
        symbol: symbol,
        direction: direction,
        entry: entry,
        stopLoss: stopLoss,
        target1: target1,
        target2: target2,
        strategy: strategy,
        playbook: playbook, // NEW: Auto-populated
        riskPercent: 1,
        notes: notes || '',
        journal: journal,
        imageUrl: uploadedImageUrl,
        trackedAt: Date.now(), // Timestamp when trade tracking started
        entryTime: new Date().toISOString(),
        status: 'ACTIVE',
        exitPrice: null,
        exitTime: null,
        outcome: null,
        signalSnapshot: signalSnapshot, // NEW: Full canonical signal snapshot
        review: { // NEW: Review object structure
          whatWentRight: '',
          whatWentWrong: '',
          performanceSummary: ''
        },
        timestamp: firebase.firestore && firebase.firestore.FieldValue ? firebase.firestore.FieldValue.serverTimestamp() : new Date()
      };
      
      console.log('‚ûï Adding new trade:', trade);
      trades.push(trade);
      console.log('üìä Total trades now:', trades.length);
      
      saveTrades();
      renderTrades();
      
      // Reset form and preview
      document.getElementById('addTradeForm').reset();
      document.getElementById('tradePreview').style.display = 'none';
      document.getElementById('addTradeModal').style.display = 'none';
      calculatedTrade = null;
      
      // Clear uploaded image URL
      const imageUrlField = document.getElementById('uploadedImageUrl');
      if (imageUrlField) {
        imageUrlField.remove();
      }
      
      // Show success message
      alert(`‚úÖ ${trade.direction} trade added for ${trade.symbol.replace('USDT', '')}!`);
    });
    
    // Save trades to Firebase or localStorage
    async function saveTrades() {
      if (db) {
        try {
          // Save each trade to Firestore
          for (const trade of trades) {
            if (trade.id) {
              await db.collection('trades').doc(String(trade.id)).set(trade);
            }
          }
          console.log('üíæ Saved trades to Firebase:', trades.length, 'trades');
        } catch (error) {
          console.error('‚ùå Error saving to Firebase:', error);
          // Fallback to localStorage
          localStorage.setItem('trackedTrades', JSON.stringify(trades));
        }
      } else {
        // Fallback to localStorage
        localStorage.setItem('trackedTrades', JSON.stringify(trades));
        console.log('üíæ Saved trades to localStorage:', trades.length, 'trades');
      }
    }
    
    // Load trades from Firebase or localStorage
    async function loadTrades() {
      console.log('üîµ loadTrades() CALLED');
      console.log('üîç db exists?', !!db);
      console.log('üîç db value:', db);
      
      if (db) {
        console.log('‚úÖ Firebase DB is initialized, fetching from Firestore...');
        try {
          // Don't use orderBy to avoid index requirement - we'll sort in memory
          console.log('üì° Calling db.collection("trades").get()...');
          const snapshot = await db.collection('trades').get();
          console.log('üì° Snapshot received! Size:', snapshot.size);
          
          trades = [];
          snapshot.forEach(doc => {
            const tradeData = doc.data();
            console.log('  üìÑ Doc ID:', doc.id, '| Data:', tradeData);
            
            // Backward compatibility: add trackedAt if missing
            if (!tradeData.trackedAt) {
              tradeData.trackedAt = tradeData.id || Date.now();
            }
            
            // Backward compatibility: add signalSnapshot if missing
            if (!tradeData.signalSnapshot) {
              tradeData.signalSnapshot = {
                symbol: tradeData.symbol,
                price: tradeData.entry || 0,
                htfBias: { direction: 'neutral', confidence: 0, source: 'none' },
                timeframes: {},
                signal: {
                  valid: true,
                  direction: tradeData.direction?.toLowerCase() || 'long',
                  setupType: tradeData.strategy || 'SCALP',
                  selectedStrategy: tradeData.strategy || 'SCALP',
                  strategiesChecked: [],
                  confidence: tradeData.confidence ? tradeData.confidence / 100 : 0,
                  reason: 'Legacy trade - signal snapshot reconstructed',
                  entryZone: tradeData.entryZone || { min: tradeData.entry, max: tradeData.entry },
                  stopLoss: tradeData.stopLoss,
                  invalidationLevel: tradeData.invalidationLevel || tradeData.stopLoss,
                  targets: [tradeData.target1, tradeData.target2],
                  riskReward: { tp1RR: null, tp2RR: null }
                },
                meta: {
                  scanTime: new Date(tradeData.trackedAt).toISOString(),
                  mode: 'STANDARD',
                  currentPrice: tradeData.entry || 0
                }
              };
            }
            
            // Backward compatibility: add review object if missing
            if (!tradeData.review) {
              tradeData.review = {
                whatWentRight: '',
                whatWentWrong: '',
                performanceSummary: ''
              };
            }
            
            // Backward compatibility: add playbook if missing
            if (!tradeData.playbook) {
              tradeData.playbook = `${tradeData.strategy || 'SCALP'} ${tradeData.direction || 'LONG'}`;
            }
            
            console.log('  ‚úÖ Loaded trade from Firebase:', tradeData.symbol, tradeData.status, tradeData.id);
            trades.push(tradeData);
          });
          
          // Sort by ID (timestamp-based) descending
          trades.sort((a, b) => b.id - a.id);
          
          console.log('üì¶ LOADED', trades.length, 'trades from Firebase');
          console.log('üìã Trade IDs:', trades.map(t => t.id));
          console.log('üìã Trade statuses:', trades.map(t => `${t.symbol}:${t.status}`));
          console.log('üìã Full trades array:', trades);
          return trades;
        } catch (error) {
          console.error('‚ùå ERROR loading from Firebase:', error);
          console.error('‚ùå Error message:', error.message);
          console.error('‚ùå Stack trace:', error.stack);
          // Fallback to localStorage
          trades = JSON.parse(localStorage.getItem('trackedTrades') || '[]');
          console.log('üì¶ FALLBACK: Loaded', trades.length, 'trades from localStorage');
          return trades;
        }
      } else {
        console.log('‚ö†Ô∏è NO FIREBASE DB - Using localStorage');
        // Fallback to localStorage
        const storedTrades = localStorage.getItem('trackedTrades');
        console.log('üîç localStorage "trackedTrades":', storedTrades);
        trades = JSON.parse(storedTrades || '[]');
        console.log('üì¶ Loaded', trades.length, 'trades from localStorage');
        console.log('üìã Full trades array:', trades);
        return trades;
      }
    }
    
    // Fetch current price
    async function fetchPrice(symbol) {
      try {
        const response = await fetch(`/api/analyze/${symbol}?intervals=1m`);
        const data = await response.json();
        return data.currentPrice || priceCache[symbol] || 0;
      } catch (error) {
        console.error('Error fetching price:', error);
        return priceCache[symbol] || 0;
      }
    }
    
    // Format elapsed time from timestamp
    function formatElapsedTime(trackedAt) {
      if (!trackedAt) return '00:00:00';
      
      const now = Date.now();
      const elapsed = Math.floor((now - trackedAt) / 1000); // seconds
      
      const hours = Math.floor(elapsed / 3600);
      const minutes = Math.floor((elapsed % 3600) / 60);
      const seconds = elapsed % 60;
      
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
    
    // Update all trade timers
    function updateTimers() {
      trades.forEach(trade => {
        const timerElement = document.getElementById(`timer-${trade.id}`);
        if (timerElement && trade.trackedAt) {
          timerElement.textContent = formatElapsedTime(trade.trackedAt);
        }
      });
    }
    
    // Start timer updates (every second)
    function startTimerUpdates() {
      setInterval(() => {
        updateTimers();
      }, 1000);
    }
    
    // Start price updates
    async function startPriceUpdates() {
      // Monitor PENDING trades (every 30 seconds) - optimized to fetch each unique symbol only once
      setInterval(async () => {
        const pendingTrades = trades.filter(t => t.status === 'PENDING');
        if (pendingTrades.length === 0) return;
        
        // Get unique symbols to avoid duplicate API calls
        const uniqueSymbols = [...new Set(pendingTrades.map(t => t.symbol))];
        console.log(`üîÑ Checking ${pendingTrades.length} pending trades (${uniqueSymbols.length} unique symbols)`);
        
        // Fetch prices for each unique symbol once
        for (const symbol of uniqueSymbols) {
          const currentPrice = await fetchPrice(symbol);
          if (currentPrice > 0) {
            priceCache[symbol] = currentPrice;
            // Check all trades for this symbol
            pendingTrades.filter(t => t.symbol === symbol).forEach(trade => {
              checkTradeStatus(trade, currentPrice);
            });
          }
        }
        
        // Re-render if any pending trades changed status
        renderTrades();
      }, 30000); // Check PENDING trades every 30 seconds (reduced from 10s to save API calls)
      
      // Monitor ACTIVE trades (every 60 seconds) - optimized to fetch each unique symbol only once
      setInterval(async () => {
        const activeTrades = trades.filter(t => t.status === 'ACTIVE');
        if (activeTrades.length === 0) return;
        
        // Get unique symbols to avoid duplicate API calls
        const uniqueSymbols = [...new Set(activeTrades.map(t => t.symbol))];
        console.log(`üîÑ Checking ${activeTrades.length} active trades (${uniqueSymbols.length} unique symbols)`);
        
        // Fetch prices for each unique symbol once
        for (const symbol of uniqueSymbols) {
          const currentPrice = await fetchPrice(symbol);
          if (currentPrice > 0) {
            priceCache[symbol] = currentPrice;
            // Check all trades for this symbol
            activeTrades.filter(t => t.symbol === symbol).forEach(trade => {
              checkTradeStatus(trade, currentPrice);
            });
          }
        }
        
        renderTrades();
      }, 60000); // Check ACTIVE trades every 60 seconds (reduced from 30s to save API calls)
    }
    
    // Check if trade hit stop or target, or if pending trade hit entry
    function checkTradeStatus(trade, currentPrice) {
      // PENDING: Waiting for entry zone to be hit
      if (trade.status === 'PENDING') {
        if (!trade.entryZone || !currentPrice) return;
        
        const { min, max } = trade.entryZone;
        const inEntryZone = currentPrice >= min && currentPrice <= max;
        
        if (inEntryZone) {
          console.log(`üéØ ${trade.symbol} hit entry zone! Activating trade...`);
          trade.status = 'ACTIVE';
          trade.actualEntry = currentPrice;
          trade.activationTime = new Date().toISOString();
          saveTrades();
          return;
        }
        
        // Check if price invalidated before entry (went past stop loss)
        if (trade.direction === 'LONG' && currentPrice <= trade.stopLoss) {
          console.log(`‚ùå ${trade.symbol} invalidated before entry (below stop)`);
          trade.status = 'INVALIDATED';
          trade.exitPrice = currentPrice;
          trade.exitTime = new Date().toISOString();
          trade.outcome = 'MISSED';
          saveTrades();
          return;
        }
        
        if (trade.direction === 'SHORT' && currentPrice >= trade.stopLoss) {
          console.log(`‚ùå ${trade.symbol} invalidated before entry (above stop)`);
          trade.status = 'INVALIDATED';
          trade.exitPrice = currentPrice;
          trade.exitTime = new Date().toISOString();
          trade.outcome = 'MISSED';
          saveTrades();
          return;
        }
        
        return; // Still pending, no action needed
      }
      
      // ACTIVE: Monitor for stop loss or targets
      if (trade.status !== 'ACTIVE') return;
      
      if (trade.direction === 'LONG') {
        // Check stop loss
        if (currentPrice <= trade.stopLoss) {
          trade.status = 'CLOSED';
          trade.outcome = 'LOSS';
          trade.exitPrice = trade.stopLoss;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
        // Check targets
        if (trade.target2 && currentPrice >= trade.target2) {
          trade.status = 'CLOSED';
          trade.outcome = 'WIN';
          trade.exitPrice = trade.target2;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
        if (currentPrice >= trade.target1) {
          trade.status = 'CLOSED';
          trade.outcome = 'WIN';
          trade.exitPrice = trade.target1;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
      } else {
        // SHORT
        if (currentPrice >= trade.stopLoss) {
          trade.status = 'CLOSED';
          trade.outcome = 'LOSS';
          trade.exitPrice = trade.stopLoss;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
        if (trade.target2 && currentPrice <= trade.target2) {
          trade.status = 'CLOSED';
          trade.outcome = 'WIN';
          trade.exitPrice = trade.target2;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
        if (currentPrice <= trade.target1) {
          trade.status = 'CLOSED';
          trade.outcome = 'WIN';
          trade.exitPrice = trade.target1;
          trade.exitTime = new Date().toISOString();
          saveTrades();
          return;
        }
      }
    }
    
    // AI market analysis storage
    let marketAnalysis = {};
    
    // Fetch and analyze market data for a trade
    async function analyzeMarketForTrade(trade, currentPrice) {
      try {
        const response = await fetch(`/api/analyze/${trade.symbol}?intervals=4h,1h,15m`);
        const data = await response.json();
        
        // Extract key market indicators
        const signal = data.signal || data.tradeSignal || {};
        const momentum = signal.momentum || 'NEUTRAL';
        const trend = signal.bias || signal.direction || 'NEUTRAL';
        const confidence = signal.confidence || 0;
        
        marketAnalysis[trade.id] = {
          momentum,
          trend,
          confidence,
          timestamp: Date.now()
        };
        
        console.log(`üìä Market analysis for ${trade.symbol}:`, marketAnalysis[trade.id]);
      } catch (error) {
        console.log(`‚ö†Ô∏è Could not fetch market data for ${trade.symbol}:`, error);
        marketAnalysis[trade.id] = { momentum: 'NEUTRAL', trend: 'NEUTRAL', confidence: 0 };
      }
    }
    
    // Generate AI feedback with market context
    function generateFeedback(trade, currentPrice) {
      // If no current price, use entry price (no P&L yet)
      if (!currentPrice || currentPrice === 0) {
        currentPrice = trade.entry;
      }
      
      const risk = Math.abs(trade.entry - trade.stopLoss);
      const pnl = trade.direction === 'LONG' ? 
        (currentPrice - trade.entry) :
        (trade.entry - currentPrice);
      const pnlPercent = (pnl / trade.entry) * 100;
      const rMultiple = pnl / risk;
      
      console.log(`üìä P&L Calc for ${trade.symbol}:`, {
        currentPrice,
        entry: trade.entry,
        direction: trade.direction,
        pnl,
        pnlPercent: pnlPercent.toFixed(2) + '%',
        rMultiple: rMultiple.toFixed(2) + 'R'
      });
      
      // Get market analysis
      const market = marketAnalysis[trade.id] || { momentum: 'NEUTRAL', trend: 'NEUTRAL', confidence: 0 };
      
      let feedbackText = '';
      let signal = ''; // 5-word max summary
      
      // PENDING: Waiting for entry zone
      if (trade.status === 'PENDING') {
        const entryZone = trade.entryZone || {};
        const distanceToEntryMin = trade.direction === 'LONG' ? 
          ((entryZone.min - currentPrice) / currentPrice * 100) :
          ((currentPrice - entryZone.max) / currentPrice * 100);
        
        const inZone = currentPrice >= entryZone.min && currentPrice <= entryZone.max;
        
        if (inZone) {
          signal = 'Price reached zone - entry triggering';
          feedbackText = `<strong>Entry zone hit</strong><br><br>
            <strong>What's happening:</strong> Price just entered your zone at $${currentPrice.toLocaleString()} (entry: $${entryZone.min.toLocaleString()} - $${entryZone.max.toLocaleString()}). This is what you were waiting for. Trade activating.<br><br>
            <strong>Next move:</strong> Watch closely. Targets are TP1: $${trade.target1.toLocaleString()}, TP2: $${trade.target2.toLocaleString()}. Stop: $${trade.stopLoss.toLocaleString()}. If price holds here, you're in. If it fakes and reverses, be ready.`;
        } else if (distanceToEntryMin > 0) {
          signal = 'Waiting for price to pull back into zone';
          feedbackText = `<strong>Setup waiting for entry</strong><br><br>
            <strong>Where we are:</strong> Current price is $${currentPrice.toLocaleString()}. Your entry zone is $${entryZone.min.toLocaleString()} - $${entryZone.max.toLocaleString()} (${Math.abs(distanceToEntryMin).toFixed(2)}% away). ${trade.direction === 'LONG' ? 'Waiting for pullback to buy zone.' : 'Waiting for bounce to short zone.'}<br><br>
            <strong>Market's behavior:</strong> ${market.trend} with ${market.momentum} momentum. ${trade.direction === 'LONG' ? 'If it retraces cleanly, you get your entry. If it keeps running, you miss it - that\'s discipline.' : 'If it rallies into your zone, you get the short. If it keeps dumping without you, let it go.'}<br><br>
            <strong>What to do:</strong> Be patient. Set alerts at entry. Don't chase. If price hits $${trade.stopLoss.toLocaleString()} before entering, setup's dead.`;
        } else {
          signal = 'Price ran without you - do not chase';
          feedbackText = `<strong>Entry missed</strong><br><br>
            <strong>What happened:</strong> ${trade.direction === 'LONG' ? 'Price pumped past your buy zone' : 'Price dumped past your short zone'} without giving you an entry. Current: $${currentPrice.toLocaleString()}. Entry was: $${entryZone.min.toLocaleString()} - $${entryZone.max.toLocaleString()}.<br><br>
            <strong>Market's telling you:</strong> ${market.trend} trend, ${market.momentum} momentum. The move happened, and you weren't in it. That's fine. Chasing now is how you turn a missed trade into a losing one.<br><br>
            <strong>What to do:</strong> Delete this pending trade. Wait for a pullback or the next clean setup. Discipline beats FOMO every time.`;
        }
      } else if (trade.status === 'INVALIDATED') {
        signal = 'Setup failed before entry - capital saved';
        feedbackText = `<strong>Trade invalidated pre-entry</strong><br><br>
          <strong>What happened:</strong> Price hit $${trade.stopLoss.toLocaleString()} before you even got in. Setup died before activation. This is exactly why we don't chase or enter early.<br><br>
          <strong>Why this is good:</strong> You saved capital by waiting for proper entry. No loss taken. This is what discipline looks like. Delete this trade and move on to the next setup.`;
      } else if (trade.status === 'CLOSED') {
        const outcome = trade.outcome === 'WIN' ? 'Closed in profit' : 'Stopped out';
        signal = trade.outcome === 'WIN' ? 'Winner - plan executed correctly' : 'Loser - setup invalidated, risk managed';
        feedbackText = `<strong>${outcome}: ${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
          ${trade.outcome === 'WIN' ? 
            '<strong>What worked:</strong> You trusted your plan, let the trade develop, and took profit at targets. This is textbook execution. Review what confluence confirmed this setup so you can spot it again.<br><br><strong>Next:</strong> Don\'t get cocky. Every trade is independent. Stay disciplined.' : 
            '<strong>What happened:</strong> Market invalidated your thesis. You took the stop like you were supposed to. This is good trading - you followed your risk management plan.<br><br><strong>Next:</strong> Review what failed (structure? timing? momentum?). Learn from it. Move on with a clear head. Losing trades are part of the game.'}`;
      } else {
        // Check if market aligns with position
        const marketAligned = (trade.direction === 'LONG' && market.trend === 'BULLISH') ||
                             (trade.direction === 'SHORT' && market.trend === 'BEARISH');
        
        // Calculate R-multiples for targets
        const risk = Math.abs(trade.entry - trade.stopLoss);
        const rr1 = trade.target1 ? Math.abs((trade.target1 - trade.entry) / risk) : 0;
        const rr2 = trade.target2 ? Math.abs((trade.target2 - trade.entry) / risk) : 0;
        
        // Distance to targets
        const distanceToTP1 = Math.abs(currentPrice - trade.target1);
        const distanceToStop = Math.abs(currentPrice - trade.stopLoss);
        const distanceToEntry = Math.abs(currentPrice - trade.entry);
        
        // Active trade analysis with market-behavior focused language
        if (rMultiple >= 1.5) {
          signal = `Market gave you the move - lock it in before it takes it back`;
          feedbackText = `<strong>Strong profit at +${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Price delivered exactly what you wanted, and while the broader trend still supports your direction, this much profit rarely lasts. Markets don\'t hand out free money - they give, then take back.' : 'You\'re sitting on gains while the market is starting to shift gears. Momentum is fading, and what got you here won\'t keep you here.'}<br><br>
            <strong>Why this matters:</strong> You've banked 1.5R+. The easy part is over. From here, every tick you hold increases the odds of giving profits back. ${marketAligned ? 'Even in strong trends, price needs to breathe - and when it does, unrealized gains evaporate fast.' : 'The market\'s already showing you it wants to reverse. Don\'t be the last one holding the bag.'}<br><br>
            <strong>What to do:</strong><br>
            ‚Ä¢ Scale out 50-75% now - a bird in the hand beats two reversals<br>
            ‚Ä¢ Move stops to breakeven on remaining position<br>
            ‚Ä¢ If you stay greedy here, you'll regret it when this flips<br>
            ‚Ä¢ Profit-taking is never wrong; holding through reversals is`;
        } else if (rMultiple >= 0.8) {
          signal = marketAligned ? `Trend confirming - let it run to next target` : `Market's tired - take the W while it's there`;
          feedbackText = `<strong>Solid profit at +${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Price is behaving exactly as you\'d expect in a clean '+trade.direction.toLowerCase()+' setup. Structure is holding, momentum is aligned, and your thesis is playing out. This is what confirmation looks like - don\'t second-guess it.' : 'You\'re profitable, but the market isn\'t backing you up. Price is struggling to push further in your direction, which means the easy money is already made. What comes next is chop or reversal.'}<br><br>
            <strong>Why this matters:</strong> You're near TP1 (${rr1.toFixed(1)}R). ${marketAligned ? 'The trend is still intact, so there\'s room to run if you manage it right. But don\'t get complacent - even good setups can stall or retrace.' : 'You got lucky with timing, but the bigger picture isn\'t supporting more upside. The market\'s telling you to exit - listen to it.'}<br><br>
            <strong>What to do:</strong><br>
            ${marketAligned ? 
              '‚Ä¢ Take 25-50% off here to lock gains<br>‚Ä¢ Move stop to breakeven - protect your capital<br>‚Ä¢ Let the rest ride to TP2 ('+rr2.toFixed(1)+'R) with alerts set<br>‚Ä¢ Trust the process, but don\'t be stubborn if momentum shifts' : 
              '‚Ä¢ Take 50-75% profit now before this flips<br>‚Ä¢ Tighten stops aggressively - market\'s not your friend here<br>‚Ä¢ Don\'t hold hoping for a miracle - take the win<br>‚Ä¢ You entered at the right time, now exit before it\'s too late'}<br><br>
            <strong>Levels that matter:</strong> $${distanceToStop.toFixed(2)} to stop, $${distanceToTP1.toFixed(2)} to TP1`;
        } else if (rMultiple >= 0.3) {
          signal = marketAligned ? `Setup clean, price developing - hold tight` : `Market hesitating - be ready to bail`;
          feedbackText = `<strong>Trade in profit at +${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Price is moving in your direction, but it\'s not explosive yet. This is normal - markets don\'t go straight up or down. The broader trend supports you, momentum is aligned, and your entry looks smart. Let it cook.' : 'You\'re green, but barely. Price isn\'t committing to your direction, which means either this setup is about to fail or you\'re way too early. The market isn\'t confirming your thesis - it\'s just chopping around.'}<br><br>
            <strong>Why this matters:</strong> ${marketAligned ? 'Your targets are TP1: $'+trade.target1.toLocaleString()+' ('+rr1.toFixed(1)+'R) and TP2: $'+trade.target2.toLocaleString()+' ('+rr2.toFixed(1)+'R). You\'re not there yet, but the path is clear. Don\'t exit early just because it feels slow - that\'s how you miss the best part of the move.' : 'While you\'re technically profitable, the market\'s behavior says this could reverse at any moment. You entered hoping for follow-through, but price is giving you doubt instead.'}<br><br>
            <strong>What to do:</strong><br>
            ${marketAligned ?
              '‚Ä¢ Let it run - don\'t kill a good trade with weak hands<br>‚Ä¢ Keep stop at $'+trade.stopLoss.toLocaleString()+' until TP1 hits<br>‚Ä¢ Stop checking every 5 minutes; your plan is solid<br>‚Ä¢ If it stops out, it stops out - that\'s the game' :
              '‚Ä¢ Watch this closely - set alerts on key levels<br>‚Ä¢ If momentum dies or structure breaks, cut it<br>‚Ä¢ Don\'t hold stubbornly waiting for a miracle<br>‚Ä¢ Better to exit small green than big red'}<br><br>
            <strong>Distance to TP1:</strong> $${distanceToTP1.toFixed(2)} away. Entry was $${distanceToEntry.toFixed(2)} back.`;
        } else if (rMultiple > -0.2) {
          signal = marketAligned ? `Healthy pullback - stop exists for a reason` : `Setup's not working - stop may be mercy`;
          feedbackText = `<strong>Price hovering near entry at ${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Price is retesting your entry, which is completely normal in trending markets. The broader trend still supports you, but it needs to shake out weak hands before the real move. This is why you set your stop where you did - let it do its job.' : 'Market\'s not buying your thesis. You entered expecting a move, and instead you got chop. Price is struggling to go anywhere, which means this setup is either dead or about to invalidate.'}<br><br>
            <strong>Why this matters:</strong> ${marketAligned ? 'You\'re essentially flat. In strong trends, pullbacks are healthy - but they feel terrible. Don\'t panic exit just because you\'re not up big yet. Your stop is at $'+trade.stopLoss.toLocaleString()+' for a reason. If it hits, the trade was wrong. If it doesn\'t, you\'re still in.' : 'You thought you had a setup, but the market disagrees. Structure isn\'t holding, and price is telling you this entry was premature or flat-out wrong. If you have a discretionary exit rule, now\'s the time.'}<br><br>
            <strong>What to do:</strong><br>
            ${marketAligned ?
              '‚Ä¢ Do NOT panic exit - this is normal<br>‚Ä¢ Trust your stop at $'+trade.stopLoss.toLocaleString()+'<br>‚Ä¢ If it stops out, the setup failed (correct outcome)<br>‚Ä¢ Don\'t move stops trying to "survive" - that\'s how accounts die' :
              '‚Ä¢ Watch this like a hawk - it could roll over any second<br>‚Ä¢ If you see structure break or momentum shift, bail<br>‚Ä¢ Prepare mentally to take a small loss<br>‚Ä¢ Better to cut now than bleed later'}<br><br>
            <strong>Critical:</strong> Stop at $${trade.stopLoss.toLocaleString()} ($${distanceToStop.toFixed(2)} away)`;
        } else if (rMultiple > -0.5) {
          signal = `Market's rejecting your entry - stop's coming`;
          feedbackText = `<strong>Trade underwater at ${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Even though the broader trend technically aligns with you, THIS specific entry isn\'t working. Timing matters in trading, and yours was off. It happens. The market can trend in your favor while your position still bleeds.' : 'Market\'s moving against you, plain and simple. Your '+trade.direction.toLowerCase()+' thesis is failing. Structure broke, momentum flipped, and now you\'re holding a loser. The confluence you relied on didn\'t hold.'}<br><br>
            <strong>Why this matters:</strong> You're in drawdown and approaching your stop at $${trade.stopLoss.toLocaleString()}. ${marketAligned ? 'Sometimes good setups in strong trends still fail due to liquidity sweeps or bad timing. Don\'t take it personally - just don\'t fight it either.' : 'The market invalidated your setup. Accept it. Every trader takes losses - the good ones take them when they\'re small.'}<br><br>
            <strong>What to do:</strong><br>
            ‚Ä¢ Prepare to take this loss - it's happening<br>
            ‚Ä¢ Do NOT move your stop (that's emotional trading)<br>
            ‚Ä¢ Stop is $${distanceToStop.toFixed(2)} away - let it hit or cut now<br>
            ‚Ä¢ After exit, review: bad entry? Bad timing? Wrong read?<br>
            ‚Ä¢ This is the game - not every setup works<br><br>
            <strong>Max damage:</strong> Stop limits loss to ${Math.abs((trade.stopLoss - trade.entry) / trade.entry * 100).toFixed(2)}%`;
        } else if (rMultiple > -0.8) {
          signal = `Stop's about to hit - accept it and move on`;
          feedbackText = `<strong>Major drawdown at ${rMultiple.toFixed(2)}R (${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Even with the trend on your side overall, THIS trade is toast. You can be right about direction and still wrong about entry. The market doesn\'t care about your thesis - it cares about liquidity and momentum, and both are against you now.' : 'You\'re fighting the tape and losing. Market\'s clearly moving against your '+trade.direction.toLowerCase()+' position. Your thesis was wrong, or the market shifted after you entered. Either way, you\'re on the wrong side.'}<br><br>
            <strong>Why this matters:</strong> ${trade.stopLoss ? 'Your stop at $'+trade.stopLoss.toLocaleString()+' is about to be hit. This isn\'t negotiable. The setup completely failed. You can exit now to save a few cents of slippage, or let the stop do its job. Either way, this trade is over.' : '‚ö†Ô∏è You have NO STOP SET. You\'re in freefall with no safety net. This is how accounts blow up.'}<br><br>
            <strong>What to do NOW:</strong><br>
            ${trade.stopLoss ? 
              '‚Ä¢ Accept the loss - it\'s already baked in<br>‚Ä¢ Do NOT move your stop hoping for a bounce<br>‚Ä¢ Exit now or let stop hit in seconds<br>‚Ä¢ After this, review what went wrong (later, not now)<br>‚Ä¢ Every loss is education - but only if you learn' :
              '‚Ä¢ EXIT IMMEDIATELY - no stop = unlimited risk<br>‚Ä¢ You\'re bleeding capital with no plan<br>‚Ä¢ Close this NOW before it gets worse<br>‚Ä¢ Set a stop on your next trade - non-negotiable'}<br><br>
            <strong>Damage:</strong> Down ${Math.abs(pnlPercent).toFixed(2)}%. ${trade.stopLoss ? 'Stop limits to '+Math.abs((trade.stopLoss - trade.entry) / trade.entry * 100).toFixed(2)+'%' : 'NO STOP = spiraling'}`;
        } else {
          signal = `Dead trade - close it now or watch it burn`;
          feedbackText = `<strong>Critical loss at ${rMultiple.toFixed(2)}R (${pnlPercent.toFixed(2)}%)</strong><br><br>
            <strong>What the market is doing:</strong> ${marketAligned ? 'Doesn\'t matter if the trend "agrees" with you - THIS entry is catastrophically wrong. You can\'t hold through this kind of drawdown hoping for a miracle bounce. The market is ruthless, and right now it\'s eating you alive.' : 'Market completely invalidated your setup. You\'re fighting the tape, and the tape always wins. Your '+trade.direction.toLowerCase()+' position is fundamentally wrong, and every second you hold makes it worse.'}<br><br>
            <strong>Why this matters:</strong> ${trade.stopLoss ? 'Your stop should have been hit already. If it didn\'t trigger, close manually NOW. This trade is dead - accept it and preserve what capital you have left.' : 'üí• You have NO STOP LOSS. This is catastrophic. Every second you wait, losses compound. This is how traders blow up accounts.'}<br><br>
            <strong>EMERGENCY - DO NOW:</strong><br>
            ${trade.stopLoss ?
              '‚Ä¢ CLOSE THIS IMMEDIATELY<br>‚Ä¢ Stop should have hit - don\'t wait, manual exit<br>‚Ä¢ Do not average down or "wait for bounce"<br>‚Ä¢ Loss is real - take it and move on<br>‚Ä¢ Capital preservation > being "right"' :
              '‚Ä¢ üö® EXIT NOW - NO EXCEPTIONS üö®<br>‚Ä¢ NO STOP = you\'re risking total account ruin<br>‚Ä¢ Close this trade RIGHT NOW<br>‚Ä¢ Never trade without a stop again<br>‚Ä¢ This is a career-ending mistake if you don\'t exit'}<br><br>
            <strong>Damage:</strong> Down ${Math.abs(pnlPercent).toFixed(2)}%. ${trade.stopLoss ? 'Planned max was '+Math.abs((trade.stopLoss - trade.entry) / trade.entry * 100).toFixed(2)+'%' : 'NO STOP = freefall'}<br><br>
            <strong>After exit:</strong> Step away. Breathe. Review what happened. Come back with a clear head.`;
        }
      }
      
      return { feedbackText, rMultiple, pnlPercent, signal };
    }
    
    // Create trade row (matching homepage coin row structure)
    function createTradeRow(trade) {
      const currentPrice = priceCache[trade.symbol] || 0;
      const { feedbackText, rMultiple, pnlPercent, signal } = generateFeedback(trade, currentPrice);
      
      // Coin names
      const coinNames = {
        'BTCUSDT': 'BITCOIN',
        'ETHUSDT': 'ETHEREUM',
        'SOLUSDT': 'SOLANA'
      };
      const coinName = coinNames[trade.symbol] || trade.symbol.replace('USDT', '');
      
      // Coin name always yellow-white
      const coinNameColor = 'var(--color-yellow-75)';
      
      // Coin row
      const row = document.createElement('tr');
      row.id = `trade-row-${trade.id}`;
      
      // Check if we have valid price data
      const hasValidPrice = currentPrice > 0 && currentPrice !== trade.entry;
      
      // Row background: green if profit, red if loss, orange if pending, neutral if closed/loading
      let rowBgClass = '';
      if (trade.status === 'ACTIVE' && hasValidPrice) {
        rowBgClass = pnlPercent >= 0 ? 'has-trade-long' : 'has-trade-short';
      } else if (trade.status === 'PENDING') {
        rowBgClass = 'has-trade-pending'; // Orange background for pending trades
      }
      row.className = `coin-row ${rowBgClass}`;
      
      // P&L text color: green if profit, red if loss, yellow-white if loading/pending
      const pnlColor = (trade.status === 'ACTIVE' && hasValidPrice) ? 
        (pnlPercent >= 0 ? '#22c55e' : '#ef4444') : 
        'var(--color-yellow-75)';
      
      // All text in yellow-white
      const signalColor = 'var(--color-yellow-75)';
      
      // Calculate elapsed time for this trade
      const elapsedTime = formatElapsedTime(trade.trackedAt);
      
      row.innerHTML = `
        <td class="px-2 coin-name-cell" style="padding-top: 1.65rem; padding-bottom: 1.65rem; width: 150px; min-width: 150px; max-width: 150px;">
          <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
            <div style="font-family: var(--font-mathias); font-weight: bold; font-size: 0.9rem; color: ${coinNameColor}; text-align: center;">
              ${coinName}
            </div>
          </div>
        </td>
        
        <td class="px-2" data-label="P&L:" style="padding-top: 1.65rem; padding-bottom: 1.65rem; width: 100px; min-width: 100px; max-width: 100px; white-space: nowrap; padding-left: 1rem;">
          <div style="font-family: var(--font-mathias); font-weight: bold; color: ${pnlColor}; font-size: 0.85rem; text-align: left;">
            ${trade.status === 'PENDING' ? 'PENDING' : (hasValidPrice ? `${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%` : '--')}
          </div>
        </td>
        
        <td class="px-2" data-label="Status:" style="padding-top: 1.65rem; padding-bottom: 1.65rem; padding-left: 1rem; min-width: 250px;">
          <div style="font-family: var(--font-mathias); font-weight: bold; font-size: 0.75rem; color: ${signalColor}; text-align: left; line-height: 1.3;">
            ${trade.status === 'PENDING' || trade.status === 'INVALIDATED' ? signal : (hasValidPrice ? signal : '--')}
          </div>
        </td>
        
        <td class="px-2 time-cell" data-label="Time:" style="padding-top: 1.65rem; padding-bottom: 1.65rem; width: 90px; min-width: 90px; max-width: 90px; padding-left: 1rem;">
          <div id="timer-${trade.id}" style="font-family: var(--font-mathias); font-weight: bold; font-size: 0.75rem; color: var(--color-yellow-75); text-align: left;">
            ${elapsedTime}
          </div>
        </td>
        
        <td class="px-2 details-button-cell" data-label="Details:" style="padding-top: 1.65rem; padding-bottom: 1.65rem; width: 120px; min-width: 120px; max-width: 120px; white-space: nowrap;">
          <button 
            onclick="toggleTradeDetails(${trade.id})"
            class="px-3 py-1 text-xs font-mathias font-bold"
            style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s; min-width: 80px; padding: 0.5rem 1rem;"
          >
            DETAILS
          </button>
        </td>
      `;
      
      return row;
    }
    
    // Create details row (matching homepage details structure)
    function createTradeDetailsRow(trade) {
      const currentPrice = priceCache[trade.symbol] || 0;
      const { feedbackText, rMultiple, pnlPercent, signal } = generateFeedback(trade, currentPrice);
      const risk = Math.abs(trade.entry - trade.stopLoss);
      
      const detailsRow = document.createElement('tr');
      detailsRow.id = `trade-details-${trade.id}`;
      detailsRow.className = 'details-row';
      
      const directionColor = trade.direction === 'LONG' ? '#22c55e' : '#ef4444';
      const directionIcon = trade.direction === 'LONG' ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
      const setupType = trade.strategy.toUpperCase();
      
      // Get market analysis context
      const market = marketAnalysis[trade.id] || { momentum: 'NEUTRAL', trend: 'NEUTRAL', confidence: 0 };
      const marketAligned = (trade.direction === 'LONG' && market.trend === 'BULLISH') ||
                           (trade.direction === 'SHORT' && market.trend === 'BEARISH');
      
      // Calculate R-multiples for targets
      const rr1 = trade.target1 ? Math.abs((trade.target1 - trade.entry) / risk) : 0;
      const rr2 = trade.target2 ? Math.abs((trade.target2 - trade.entry) / risk) : 0;
      
      
      detailsRow.innerHTML = `
        <td colspan="5" style="width: 100%; padding: 1rem;">
          <div class="details-content-wrapper" style="width: 100%;">
            <!-- Trade Call Output (matching homepage) -->
            <div style="margin-bottom: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.6); border-radius: var(--radius-md); font-family: var(--font-system); backdrop-filter: blur(10px);">
              
              <!-- Header -->
              <div style="margin-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 1rem;">
                <h2 style="font-size: clamp(1.25rem, 4vw, 1.75rem); font-weight: bold; color: var(--color-yellow-75); margin-bottom: 0.75rem; letter-spacing: 0.05em; text-transform: uppercase; font-family: var(--font-mathias);">
                  ${trade.symbol.replace('USDT', '')} - ${trade.direction} (${setupType})
                </h2>
                
                ${trade.status === 'PENDING' ? `
                <div style="background-color: rgba(255, 193, 7, 0.15); border: 1px solid #ffc107; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem;">
                  <p style="color: #ffc107; font-size: 0.875rem; margin: 0;">‚è≥ PENDING ENTRY - Waiting for price to reach entry zone: $${trade.entryZone?.min?.toLocaleString() || 'N/A'} - $${trade.entryZone?.max?.toLocaleString() || 'N/A'}</p>
                </div>
                ` : ''}
                
                <!-- Key Metrics Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-top: 1rem;">
                  <div>
                    <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Current Price</div>
                    <div style="color: ${directionColor}; font-size: 1.5rem; font-weight: bold;">$${currentPrice.toLocaleString()}</div>
                  </div>
                  <div>
                    <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">${trade.status === 'PENDING' ? 'Status' : 'P&L'}</div>
                    <div style="color: ${trade.status === 'PENDING' ? '#ffc107' : (rMultiple >= 0 ? '#22c55e' : '#ef4444')}; font-size: 1.25rem; font-weight: bold;">${trade.status === 'PENDING' ? 'WAITING' : `${rMultiple.toFixed(2)}R (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)`}</div>
                  </div>
                  <div>
                    <div style="color: var(--color-yellow-75); font-size: 0.75rem; margin-bottom: 0.25rem; text-transform: uppercase; letter-spacing: 0.05em; font-family: var(--font-mathias);">Direction</div>
                    <div style="color: ${directionColor}; font-size: 1.25rem; font-weight: bold;">${directionIcon} ${trade.direction}</div>
                  </div>
                </div>
              </div>
              
              <!-- Editorial Grid Layout -->
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                <!-- Left Column: Entry & Risk -->
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                  <div>
                    <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">${trade.status === 'PENDING' ? 'Entry Zone' : 'Entry'}</div>
                    <div style="color: var(--color-yellow-75); font-size: 1.125rem; font-weight: bold; line-height: 1.2;">
                      ${trade.status === 'PENDING' && trade.entryZone ? 
                        `$${trade.entryZone.min.toLocaleString()} - $${trade.entryZone.max.toLocaleString()}` : 
                        `$${trade.entry.toLocaleString()}`}
                    </div>
                  </div>
                  
                  <div>
                    <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Stop Loss</div>
                    <div style="color: ${trade.direction === 'LONG' ? '#ef4444' : '#22c55e'}; font-size: 1.125rem; font-weight: bold;">${trade.stopLoss ? `$${trade.stopLoss.toLocaleString()}` : 'Not set'}</div>
                  </div>
                  
                  <div>
                    <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Risk / Reward</div>
                    <div style="color: #22c55e; font-size: 1rem; font-weight: bold; line-height: 1.4;">
                      ${rr1 > 0 ? `${rr1.toFixed(1)}R` : 'N/A'} ${rr2 > 0 ? `to ${rr2.toFixed(1)}R` : ''}
                    </div>
                  </div>
                </div>
                
                <!-- Right Column: Targets & Invalidation -->
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                  <div>
                    <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Targets</div>
                    <div style="color: var(--color-yellow-75); font-size: 0.875rem; font-weight: bold; line-height: 1.6;">
                      ${trade.target1 ? `<div>TP1 (${rr1.toFixed(1)}R): $${trade.target1.toLocaleString()}</div>` : '<div>TP1: Not set</div>'}
                      ${trade.target2 ? `<div style="margin-top: 0.25rem;">TP2 (${rr2.toFixed(1)}R): $${trade.target2.toLocaleString()}</div>` : ''}
                    </div>
                  </div>
                  
                  <div>
                    <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Invalidation</div>
                    <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.5;">
                      <div style="margin-bottom: 0.5rem;">
                        ${trade.signalSnapshot?.signal?.invalidation?.description || 
                          (setupType === 'SWING' ? 'HTF invalidation indicates macro trend shifted.' : 
                          setupType === 'SCALP' ? 'LTF invalidation means scalp failed.' : 
                          setupType === 'MICROSCALP' ? 'Exit immediately if wrong - high risk countertrend.' :
                          'Structure break invalidates setup.')}
                      </div>
                      <div><strong>Level:</strong> ${(trade.invalidationLevel || trade.stopLoss) ? `$${(trade.invalidationLevel || trade.stopLoss).toLocaleString()}` : 'Not set'} (${trade.direction === 'LONG' ? 'close below' : 'close above'})</div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Full Width: AI Trade Management -->
              <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">AI Trade Management Analysis</div>
                <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8;">
                  ${trade.aiAnalysis ? trade.aiAnalysis : feedbackText}
                </div>
              </div>
              
              <!-- Full Width: Market Context -->
              <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Market Context</div>
                <div style="color: var(--color-yellow-75); font-size: 0.875rem; line-height: 1.8;">
                  <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                    <div><span style="color: rgba(255, 255, 255, 0.5);">‚Äì</span> Market alignment: ${market.alignment === 'Aligned' ? '‚úì Aligned' : '‚ö†Ô∏è Against'}</div>
                    <div><span style="color: rgba(255, 255, 255, 0.5);">‚Äì</span> Market trend: ${market.trend || 'NEUTRAL'}</div>
                    <div><span style="color: rgba(255, 255, 255, 0.5);">‚Äì</span> Momentum: ${market.momentum || 'NEUTRAL'}</div>
                    <div><span style="color: rgba(255, 255, 255, 0.5);">‚Äì</span> Confidence: ${market.confidence || 0}%</div>
                  </div>
                </div>
              </div>
              
              ${trade.journal ? `
              <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Trade Journal</div>
                <div style="color: rgba(255, 255, 255, 0.7); font-size: 0.875rem; line-height: 1.6; white-space: pre-wrap;">
                  ${trade.journal}
                </div>
              </div>
              ` : ''}
              
              ${trade.imageUrl ? `
              <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: var(--color-yellow-75); font-weight: bold; font-size: 0.75rem; margin-bottom: 0.75rem; letter-spacing: 0.1em; text-transform: uppercase; font-family: var(--font-mathias);">Trade Screenshot</div>
                <div style="display: flex; justify-content: center; margin-top: 1rem;">
                  <a href="${trade.imageUrl}" target="_blank" rel="noopener noreferrer">
                    <img src="${trade.imageUrl}" alt="Trade Screenshot" style="max-width: 100%; max-height: 400px; border-radius: 0.5rem; border: 2px solid var(--color-yellow-75);" />
                  </a>
                </div>
              </div>
              ` : ''}
              
              <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: var(--text-secondary); font-family: var(--font-system);">
                <p>Entry Time: ${new Date(trade.entryTime).toLocaleString()}</p>
                ${trade.exitTime ? `<p>Exit Time: ${new Date(trade.exitTime).toLocaleString()}</p>` : ''}
              </div>
            </div>
            
            ${trade.status === 'CLOSED' && trade.exitPrice ? `
            <!-- Trade Review Section -->
            <div style="margin-top: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.4); border-radius: var(--radius-md); border: 1px solid rgba(255, 255, 255, 0.1);">
              <h3 style="font-family: var(--font-mathias); font-size: 1rem; font-weight: bold; color: var(--color-yellow-75); margin-bottom: 1rem; text-transform: uppercase;">
                Trade Review
              </h3>
              ${trade.review && trade.review.performanceSummary ? `
                <div style="font-family: var(--font-system); font-size: 0.875rem; color: var(--text-secondary); line-height: 1.6;">
                  ${trade.review.whatWentRight ? `
                    <div style="margin-bottom: 1rem;">
                      <strong style="color: #22c55e; font-family: var(--font-mathias);">What Went Right:</strong>
                      <p style="margin-top: 0.5rem; margin-bottom: 0;">${trade.review.whatWentRight}</p>
                    </div>
                  ` : ''}
                  ${trade.review.whatWentWrong ? `
                    <div style="margin-bottom: 1rem;">
                      <strong style="color: #ef4444; font-family: var(--font-mathias);">What Went Wrong:</strong>
                      <p style="margin-top: 0.5rem; margin-bottom: 0;">${trade.review.whatWentWrong}</p>
                    </div>
                  ` : ''}
                  ${trade.review.performanceSummary ? `
                    <div style="margin-bottom: 1rem;">
                      <strong style="color: var(--color-yellow-75); font-family: var(--font-mathias);">Performance Summary:</strong>
                      <p style="margin-top: 0.5rem; margin-bottom: 0;">${trade.review.performanceSummary}</p>
                    </div>
                  ` : ''}
                  ${trade.review.lessons && trade.review.lessons.length > 0 ? `
                    <div>
                      <strong style="color: var(--color-yellow-75); font-family: var(--font-mathias);">Lessons:</strong>
                      <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        ${trade.review.lessons.map(lesson => `<li>${lesson}</li>`).join('')}
                      </ul>
                    </div>
                  ` : ''}
                </div>
              ` : `
                <p style="font-family: var(--font-system); font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem;">
                  No review generated yet. Click "Generate Review" to get AI-powered feedback on this trade.
                </p>
                <button 
                  onclick="generateTradeReview(${trade.id})"
                  class="px-3 py-1 text-xs font-mathias font-bold"
                  style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s; padding: 0.5rem 1rem;"
                >
                  GENERATE REVIEW
                </button>
              `}
            </div>
            ` : ''}
            
            ${trade.status !== 'CLOSED' ? `
            <!-- AI Analysis Section for Active/Pending Trades -->
            <div style="margin-top: 1.5rem; padding: 1.5rem; background-color: rgba(0, 0, 0, 0.4); border-radius: var(--radius-md); border: 1px solid rgba(255, 255, 255, 0.1);">
              <h3 style="font-family: var(--font-mathias); font-size: 1rem; font-weight: bold; color: var(--color-yellow-75); margin-bottom: 1rem; text-transform: uppercase;">
                AI Trade Analysis
              </h3>
              <div id="aiAnalysis-${trade.id}" style="font-family: var(--font-system); font-size: 0.875rem; color: var(--text-secondary); line-height: 1.6; min-height: 60px;">
                ${trade.aiAnalysis ? `
                  <p style="margin: 0; white-space: pre-wrap;">${trade.aiAnalysis}</p>
                ` : `
                  <p style="margin: 0; color: var(--text-secondary);">Click "ANALYZE" to get AI-powered feedback on your current position.</p>
                `}
              </div>
              <button 
                onclick="analyzeTrade(${trade.id})"
                id="analyzeBtn-${trade.id}"
                class="px-3 py-1 text-xs font-mathias font-bold"
                style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s; padding: 0.5rem 1rem; margin-top: 1rem;"
              >
                ANALYZE
              </button>
            </div>
            ` : ''}
            
            <div style="text-align: center; padding: 1rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
              <button 
                onclick="toggleTradeDetails(${trade.id})"
                class="px-3 py-1 text-xs font-mathias font-bold"
                style="background-color: var(--color-yellow-75); color: black; border: 2px solid var(--color-yellow-75); border-radius: var(--radius-md); transition: all 0.3s; min-width: 80px; padding: 0.5rem 1rem;"
              >
                HIDE
              </button>
              <button 
                onclick="deleteTrade(${trade.id})"
                class="px-3 py-1 text-xs font-mathias font-bold"
                style="background-color: #ef4444; color: #ffffff; border: 2px solid #ef4444; border-radius: var(--radius-md); transition: all 0.3s; padding: 0.5rem 1rem;"
              >
                DELETE
              </button>
            </div>
          </div>
        </td>
      `;
      
      return detailsRow;
    }
    
    // Track expanded trade details
    let expandedTradeIds = new Set();
    
    // Refresh trades (fetch latest prices and re-analyze)
    window.refreshTrades = async function() {
      console.log('üîÑ Refreshing trades...');
      
      const activeTrades = trades.filter(t => t.status === 'ACTIVE');
      
      if (activeTrades.length === 0) {
        console.log('‚ÑπÔ∏è No active trades to refresh');
        return;
      }
      
      // Show loading state
      const refreshBtn = event.target.closest('button');
      const originalContent = refreshBtn.innerHTML;
      refreshBtn.innerHTML = `
        <svg style="animation: spin 1s linear infinite;" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
        </svg>
        <span>REFRESHING...</span>
      `;
      refreshBtn.disabled = true;
      
      try {
        // Fetch latest prices for all active trades
        for (const trade of activeTrades) {
          const currentPrice = await fetchPrice(trade.symbol);
          if (currentPrice > 0) {
            priceCache[trade.symbol] = currentPrice;
            checkTradeStatus(trade, currentPrice);
            console.log(`‚úÖ Updated ${trade.symbol}: $${currentPrice.toLocaleString()}`);
          }
        }
        
        // Re-render with updated prices
        await renderTrades();
        console.log('‚úÖ Refresh complete');
      } catch (error) {
        console.error('‚ùå Refresh failed:', error);
      } finally {
        // Restore button
        refreshBtn.innerHTML = originalContent;
        refreshBtn.disabled = false;
      }
    };
    
    // Toggle trade details
    window.toggleTradeDetails = function(tradeId) {
      const detailsRow = document.getElementById(`trade-details-${tradeId}`);
      const button = event.target.closest('button');
      const cardContainer = document.querySelector('.card-edittrax');
      const tableContainer = document.querySelector('.table-container');
      
      console.log('üîÑ Toggling details for trade:', tradeId);
      
      if (detailsRow.classList.contains('expanded')) {
        detailsRow.classList.remove('expanded');
        expandedTradeIds.delete(tradeId);
        console.log('  ‚ùå Collapsed');
        if (button) button.textContent = 'DETAILS';
        // Restore overflow
        if (cardContainer) cardContainer.style.overflow = 'hidden';
        if (tableContainer) tableContainer.style.overflowX = 'auto';
      } else {
        detailsRow.classList.add('expanded');
        expandedTradeIds.add(tradeId);
        console.log('  ‚úÖ Expanded');
        if (button) button.textContent = 'HIDE';
        // Allow overflow for full width
        if (cardContainer) cardContainer.style.overflow = 'visible';
        if (tableContainer) tableContainer.style.overflowX = 'visible';
      }
    };
    
    // Calculate trade statistics
    function calculateStats(trades, filters = {}) {
      // Apply filters
      let filteredTrades = [...trades];
      
      if (filters.symbol) {
        filteredTrades = filteredTrades.filter(t => t.symbol === filters.symbol);
      }
      if (filters.strategy) {
        filteredTrades = filteredTrades.filter(t => t.strategy === filters.strategy);
      }
      if (filters.direction) {
        filteredTrades = filteredTrades.filter(t => t.direction === filters.direction);
      }
      
      // Only analyze closed trades
      const closedTrades = filteredTrades.filter(t => t.status === 'CLOSED' && t.exitPrice);
      
      if (closedTrades.length === 0) {
        return {
          totalTrades: filteredTrades.length,
          closedTrades: 0,
          winRate: 0,
          avgR: 0,
          maxWin: 0,
          maxLoss: 0,
          totalPnL: 0,
          byStrategy: {},
          bySymbol: {}
        };
      }
      
      // Calculate overall stats
      let wins = 0;
      let losses = 0;
      let totalR = 0;
      let maxWin = -Infinity;
      let maxLoss = Infinity;
      let totalPnL = 0;
      
      closedTrades.forEach(trade => {
        const risk = Math.abs(trade.entry - trade.stopLoss);
        if (risk === 0) return;
        
        const pnl = trade.direction === 'LONG' ? 
          (trade.exitPrice - trade.entry) :
          (trade.entry - trade.exitPrice);
        const rMultiple = pnl / risk;
        
        totalR += rMultiple;
        totalPnL += pnl;
        
        if (rMultiple > 0) {
          wins++;
          if (rMultiple > maxWin) maxWin = rMultiple;
        } else {
          losses++;
          if (rMultiple < maxLoss) maxLoss = rMultiple;
        }
      });
      
      const winRate = closedTrades.length > 0 ? (wins / closedTrades.length) * 100 : 0;
      const avgR = closedTrades.length > 0 ? totalR / closedTrades.length : 0;
      
      // Calculate by strategy
      const byStrategy = {};
      const strategies = [...new Set(closedTrades.map(t => t.strategy))];
      strategies.forEach(strategy => {
        const strategyTrades = closedTrades.filter(t => t.strategy === strategy);
        let strategyWins = 0;
        let strategyTotalR = 0;
        
        strategyTrades.forEach(trade => {
          const risk = Math.abs(trade.entry - trade.stopLoss);
          if (risk === 0) return;
          
          const pnl = trade.direction === 'LONG' ? 
            (trade.exitPrice - trade.entry) :
            (trade.entry - trade.exitPrice);
          const rMultiple = pnl / risk;
          
          strategyTotalR += rMultiple;
          if (rMultiple > 0) strategyWins++;
        });
        
        byStrategy[strategy] = {
          count: strategyTrades.length,
          winRate: strategyTrades.length > 0 ? (strategyWins / strategyTrades.length) * 100 : 0,
          avgR: strategyTrades.length > 0 ? strategyTotalR / strategyTrades.length : 0
        };
      });
      
      // Calculate by symbol
      const bySymbol = {};
      const symbols = [...new Set(closedTrades.map(t => t.symbol))];
      symbols.forEach(symbol => {
        const symbolTrades = closedTrades.filter(t => t.symbol === symbol);
        let symbolWins = 0;
        let symbolTotalR = 0;
        
        symbolTrades.forEach(trade => {
          const risk = Math.abs(trade.entry - trade.stopLoss);
          if (risk === 0) return;
          
          const pnl = trade.direction === 'LONG' ? 
            (trade.exitPrice - trade.entry) :
            (trade.entry - trade.exitPrice);
          const rMultiple = pnl / risk;
          
          symbolTotalR += rMultiple;
          if (rMultiple > 0) symbolWins++;
        });
        
        bySymbol[symbol] = {
          count: symbolTrades.length,
          winRate: symbolTrades.length > 0 ? (symbolWins / symbolTrades.length) * 100 : 0,
          avgR: symbolTrades.length > 0 ? symbolTotalR / symbolTrades.length : 0
        };
      });
      
      return {
        totalTrades: filteredTrades.length,
        closedTrades: closedTrades.length,
        winRate: winRate,
        avgR: avgR,
        maxWin: maxWin === -Infinity ? 0 : maxWin,
        maxLoss: maxLoss === Infinity ? 0 : maxLoss,
        totalPnL: totalPnL,
        byStrategy: byStrategy,
        bySymbol: bySymbol
      };
    }
    
    // Update stats display
    function updateStatsDisplay() {
      const stats = calculateStats(trades);
      const statsDisplay = document.getElementById('statsDisplay');
      
      if (!statsDisplay) return;
      
      let html = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Total Trades</div>
            <div style="color: var(--text-primary); font-size: 1.5rem; font-weight: bold;">${stats.totalTrades}</div>
          </div>
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Closed Trades</div>
            <div style="color: var(--text-primary); font-size: 1.5rem; font-weight: bold;">${stats.closedTrades}</div>
          </div>
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Win Rate</div>
            <div style="color: ${stats.winRate >= 50 ? '#22c55e' : '#ef4444'}; font-size: 1.5rem; font-weight: bold;">${stats.winRate.toFixed(1)}%</div>
          </div>
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Avg R</div>
            <div style="color: ${stats.avgR >= 0 ? '#22c55e' : '#ef4444'}; font-size: 1.5rem; font-weight: bold;">${stats.avgR >= 0 ? '+' : ''}${stats.avgR.toFixed(2)}R</div>
          </div>
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Max Win</div>
            <div style="color: #22c55e; font-size: 1.5rem; font-weight: bold;">+${stats.maxWin.toFixed(2)}R</div>
          </div>
          <div>
            <div style="color: var(--color-yellow-75); font-family: var(--font-mathias); font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Max Loss</div>
            <div style="color: #ef4444; font-size: 1.5rem; font-weight: bold;">${stats.maxLoss.toFixed(2)}R</div>
          </div>
        </div>
      `;
      
      if (Object.keys(stats.byStrategy).length > 0) {
        html += `
          <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <h3 style="font-family: var(--font-mathias); font-size: 1rem; font-weight: bold; color: var(--color-yellow-75); margin-bottom: 1rem; text-transform: uppercase;">By Strategy</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
        `;
        
        Object.entries(stats.byStrategy).forEach(([strategy, data]) => {
          html += `
            <div style="padding: 1rem; background-color: rgba(0, 0, 0, 0.4); border-radius: 0.5rem; border: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="font-family: var(--font-mathias); font-weight: bold; color: var(--color-yellow-75); margin-bottom: 0.5rem;">${strategy}</div>
              <div style="font-size: 0.875rem; color: var(--text-secondary);">
                <div>${data.count} trades | ${data.winRate.toFixed(1)}% win rate</div>
                <div style="color: ${data.avgR >= 0 ? '#22c55e' : '#ef4444'}; margin-top: 0.25rem;">
                  Avg: ${data.avgR >= 0 ? '+' : ''}${data.avgR.toFixed(2)}R
                </div>
              </div>
            </div>
          `;
        });
        
        html += `</div></div>`;
      }
      
      statsDisplay.innerHTML = html;
    }
    
    // Toggle stats panel
    window.toggleStatsPanel = function() {
      const content = document.getElementById('statsContent');
      const icon = document.getElementById('statsToggleIcon');
      if (content.style.display === 'none' || !content.style.display) {
        content.style.display = 'block';
        icon.textContent = '‚ñº';
      } else {
        content.style.display = 'none';
        icon.textContent = '‚ñ∂';
      }
    };
    
    // Render all trades
    async function renderTrades() {
      console.log('üü¢ renderTrades() CALLED');
      console.log('üî¢ trades.length:', trades.length);
      console.log('üìã trades array:', trades);
      
      // Update stats display
      updateStatsDisplay();
      
      const pendingTrades = trades.filter(t => t.status === 'PENDING');
      const activeTrades = trades.filter(t => t.status === 'ACTIVE');
      const closedTrades = trades.filter(t => t.status === 'CLOSED');
      const invalidatedTrades = trades.filter(t => t.status === 'INVALIDATED');
      
      console.log('  üìä Pending:', pendingTrades.length, '| Active:', activeTrades.length, '| Closed:', closedTrades.length, '| Invalidated:', invalidatedTrades.length);
      
      const allTrades = [...pendingTrades, ...activeTrades, ...closedTrades, ...invalidatedTrades];
      console.log('  üìä allTrades.length:', allTrades.length);
      
      const tradesTable = document.getElementById('tradesTable');
      console.log('  üîç tradesTable element exists?', !!tradesTable);
      
      if (!tradesTable) {
        console.error('‚ùå tradesTable element NOT FOUND!');
        return;
      }
      
      if (allTrades.length === 0) {
        console.log('  ‚ÑπÔ∏è NO TRADES TO DISPLAY - clearing table');
        tradesTable.innerHTML = '';
      } else {
        console.log('  ‚úÖ RENDERING', allTrades.length, 'trades...');
        // Fetch market analysis for all active and pending trades (pending needs monitoring for entry)
        console.log('üìä Fetching market analysis for active and pending trades...');
        const tradesToAnalyze = [...pendingTrades, ...activeTrades];
        const analysisPromises = tradesToAnalyze.map(trade => analyzeMarketForTrade(trade, priceCache[trade.symbol] || 0));
        await Promise.all(analysisPromises);
        
        tradesTable.innerHTML = '';
        allTrades.forEach(trade => {
          console.log(`  ‚úì Rendering trade: ${trade.symbol} ${trade.direction} @ $${trade.entry}`);
          const tradeRow = createTradeRow(trade);
          const detailsRow = createTradeDetailsRow(trade);
          tradesTable.appendChild(tradeRow);
          tradesTable.appendChild(detailsRow);
          
          // Restore expanded state if this trade was previously expanded
          if (expandedTradeIds.has(trade.id)) {
            console.log(`  üîì Restoring expanded state for trade ${trade.id}`);
            detailsRow.classList.add('expanded');
            // Update button text
            const button = tradeRow.querySelector('button[onclick*="toggleTradeDetails"]');
            if (button) button.textContent = 'HIDE';
          }
        });
        console.log('‚úÖ All trades rendered');
      }
    }
    
    // Close trade manually
    window.closeTrade = function(tradeId, exitPrice) {
      const trade = trades.find(t => t.id === tradeId);
      if (!trade) return;
      
      const risk = Math.abs(trade.entry - trade.stopLoss);
      const pnl = trade.direction === 'LONG' ? 
        (exitPrice - trade.entry) :
        (trade.entry - exitPrice);
      const rMultiple = pnl / risk;
      
      trade.status = 'CLOSED';
      trade.outcome = rMultiple >= 0 ? 'WIN' : 'LOSS';
      trade.exitPrice = exitPrice;
      trade.exitTime = new Date().toISOString();
      
      saveTrades();
      renderTrades();
    };
    
    // Analyze active trade position
    window.analyzeTrade = async function(tradeId) {
      const trade = trades.find(t => t.id === tradeId);
      if (!trade) {
        alert('Trade not found');
        return;
      }
      
      if (trade.status === 'CLOSED') {
        alert('Analysis is only available for active or pending trades');
        return;
      }
      
      console.log('ü§ñ Analyzing trade position:', tradeId);
      
      // Show loading state
      const button = document.getElementById(`analyzeBtn-${tradeId}`);
      const analysisDiv = document.getElementById(`aiAnalysis-${tradeId}`);
      const originalText = button ? button.textContent : 'ANALYZE';
      
      if (button) {
        button.textContent = 'ANALYZING...';
        button.disabled = true;
      }
      
      if (analysisDiv) {
        analysisDiv.innerHTML = '<p style="color: var(--color-yellow-75);">Analyzing trade position...</p>';
      }
      
      try {
        // Get current market snapshot for the symbol
        const currentPrice = priceCache[trade.symbol] || trade.entry;
        
        // Fetch market data for analysis
        const marketResponse = await fetch(`/api/analyze/${trade.symbol}`);
        const marketData = await marketResponse.json();
        
        // Build market snapshot
        const marketSnapshot = {
          symbol: trade.symbol,
          currentPrice: currentPrice,
          priceChange24h: marketData.priceChange24h || 0,
          analysis: marketData.analysis || {},
          signal: marketData.signal || marketData.tradeSignal || {},
          htfBias: marketData.htfBias || { direction: 'neutral', confidence: 0, source: 'none' }
        };
        
        // Call AI analysis endpoint
        const response = await fetch('/api/agent-review', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            marketSnapshot: marketSnapshot,
            setupType: trade.strategy || 'SCALP',
            symbol: trade.symbol
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to analyze trade');
        }
        
        const data = await response.json();
        console.log('‚úÖ Trade analysis received:', data);
        
        // Extract analysis text
        const analysisText = data.formattedText || data.analysis || 'Analysis complete';
        
        // Extract structured data from analysis if available
        const priority = data.priority || 'B';
        const formattedText = data.formattedText || '';
        
        // Update market context from the fetched market data
        const marketTrend = marketData.htfBias?.direction === 'long' ? 'BULLISH' : 
                           marketData.htfBias?.direction === 'short' ? 'BEARISH' : 'NEUTRAL';
        const marketConfidence = marketData.htfBias?.confidence || 0;
        const tradeDirection = trade.direction === 'LONG' ? 'LONG' : 'SHORT';
        const marketAligned = (tradeDirection === 'LONG' && marketTrend === 'BULLISH') ||
                             (tradeDirection === 'SHORT' && marketTrend === 'BEARISH');
        
        // Update market analysis cache
        marketAnalysis[trade.id] = {
          momentum: marketData.signal?.direction === trade.direction.toLowerCase() ? 'ALIGNED' : 'AGAINST',
          trend: marketTrend,
          confidence: marketConfidence,
          alignment: marketAligned ? 'Aligned' : 'Against'
        };
        
        // Update trade with analysis
        trade.aiAnalysis = analysisText;
        trade.aiAnalysisData = {
          priority: priority,
          formattedText: formattedText,
          timestamp: new Date().toISOString(),
          marketTrend: marketTrend,
          marketConfidence: marketConfidence,
          marketAligned: marketAligned
        };
        
        // Update signal snapshot and trade values from fresh market data
        if (marketData.signal && trade.signalSnapshot) {
          // Update targets if available in signal
          if (marketData.signal.targets && Array.isArray(marketData.signal.targets) && marketData.signal.targets.length >= 2) {
            trade.target1 = marketData.signal.targets[0];
            trade.target2 = marketData.signal.targets[1];
          }
          
          // Update invalidation level if available
          if (marketData.signal.invalidationLevel) {
            trade.invalidationLevel = marketData.signal.invalidationLevel;
          } else if (marketData.signal.stopLoss) {
            trade.invalidationLevel = marketData.signal.stopLoss;
          }
          
          // Update signal snapshot with fresh data
          trade.signalSnapshot.signal = {
            ...trade.signalSnapshot.signal,
            ...marketData.signal,
            invalidation: marketData.signal.invalidation || trade.signalSnapshot.signal.invalidation
          };
          trade.signalSnapshot.htfBias = marketData.htfBias || trade.signalSnapshot.htfBias;
        }
        
        // Save to Firebase
        await saveTrades();
        
        // Re-render the trade details to update all sections with new data
        await renderTrades();
        
        // Re-expand the details if it was expanded
        const detailsRow = document.getElementById(`trade-details-${tradeId}`);
        if (detailsRow && expandedTradeIds.has(tradeId)) {
          detailsRow.classList.add('expanded');
          // Update button text
          const hideButton = detailsRow.querySelector('button[onclick*="toggleTradeDetails"]');
          if (hideButton) hideButton.textContent = 'HIDE';
        }
        
        if (button) {
          button.textContent = 'RE-ANALYZE';
          button.disabled = false;
        }
        
      } catch (error) {
        console.error('‚ùå Error analyzing trade:', error);
        if (analysisDiv) {
          analysisDiv.innerHTML = `<p style="color: #ef4444;">Error: ${error.message}</p>`;
        }
        if (button) {
          button.textContent = originalText;
          button.disabled = false;
        }
      }
    };
    
    // Generate trade review
    window.generateTradeReview = async function(tradeId) {
      const trade = trades.find(t => t.id === tradeId);
      if (!trade) {
        alert('Trade not found');
        return;
      }
      
      if (trade.status !== 'CLOSED' || !trade.exitPrice) {
        alert('Review can only be generated for closed trades with an exit price');
        return;
      }
      
      if (!trade.signalSnapshot) {
        alert('Cannot generate review: trade missing signal snapshot. This trade was created before the review feature was added.');
        return;
      }
      
      console.log('üìù Generating review for trade:', tradeId);
      
      // Show loading state
      const button = event.target.closest('button');
      const originalText = button.textContent;
      button.textContent = 'GENERATING...';
      button.disabled = true;
      
      try {
        const response = await fetch('/api/review-trade', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ trade })
        });
        
        if (!response.ok) {
          // Try to parse error as JSON, but handle HTML error pages
          let errorMessage = 'Failed to generate review';
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
          } catch (e) {
            const errorText = await response.text();
            errorMessage = `Server error (${response.status}): ${errorText.substring(0, 100)}`;
          }
          throw new Error(errorMessage);
        }
        
        const data = await response.json();
        console.log('‚úÖ Review generated:', data);
        
        // Update trade with review
        trade.review = data.review;
        
        // Save to Firebase
        await saveTrades();
        
        // Re-render to show review
        await renderTrades();
        
        // Re-expand the details
        const detailsRow = document.getElementById(`trade-details-${tradeId}`);
        if (detailsRow) {
          detailsRow.classList.add('expanded');
          expandedTradeIds.add(tradeId);
        }
        
        alert('Review generated successfully!');
      } catch (error) {
        console.error('‚ùå Error generating review:', error);
        alert(`Failed to generate review: ${error.message}`);
        button.textContent = originalText;
        button.disabled = false;
      }
    };
    
    // Delete trade
    window.deleteTrade = async function(tradeId) {
      if (!confirm('Are you sure you want to delete this trade? This action cannot be undone.')) {
        return;
      }
      
      console.log('üóëÔ∏è Deleting trade:', tradeId);
      
      // Remove from expanded state
      expandedTradeIds.delete(tradeId);
      
      // Remove from trades array
      const index = trades.findIndex(t => t.id === tradeId);
      if (index !== -1) {
        const deletedTrade = trades.splice(index, 1)[0];
        console.log('‚úÖ Deleted trade:', deletedTrade.symbol, deletedTrade.direction);
        
        // Delete from Firebase
        if (db) {
          try {
            await db.collection('trades').doc(String(tradeId)).delete();
            console.log('üóëÔ∏è Deleted from Firebase');
            
            // Also delete associated image if exists
            if (deletedTrade.imageUrl && storage) {
              try {
                const imageRef = storage.refFromURL(deletedTrade.imageUrl);
                await imageRef.delete();
                console.log('üóëÔ∏è Deleted trade image from Firebase Storage');
              } catch (imgError) {
                console.warn('‚ö†Ô∏è Could not delete image:', imgError);
              }
            }
          } catch (error) {
            console.error('‚ùå Error deleting from Firebase:', error);
          }
        }
        
        await saveTrades();
        renderTrades();
      } else {
        console.error('‚ùå Trade not found:', tradeId);
      }
    };
    
    // Handle file upload
    window.handleFileUpload = async function(event) {
      console.log('üì§ File upload triggered');
      const file = event.target.files[0];
      if (!file) {
        console.log('‚ö†Ô∏è No file selected');
        return;
      }
      
      console.log('üìÅ File selected:', file.name, file.type, file.size);
      
      // Check if it's an image
      if (!file.type.startsWith('image/')) {
        console.log('‚ùå Not an image file');
        alert('Please upload an image file (PNG, JPG, etc.)');
        event.target.value = '';
        return;
      }
      
      // Show loading indicator
      const uploadBtn = event.target.parentElement.querySelector('div');
      const originalContent = uploadBtn.innerHTML;
      uploadBtn.innerHTML = `
        <svg style="animation: spin 1s linear infinite;" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
        </svg>
        <span>ANALYZING IMAGE...</span>
      `;
      
      try {
        // Upload image to Firebase Storage first
        let uploadedImageUrl = null;
        if (storage) {
          try {
            const timestamp = Date.now();
            const fileName = `trade_images/${timestamp}_${file.name}`;
            const storageRef = storage.ref(fileName);
            
            console.log('üì§ Uploading image to Firebase Storage...');
            const uploadTask = await storageRef.put(file);
            uploadedImageUrl = await uploadTask.ref.getDownloadURL();
            console.log('‚úÖ Image uploaded to Firebase:', uploadedImageUrl);
          } catch (storageError) {
            console.error('‚ùå Error uploading to Firebase Storage:', storageError);
            alert('‚ö†Ô∏è Image upload failed, but we\'ll try to parse it anyway.');
          }
        }
        
        // Convert image to base64
        const reader = new FileReader();
        reader.onload = async function(e) {
          const base64Data = e.target.result;
          
          try {
            console.log('üöÄ Sending image to API...');
            // Send to API
            const response = await fetch('/api/parse-trade-image', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                imageData: base64Data
              })
            });
            
            console.log('üì• API response status:', response.status);
            const result = await response.json();
            console.log('üìä API result:', result);
            
            if (!response.ok) {
              throw new Error(result.error || 'Failed to parse image');
            }
            
            // Auto-fill form with extracted data
            const data = result.data;
            
            if (data.symbol) {
              document.getElementById('symbol').value = data.symbol;
            }
            
            if (data.direction) {
              document.getElementById('direction').value = data.direction;
            }
            
            if (data.entry) {
              document.getElementById('entry').value = data.entry;
            }
            
            if (data.stopLoss) {
              document.getElementById('stopLoss').value = data.stopLoss;
            }
            
            // Store uploaded image URL in a hidden field
            if (uploadedImageUrl) {
              let imageUrlField = document.getElementById('uploadedImageUrl');
              if (!imageUrlField) {
                imageUrlField = document.createElement('input');
                imageUrlField.type = 'hidden';
                imageUrlField.id = 'uploadedImageUrl';
                document.getElementById('addTradeForm').appendChild(imageUrlField);
              }
              imageUrlField.value = uploadedImageUrl;
              console.log('üíæ Stored image URL for trade submission');
            }
            
            // Trigger preview update
            await updateTradePreview();
            
            // Show success message
            const fieldsFound = [];
            if (data.symbol) fieldsFound.push('Symbol');
            if (data.direction) fieldsFound.push('Direction');
            if (data.entry) fieldsFound.push('Entry');
            if (data.stopLoss) fieldsFound.push('Stop Loss');
            
            alert(`‚úÖ Trade details extracted!\n\nFound: ${fieldsFound.join(', ')}\n\nPlease review the values before submitting.`);
            
          } catch (error) {
            console.error('Error parsing image:', error);
            alert(`‚ùå Could not extract trade details from image.\n\n${error.message}\n\nPlease enter manually or try a clearer screenshot.`);
          } finally {
            // Restore button
            uploadBtn.innerHTML = originalContent;
          }
        };
        
        reader.readAsDataURL(file);
        
      } catch (error) {
        console.error('Error reading file:', error);
        alert('Error reading file. Please try again.');
        uploadBtn.innerHTML = originalContent;
      }
      
      // Reset file input
      event.target.value = '';
    };
  </script>

  <!-- Particles.js Library -->
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <script>
    // Initialize particle system
    particlesJS('particles-js', {
      particles: {
        number: {
          value: 500,
          density: {
            enable: true,
            value_area: 800
          }
        },
        color: {
          value: '#ffffff'
        },
        shape: {
          type: 'circle'
        },
        opacity: {
          value: 0.5,
          random: true,
          anim: {
            enable: true,
            speed: 1,
            opacity_min: 0.1,
            sync: false
          }
        },
        size: {
          value: 2,
          random: true,
          anim: {
            enable: true,
            speed: 2,
            size_min: 0.1,
            sync: false
          }
        },
        line_linked: {
          enable: false
        },
        move: {
          enable: true,
          speed: 0.5,
          direction: 'none',
          random: true,
          straight: false,
          out_mode: 'out',
          bounce: false
        }
      },
      interactivity: {
        detect_on: 'canvas',
        events: {
          onhover: {
            enable: false
          },
          onclick: {
            enable: false
          },
          resize: true
        }
      },
      retina_detect: true
    });
  </script>
</body>
</html>

