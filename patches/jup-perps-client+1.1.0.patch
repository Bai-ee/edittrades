diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js b/node_modules/jup-perps-client/dist/accounts/custody.js
index 9142821..ae3d19f 100644
--- a/node_modules/jup-perps-client/dist/accounts/custody.js
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
-import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
 export const CUSTODY_DISCRIMINATOR = new Uint8Array([
     1, 184, 48, 81, 93, 131, 63, 145,
 ]);
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak b/node_modules/jup-perps-client/dist/accounts/custody.js.bak
new file mode 100644
index 0000000..9142821
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak10 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak10
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak10
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak2 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak2
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak2
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak6 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak6
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak6
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak7 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak7
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak7
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak8 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak8
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak8
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/custody.js.bak9 b/node_modules/jup-perps-client/dist/accounts/custody.js.bak9
new file mode 100644
index 0000000..ae3d19f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/custody.js.bak9
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getAssetsDecoder, getAssetsEncoder, getFundingRateStateDecoder, getFundingRateStateEncoder, getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPriceImpactBufferDecoder, getPriceImpactBufferEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const CUSTODY_DISCRIMINATOR = new Uint8Array([
+    1, 184, 48, 81, 93, 131, 63, 145,
+]);
+export function getCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
+}
+export function getCustodyEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pool', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['tokenAccount', getAddressEncoder()],
+        ['decimals', getU8Encoder()],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['assets', getAssetsEncoder()],
+        ['fundingRateState', getFundingRateStateEncoder()],
+        ['bump', getU8Encoder()],
+        ['tokenAccountBump', getU8Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['jumpRateState', getJumpRateStateEncoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+        ['priceImpactBuffer', getPriceImpactBufferEncoder()],
+    ]), (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR }));
+}
+export function getCustodyDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pool', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['tokenAccount', getAddressDecoder()],
+        ['decimals', getU8Decoder()],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['assets', getAssetsDecoder()],
+        ['fundingRateState', getFundingRateStateDecoder()],
+        ['bump', getU8Decoder()],
+        ['tokenAccountBump', getU8Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['jumpRateState', getJumpRateStateDecoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+        ['priceImpactBuffer', getPriceImpactBufferDecoder()],
+    ]);
+}
+export function getCustodyCodec() {
+    return combineCodec(getCustodyEncoder(), getCustodyDecoder());
+}
+export function decodeCustody(encodedAccount) {
+    return decodeAccount(encodedAccount, getCustodyDecoder());
+}
+export async function fetchCustody(rpc, address, config) {
+    const maybeAccount = await fetchMaybeCustody(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeCustody(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeCustody(maybeAccount);
+}
+export async function fetchAllCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeCustody(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
+}
+export function getCustodySize() {
+    return 932;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/index-patched.js b/node_modules/jup-perps-client/dist/accounts/index-patched.js
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index-patched.js
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index-patched.js.bak2 b/node_modules/jup-perps-client/dist/accounts/index-patched.js.bak2
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index-patched.js.bak2
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js b/node_modules/jup-perps-client/dist/accounts/index.js
index 0b12908..f4c5187 100644
--- a/node_modules/jup-perps-client/dist/accounts/index.js
+++ b/node_modules/jup-perps-client/dist/accounts/index.js
@@ -1,13 +1,10 @@
 /**
- * This code was AUTOGENERATED using the codama library.
- * Please DO NOT EDIT THIS FILE, instead use visitors
- * to add features, then rerun codama to update it.
- *
- * @see https://github.com/codama-idl/codama
+ * Patched index.js - uses explicit file imports instead of directory imports
  */
-export * from './custody';
-export * from './perpetuals';
-export * from './pool';
-export * from './position';
-export * from './positionRequest';
-export * from './tokenLedger';
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.backup b/node_modules/jup-perps-client/dist/accounts/index.js.backup
new file mode 100644
index 0000000..0b12908
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.backup
@@ -0,0 +1,13 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './custody';
+export * from './perpetuals';
+export * from './pool';
+export * from './position';
+export * from './positionRequest';
+export * from './tokenLedger';
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak10 b/node_modules/jup-perps-client/dist/accounts/index.js.bak10
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak10
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak2 b/node_modules/jup-perps-client/dist/accounts/index.js.bak2
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak2
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak6 b/node_modules/jup-perps-client/dist/accounts/index.js.bak6
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak6
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak7 b/node_modules/jup-perps-client/dist/accounts/index.js.bak7
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak7
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak8 b/node_modules/jup-perps-client/dist/accounts/index.js.bak8
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak8
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/index.js.bak9 b/node_modules/jup-perps-client/dist/accounts/index.js.bak9
new file mode 100644
index 0000000..f4c5187
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/index.js.bak9
@@ -0,0 +1,10 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './custody.js';
+export * from './perpetuals.js';
+export * from './pool.js';
+export * from './position.js';
+export * from './positionRequest.js';
+export * from './tokenLedger.js';
+
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js b/node_modules/jup-perps-client/dist/accounts/perpetuals.js
index 8b95fbd..48f5470 100644
--- a/node_modules/jup-perps-client/dist/accounts/perpetuals.js
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
-import { getPermissionsDecoder, getPermissionsEncoder, } from '../types';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
 export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
     28, 167, 98, 191, 104, 82, 108, 196,
 ]);
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak10 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak10
new file mode 100644
index 0000000..48f5470
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak10
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak2 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak2
new file mode 100644
index 0000000..8b95fbd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak2
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak6 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak6
new file mode 100644
index 0000000..48f5470
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak6
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak7 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak7
new file mode 100644
index 0000000..48f5470
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak7
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak8 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak8
new file mode 100644
index 0000000..48f5470
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak8
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak9 b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak9
new file mode 100644
index 0000000..48f5470
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/perpetuals.js.bak9
@@ -0,0 +1,61 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const PERPETUALS_DISCRIMINATOR = new Uint8Array([
+    28, 167, 98, 191, 104, 82, 108, 196,
+]);
+export function getPerpetualsDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(PERPETUALS_DISCRIMINATOR);
+}
+export function getPerpetualsEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+        ['pools', getArrayEncoder(getAddressEncoder())],
+        ['admin', getAddressEncoder()],
+        ['transferAuthorityBump', getU8Encoder()],
+        ['perpetualsBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: PERPETUALS_DISCRIMINATOR }));
+}
+export function getPerpetualsDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+        ['pools', getArrayDecoder(getAddressDecoder())],
+        ['admin', getAddressDecoder()],
+        ['transferAuthorityBump', getU8Decoder()],
+        ['perpetualsBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPerpetualsCodec() {
+    return combineCodec(getPerpetualsEncoder(), getPerpetualsDecoder());
+}
+export function decodePerpetuals(encodedAccount) {
+    return decodeAccount(encodedAccount, getPerpetualsDecoder());
+}
+export async function fetchPerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchMaybePerpetuals(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePerpetuals(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePerpetuals(maybeAccount);
+}
+export async function fetchAllPerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePerpetuals(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePerpetuals(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePerpetuals(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js b/node_modules/jup-perps-client/dist/accounts/pool.js
index 31e097f..d137895 100644
--- a/node_modules/jup-perps-client/dist/accounts/pool.js
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
-import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
 export const POOL_DISCRIMINATOR = new Uint8Array([
     241, 154, 109, 4, 17, 177, 109, 188,
 ]);
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak b/node_modules/jup-perps-client/dist/accounts/pool.js.bak
new file mode 100644
index 0000000..31e097f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak10 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak10
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak10
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak2 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak2
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak2
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak6 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak6
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak6
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak7 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak7
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak7
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak8 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak8
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak8
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/pool.js.bak9 b/node_modules/jup-perps-client/dist/accounts/pool.js.bak9
new file mode 100644
index 0000000..d137895
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/pool.js.bak9
@@ -0,0 +1,69 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getArrayDecoder, getArrayEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU32Decoder, getU32Encoder, getU8Decoder, getU8Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, getPoolAprDecoder, getPoolAprEncoder, } from '../types/index.js';
+export const POOL_DISCRIMINATOR = new Uint8Array([
+    241, 154, 109, 4, 17, 177, 109, 188,
+]);
+export function getPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POOL_DISCRIMINATOR);
+}
+export function getPoolEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['custodies', getArrayEncoder(getAddressEncoder())],
+        ['aumUsd', getU128Encoder()],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['poolApr', getPoolAprEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+        ['bump', getU8Encoder()],
+        ['lpTokenBump', getU8Encoder()],
+        ['inceptionTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: POOL_DISCRIMINATOR }));
+}
+export function getPoolDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['custodies', getArrayDecoder(getAddressDecoder())],
+        ['aumUsd', getU128Decoder()],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['poolApr', getPoolAprDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+        ['bump', getU8Decoder()],
+        ['lpTokenBump', getU8Decoder()],
+        ['inceptionTime', getI64Decoder()],
+    ]);
+}
+export function getPoolCodec() {
+    return combineCodec(getPoolEncoder(), getPoolDecoder());
+}
+export function decodePool(encodedAccount) {
+    return decodeAccount(encodedAccount, getPoolDecoder());
+}
+export async function fetchPool(rpc, address, config) {
+    const maybeAccount = await fetchMaybePool(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePool(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePool(maybeAccount);
+}
+export async function fetchAllPool(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePool(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePool(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePool(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js b/node_modules/jup-perps-client/dist/accounts/position.js
index d15aa3f..73cb421 100644
--- a/node_modules/jup-perps-client/dist/accounts/position.js
+++ b/node_modules/jup-perps-client/dist/accounts/position.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
-import { getSideDecoder, getSideEncoder, } from '../types';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
 export const POSITION_DISCRIMINATOR = new Uint8Array([
     170, 188, 143, 228, 122, 64, 247, 208,
 ]);
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak10 b/node_modules/jup-perps-client/dist/accounts/position.js.bak10
new file mode 100644
index 0000000..73cb421
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak10
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak2 b/node_modules/jup-perps-client/dist/accounts/position.js.bak2
new file mode 100644
index 0000000..d15aa3f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak2
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak6 b/node_modules/jup-perps-client/dist/accounts/position.js.bak6
new file mode 100644
index 0000000..73cb421
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak6
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak7 b/node_modules/jup-perps-client/dist/accounts/position.js.bak7
new file mode 100644
index 0000000..73cb421
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak7
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak8 b/node_modules/jup-perps-client/dist/accounts/position.js.bak8
new file mode 100644
index 0000000..73cb421
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak8
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/position.js.bak9 b/node_modules/jup-perps-client/dist/accounts/position.js.bak9
new file mode 100644
index 0000000..73cb421
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/position.js.bak9
@@ -0,0 +1,80 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_DISCRIMINATOR = new Uint8Array([
+    170, 188, 143, 228, 122, 64, 247, 208,
+]);
+export function getPositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);
+}
+export function getPositionEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['collateralCustody', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['side', getSideEncoder()],
+        ['price', getU64Encoder()],
+        ['sizeUsd', getU64Encoder()],
+        ['collateralUsd', getU64Encoder()],
+        ['realisedPnlUsd', getI64Encoder()],
+        ['cumulativeInterestSnapshot', getU128Encoder()],
+        ['lockedAmount', getU64Encoder()],
+        ['bump', getU8Encoder()],
+    ]), (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR }));
+}
+export function getPositionDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['collateralCustody', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['side', getSideDecoder()],
+        ['price', getU64Decoder()],
+        ['sizeUsd', getU64Decoder()],
+        ['collateralUsd', getU64Decoder()],
+        ['realisedPnlUsd', getI64Decoder()],
+        ['cumulativeInterestSnapshot', getU128Decoder()],
+        ['lockedAmount', getU64Decoder()],
+        ['bump', getU8Decoder()],
+    ]);
+}
+export function getPositionCodec() {
+    return combineCodec(getPositionEncoder(), getPositionDecoder());
+}
+export function decodePosition(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionDecoder());
+}
+export async function fetchPosition(rpc, address, config) {
+    const maybeAccount = await fetchMaybePosition(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePosition(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePosition(maybeAccount);
+}
+export async function fetchAllPosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePosition(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
+}
+export function getPositionSize() {
+    return 210;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js b/node_modules/jup-perps-client/dist/accounts/positionRequest.js
index e45a631..41eae07 100644
--- a/node_modules/jup-perps-client/dist/accounts/positionRequest.js
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
-import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
 export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
     12, 38, 250, 199, 46, 154, 32, 216,
 ]);
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak10 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak10
new file mode 100644
index 0000000..41eae07
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak10
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak2 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak2
new file mode 100644
index 0000000..e45a631
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak2
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak6 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak6
new file mode 100644
index 0000000..41eae07
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak6
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak7 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak7
new file mode 100644
index 0000000..41eae07
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak7
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak8 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak8
new file mode 100644
index 0000000..41eae07
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak8
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak9 b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak9
new file mode 100644
index 0000000..41eae07
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/positionRequest.js.bak9
@@ -0,0 +1,93 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
+import { getRequestChangeDecoder, getRequestChangeEncoder, getRequestTypeDecoder, getRequestTypeEncoder, getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    12, 38, 250, 199, 46, 154, 32, 216,
+]);
+export function getPositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getPositionRequestEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['owner', getAddressEncoder()],
+        ['pool', getAddressEncoder()],
+        ['custody', getAddressEncoder()],
+        ['position', getAddressEncoder()],
+        ['mint', getAddressEncoder()],
+        ['openTime', getI64Encoder()],
+        ['updateTime', getI64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralDelta', getU64Encoder()],
+        ['requestChange', getRequestChangeEncoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['preSwapAmount', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['executed', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['bump', getU8Encoder()],
+        ['referral', getOptionEncoder(getAddressEncoder())],
+    ]), (value) => ({ ...value, discriminator: POSITION_REQUEST_DISCRIMINATOR }));
+}
+export function getPositionRequestDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['owner', getAddressDecoder()],
+        ['pool', getAddressDecoder()],
+        ['custody', getAddressDecoder()],
+        ['position', getAddressDecoder()],
+        ['mint', getAddressDecoder()],
+        ['openTime', getI64Decoder()],
+        ['updateTime', getI64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralDelta', getU64Decoder()],
+        ['requestChange', getRequestChangeDecoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['preSwapAmount', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['executed', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['bump', getU8Decoder()],
+        ['referral', getOptionDecoder(getAddressDecoder())],
+    ]);
+}
+export function getPositionRequestCodec() {
+    return combineCodec(getPositionRequestEncoder(), getPositionRequestDecoder());
+}
+export function decodePositionRequest(encodedAccount) {
+    return decodeAccount(encodedAccount, getPositionRequestDecoder());
+}
+export async function fetchPositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchMaybePositionRequest(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybePositionRequest(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodePositionRequest(maybeAccount);
+}
+export async function fetchAllPositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybePositionRequest(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybePositionRequest(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodePositionRequest(maybeAccount));
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak10 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak10
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak10
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak2 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak2
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak2
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak6 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak6
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak6
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak7 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak7
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak7
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak8 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak8
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak8
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak9 b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak9
new file mode 100644
index 0000000..bf50af3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/accounts/tokenLedger.js.bak9
@@ -0,0 +1,55 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+export const TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    156, 247, 9, 188, 54, 108, 85, 77,
+]);
+export function getTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getTokenLedgerEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAccount', getAddressEncoder()],
+        ['amount', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getTokenLedgerDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAccount', getAddressDecoder()],
+        ['amount', getU64Decoder()],
+    ]);
+}
+export function getTokenLedgerCodec() {
+    return combineCodec(getTokenLedgerEncoder(), getTokenLedgerDecoder());
+}
+export function decodeTokenLedger(encodedAccount) {
+    return decodeAccount(encodedAccount, getTokenLedgerDecoder());
+}
+export async function fetchTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchMaybeTokenLedger(rpc, address, config);
+    assertAccountExists(maybeAccount);
+    return maybeAccount;
+}
+export async function fetchMaybeTokenLedger(rpc, address, config) {
+    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
+    return decodeTokenLedger(maybeAccount);
+}
+export async function fetchAllTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchAllMaybeTokenLedger(rpc, addresses, config);
+    assertAccountsExist(maybeAccounts);
+    return maybeAccounts;
+}
+export async function fetchAllMaybeTokenLedger(rpc, addresses, config) {
+    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
+    return maybeAccounts.map((maybeAccount) => decodeTokenLedger(maybeAccount));
+}
+export function getTokenLedgerSize() {
+    return 48;
+}
diff --git a/node_modules/jup-perps-client/dist/errors/index-patched.js b/node_modules/jup-perps-client/dist/errors/index-patched.js
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index-patched.js
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js b/node_modules/jup-perps-client/dist/errors/index.js
index 5827468..a306cca 100644
--- a/node_modules/jup-perps-client/dist/errors/index.js
+++ b/node_modules/jup-perps-client/dist/errors/index.js
@@ -5,4 +5,4 @@
  *
  * @see https://github.com/codama-idl/codama
  */
-export * from './perpetuals';
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.backup b/node_modules/jup-perps-client/dist/errors/index.js.backup
new file mode 100644
index 0000000..5827468
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.backup
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak10 b/node_modules/jup-perps-client/dist/errors/index.js.bak10
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak10
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak2 b/node_modules/jup-perps-client/dist/errors/index.js.bak2
new file mode 100644
index 0000000..5827468
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak2
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak6 b/node_modules/jup-perps-client/dist/errors/index.js.bak6
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak6
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak7 b/node_modules/jup-perps-client/dist/errors/index.js.bak7
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak7
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak8 b/node_modules/jup-perps-client/dist/errors/index.js.bak8
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak8
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/index.js.bak9 b/node_modules/jup-perps-client/dist/errors/index.js.bak9
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/index.js.bak9
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js b/node_modules/jup-perps-client/dist/errors/perpetuals.js
index 87910db..79c6f03 100644
--- a/node_modules/jup-perps-client/dist/errors/perpetuals.js
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { isProgramError, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
 /** MathOverflow: Overflow in arithmetic operation */
 export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
 /** UnsupportedOracle: Unsupported price oracle */
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak10 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak10
new file mode 100644
index 0000000..79c6f03
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak10
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak2 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak2
new file mode 100644
index 0000000..87910db
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak2
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak6 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak6
new file mode 100644
index 0000000..87910db
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak6
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak7 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak7
new file mode 100644
index 0000000..79c6f03
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak7
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak8 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak8
new file mode 100644
index 0000000..79c6f03
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak8
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak9 b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak9
new file mode 100644
index 0000000..79c6f03
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/errors/perpetuals.js.bak9
@@ -0,0 +1,191 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { isProgramError, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+/** MathOverflow: Overflow in arithmetic operation */
+export const PERPETUALS_ERROR__MATH_OVERFLOW = 0x1770; // 6000
+/** UnsupportedOracle: Unsupported price oracle */
+export const PERPETUALS_ERROR__UNSUPPORTED_ORACLE = 0x1771; // 6001
+/** InvalidOracleAccount: Invalid oracle account */
+export const PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT = 0x1772; // 6002
+/** StaleOraclePrice: Stale oracle price */
+export const PERPETUALS_ERROR__STALE_ORACLE_PRICE = 0x1773; // 6003
+/** InvalidOraclePrice: Invalid oracle price */
+export const PERPETUALS_ERROR__INVALID_ORACLE_PRICE = 0x1774; // 6004
+/** InvalidEnvironment: Instruction is not allowed in production */
+export const PERPETUALS_ERROR__INVALID_ENVIRONMENT = 0x1775; // 6005
+/** InvalidCollateralAccount: Invalid collateral account */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT = 0x1776; // 6006
+/** InvalidCollateralAmount: Invalid collateral amount */
+export const PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT = 0x1777; // 6007
+/** CollateralSlippage: Collateral slippage */
+export const PERPETUALS_ERROR__COLLATERAL_SLIPPAGE = 0x1778; // 6008
+/** InvalidPositionState: Invalid position state */
+export const PERPETUALS_ERROR__INVALID_POSITION_STATE = 0x1779; // 6009
+/** InvalidPerpetualsConfig: Invalid perpetuals config */
+export const PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG = 0x177a; // 6010
+/** InvalidPoolConfig: Invalid pool config */
+export const PERPETUALS_ERROR__INVALID_POOL_CONFIG = 0x177b; // 6011
+/** InvalidInstruction: Invalid instruction */
+export const PERPETUALS_ERROR__INVALID_INSTRUCTION = 0x177c; // 6012
+/** InvalidCustodyConfig: Invalid custody config */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG = 0x177d; // 6013
+/** InvalidCustodyBalance: Invalid custody balance */
+export const PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE = 0x177e; // 6014
+/** InvalidArgument: Invalid argument */
+export const PERPETUALS_ERROR__INVALID_ARGUMENT = 0x177f; // 6015
+/** InvalidPositionRequest: Invalid position request */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST = 0x1780; // 6016
+/** InvalidPositionRequestInputAta: Invalid position request input ata */
+export const PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA = 0x1781; // 6017
+/** InvalidMint: Invalid mint */
+export const PERPETUALS_ERROR__INVALID_MINT = 0x1782; // 6018
+/** InsufficientTokenAmount: Insufficient token amount */
+export const PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT = 0x1783; // 6019
+/** InsufficientAmountReturned: Insufficient token amount returned */
+export const PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED = 0x1784; // 6020
+/** MaxPriceSlippage: Price slippage limit exceeded */
+export const PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE = 0x1785; // 6021
+/** MaxLeverage: Position leverage limit exceeded */
+export const PERPETUALS_ERROR__MAX_LEVERAGE = 0x1786; // 6022
+/** CustodyAmountLimit: Custody amount limit exceeded */
+export const PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT = 0x1787; // 6023
+/** PoolAmountLimit: Pool amount limit exceeded */
+export const PERPETUALS_ERROR__POOL_AMOUNT_LIMIT = 0x1788; // 6024
+/** PersonalPoolAmountLimit: Personal pool amount limit exceeded */
+export const PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT = 0x1789; // 6025
+/** UnsupportedToken: Token is not supported */
+export const PERPETUALS_ERROR__UNSUPPORTED_TOKEN = 0x178a; // 6026
+/** InstructionNotAllowed: Instruction is not allowed at this time */
+export const PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED = 0x178b; // 6027
+/** JupiterProgramMismatch: Jupiter Program ID mismatch */
+export const PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH = 0x178c; // 6028
+/** ProgramMismatch: Program ID mismatch */
+export const PERPETUALS_ERROR__PROGRAM_MISMATCH = 0x178d; // 6029
+/** AddressMismatch: Address mismatch */
+export const PERPETUALS_ERROR__ADDRESS_MISMATCH = 0x178e; // 6030
+/** KeeperATAMissing: Missing keeper ATA */
+export const PERPETUALS_ERROR__KEEPER_A_T_A_MISSING = 0x178f; // 6031
+/** SwapAmountMismatch: Swap amount mismatch */
+export const PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH = 0x1790; // 6032
+/** CPINotAllowed: CPI not allowed */
+export const PERPETUALS_ERROR__C_P_I_NOT_ALLOWED = 0x1791; // 6033
+/** InvalidKeeper: Invalid Keeper */
+export const PERPETUALS_ERROR__INVALID_KEEPER = 0x1792; // 6034
+/** ExceedExecutionPeriod: Exceed execution period */
+export const PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD = 0x1793; // 6035
+/** InvalidRequestType: Invalid Request Type */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TYPE = 0x1794; // 6036
+/** InvalidTriggerPrice: Invalid Trigger Price */
+export const PERPETUALS_ERROR__INVALID_TRIGGER_PRICE = 0x1795; // 6037
+/** TriggerPriceSlippage: Trigger Price Slippage */
+export const PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE = 0x1796; // 6038
+/** MissingTriggerPrice: Missing Trigger Price */
+export const PERPETUALS_ERROR__MISSING_TRIGGER_PRICE = 0x1797; // 6039
+/** MissingPriceSlippage: Missing Price Slippage */
+export const PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE = 0x1798; // 6040
+/** InvalidPriceCalcMode: Invalid Price Calc Mode */
+export const PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE = 0x1799; // 6041
+/** RequestUpdatedTooRecent: Request Updated Too Recent */
+export const PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT = 0x179a; // 6042
+/** ExceedTokenWeightage: Exceed Token Weightage */
+export const PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE = 0x179b; // 6043
+/** OraclePublishTimeTooEarly: Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179c; // 6044
+/** PullOraclePublishTimeTooEarly: Pull Oracle Publish Time Too Early */
+export const PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY = 0x179d; // 6045
+/** StalePullOraclePrice: Stale Pull Oracle Price */
+export const PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE = 0x179e; // 6046
+/** InvalidPullOraclePrice: Invalid Pull Oracle Price */
+export const PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE = 0x179f; // 6047
+/** PullOracleNotVerified: Pull Oracle Not Verified */
+export const PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED = 0x17a0; // 6048
+/** PriceDiffTooLarge: Price Diff Between Pull and Push Oracle is Too Large */
+export const PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE = 0x17a1; // 6049
+/** InvalidDovesOraclePrice: Invalid Doves Oracle Price */
+export const PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE = 0x17a2; // 6050
+/** InvalidRequestTime: Invalid Request Time */
+export const PERPETUALS_ERROR__INVALID_REQUEST_TIME = 0x17a3; // 6051
+/** PositionUpdatedTooRecent: Position Updated Too Recent */
+export const PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT = 0x17a4; // 6052
+/** LedgerTokenAccountDoesNotMatch: Ledger token account does not match */
+export const PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH = 0x17a5; // 6053
+/** InvalidTokenLedger: Invalid token ledger */
+export const PERPETUALS_ERROR__INVALID_TOKEN_LEDGER = 0x17a6; // 6054
+/** OraclePriceDifferenceTooLarge: Oracle Price Difference Too Large */
+export const PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE = 0x17a7; // 6055
+let perpetualsErrorMessages;
+if (process.env.NODE_ENV !== 'production') {
+    perpetualsErrorMessages = {
+        [PERPETUALS_ERROR__ADDRESS_MISMATCH]: `Address mismatch`,
+        [PERPETUALS_ERROR__COLLATERAL_SLIPPAGE]: `Collateral slippage`,
+        [PERPETUALS_ERROR__C_P_I_NOT_ALLOWED]: `CPI not allowed`,
+        [PERPETUALS_ERROR__CUSTODY_AMOUNT_LIMIT]: `Custody amount limit exceeded`,
+        [PERPETUALS_ERROR__EXCEED_EXECUTION_PERIOD]: `Exceed execution period`,
+        [PERPETUALS_ERROR__EXCEED_TOKEN_WEIGHTAGE]: `Exceed Token Weightage`,
+        [PERPETUALS_ERROR__INSTRUCTION_NOT_ALLOWED]: `Instruction is not allowed at this time`,
+        [PERPETUALS_ERROR__INSUFFICIENT_AMOUNT_RETURNED]: `Insufficient token amount returned`,
+        [PERPETUALS_ERROR__INSUFFICIENT_TOKEN_AMOUNT]: `Insufficient token amount`,
+        [PERPETUALS_ERROR__INVALID_ARGUMENT]: `Invalid argument`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_ACCOUNT]: `Invalid collateral account`,
+        [PERPETUALS_ERROR__INVALID_COLLATERAL_AMOUNT]: `Invalid collateral amount`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_BALANCE]: `Invalid custody balance`,
+        [PERPETUALS_ERROR__INVALID_CUSTODY_CONFIG]: `Invalid custody config`,
+        [PERPETUALS_ERROR__INVALID_DOVES_ORACLE_PRICE]: `Invalid Doves Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_ENVIRONMENT]: `Instruction is not allowed in production`,
+        [PERPETUALS_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
+        [PERPETUALS_ERROR__INVALID_KEEPER]: `Invalid Keeper`,
+        [PERPETUALS_ERROR__INVALID_MINT]: `Invalid mint`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_ACCOUNT]: `Invalid oracle account`,
+        [PERPETUALS_ERROR__INVALID_ORACLE_PRICE]: `Invalid oracle price`,
+        [PERPETUALS_ERROR__INVALID_PERPETUALS_CONFIG]: `Invalid perpetuals config`,
+        [PERPETUALS_ERROR__INVALID_POOL_CONFIG]: `Invalid pool config`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST]: `Invalid position request`,
+        [PERPETUALS_ERROR__INVALID_POSITION_REQUEST_INPUT_ATA]: `Invalid position request input ata`,
+        [PERPETUALS_ERROR__INVALID_POSITION_STATE]: `Invalid position state`,
+        [PERPETUALS_ERROR__INVALID_PRICE_CALC_MODE]: `Invalid Price Calc Mode`,
+        [PERPETUALS_ERROR__INVALID_PULL_ORACLE_PRICE]: `Invalid Pull Oracle Price`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TIME]: `Invalid Request Time`,
+        [PERPETUALS_ERROR__INVALID_REQUEST_TYPE]: `Invalid Request Type`,
+        [PERPETUALS_ERROR__INVALID_TOKEN_LEDGER]: `Invalid token ledger`,
+        [PERPETUALS_ERROR__INVALID_TRIGGER_PRICE]: `Invalid Trigger Price`,
+        [PERPETUALS_ERROR__JUPITER_PROGRAM_MISMATCH]: `Jupiter Program ID mismatch`,
+        [PERPETUALS_ERROR__KEEPER_A_T_A_MISSING]: `Missing keeper ATA`,
+        [PERPETUALS_ERROR__LEDGER_TOKEN_ACCOUNT_DOES_NOT_MATCH]: `Ledger token account does not match`,
+        [PERPETUALS_ERROR__MATH_OVERFLOW]: `Overflow in arithmetic operation`,
+        [PERPETUALS_ERROR__MAX_LEVERAGE]: `Position leverage limit exceeded`,
+        [PERPETUALS_ERROR__MAX_PRICE_SLIPPAGE]: `Price slippage limit exceeded`,
+        [PERPETUALS_ERROR__MISSING_PRICE_SLIPPAGE]: `Missing Price Slippage`,
+        [PERPETUALS_ERROR__MISSING_TRIGGER_PRICE]: `Missing Trigger Price`,
+        [PERPETUALS_ERROR__ORACLE_PRICE_DIFFERENCE_TOO_LARGE]: `Oracle Price Difference Too Large`,
+        [PERPETUALS_ERROR__ORACLE_PUBLISH_TIME_TOO_EARLY]: `Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__PERSONAL_POOL_AMOUNT_LIMIT]: `Personal pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POOL_AMOUNT_LIMIT]: `Pool amount limit exceeded`,
+        [PERPETUALS_ERROR__POSITION_UPDATED_TOO_RECENT]: `Position Updated Too Recent`,
+        [PERPETUALS_ERROR__PRICE_DIFF_TOO_LARGE]: `Price Diff Between Pull and Push Oracle is Too Large`,
+        [PERPETUALS_ERROR__PROGRAM_MISMATCH]: `Program ID mismatch`,
+        [PERPETUALS_ERROR__PULL_ORACLE_NOT_VERIFIED]: `Pull Oracle Not Verified`,
+        [PERPETUALS_ERROR__PULL_ORACLE_PUBLISH_TIME_TOO_EARLY]: `Pull Oracle Publish Time Too Early`,
+        [PERPETUALS_ERROR__REQUEST_UPDATED_TOO_RECENT]: `Request Updated Too Recent`,
+        [PERPETUALS_ERROR__STALE_ORACLE_PRICE]: `Stale oracle price`,
+        [PERPETUALS_ERROR__STALE_PULL_ORACLE_PRICE]: `Stale Pull Oracle Price`,
+        [PERPETUALS_ERROR__SWAP_AMOUNT_MISMATCH]: `Swap amount mismatch`,
+        [PERPETUALS_ERROR__TRIGGER_PRICE_SLIPPAGE]: `Trigger Price Slippage`,
+        [PERPETUALS_ERROR__UNSUPPORTED_ORACLE]: `Unsupported price oracle`,
+        [PERPETUALS_ERROR__UNSUPPORTED_TOKEN]: `Token is not supported`,
+    };
+}
+export function getPerpetualsErrorMessage(code) {
+    if (process.env.NODE_ENV !== 'production') {
+        return perpetualsErrorMessages[code];
+    }
+    return 'Error message not available in production bundles.';
+}
+export function isPerpetualsError(error, transactionMessage, code) {
+    return isProgramError(error, transactionMessage, PERPETUALS_PROGRAM_ADDRESS, code);
+}
diff --git a/node_modules/jup-perps-client/dist/index-patched.js b/node_modules/jup-perps-client/dist/index-patched.js
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index-patched.js
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index-patched.js.bak2 b/node_modules/jup-perps-client/dist/index-patched.js.bak2
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index-patched.js.bak2
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js b/node_modules/jup-perps-client/dist/index.js
index 104297a..45a84d8 100644
--- a/node_modules/jup-perps-client/dist/index.js
+++ b/node_modules/jup-perps-client/dist/index.js
@@ -1,12 +1,9 @@
 /**
- * This code was AUTOGENERATED using the codama library.
- * Please DO NOT EDIT THIS FILE, instead use visitors
- * to add features, then rerun codama to update it.
- *
- * @see https://github.com/codama-idl/codama
+ * Patched index.js - uses explicit file imports instead of directory imports
  */
-export * from './accounts';
-export * from './errors';
-export * from './instructions';
-export * from './programs';
-export * from './types';
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.backup b/node_modules/jup-perps-client/dist/index.js.backup
new file mode 100644
index 0000000..104297a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.backup
@@ -0,0 +1,12 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './accounts';
+export * from './errors';
+export * from './instructions';
+export * from './programs';
+export * from './types';
diff --git a/node_modules/jup-perps-client/dist/index.js.bak10 b/node_modules/jup-perps-client/dist/index.js.bak10
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak10
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.bak2 b/node_modules/jup-perps-client/dist/index.js.bak2
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak2
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.bak6 b/node_modules/jup-perps-client/dist/index.js.bak6
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak6
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.bak7 b/node_modules/jup-perps-client/dist/index.js.bak7
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak7
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.bak8 b/node_modules/jup-perps-client/dist/index.js.bak8
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak8
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/index.js.bak9 b/node_modules/jup-perps-client/dist/index.js.bak9
new file mode 100644
index 0000000..45a84d8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/index.js.bak9
@@ -0,0 +1,9 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './accounts/index.js';
+export * from './errors/index.js';
+export * from './instructions/index.js';
+export * from './programs/index.js';
+export * from './types/index.js';
+
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js b/node_modules/jup-perps-client/dist/instructions/addCustody.js
index ce41553..ef6d862 100644
--- a/node_modules/jup-perps-client/dist/instructions/addCustody.js
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
 export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
     247, 254, 126, 17, 26, 6, 215, 117,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak10 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak10
new file mode 100644
index 0000000..64808d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak10
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak2 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak2
new file mode 100644
index 0000000..ce41553
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak2
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak6 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak6
new file mode 100644
index 0000000..0ebdec9
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak6
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak7 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak7
new file mode 100644
index 0000000..64808d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak7
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak8 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak8
new file mode 100644
index 0000000..64808d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak8
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak9 b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak9
new file mode 100644
index 0000000..64808d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addCustody.js.bak9
@@ -0,0 +1,150 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const ADD_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    247, 254, 126, 17, 26, 6, 215, 117,
+]);
+export function getAddCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_CUSTODY_DISCRIMINATOR);
+}
+export function getAddCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['isStable', getBooleanEncoder()],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_CUSTODY_DISCRIMINATOR }));
+}
+export function getAddCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['isStable', getBooleanDecoder()],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getAddCustodyInstructionDataCodec() {
+    return combineCodec(getAddCustodyInstructionDataEncoder(), getAddCustodyInstructionDataDecoder());
+}
+export function getAddCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyTokenMint: {
+            value: input.custodyTokenMint ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddCustodyInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js
index 3283cfe..bf25c37 100644
--- a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
     228, 162, 78, 28, 70, 219, 116, 115,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak10
new file mode 100644
index 0000000..d3a77d3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak10
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak2
new file mode 100644
index 0000000..3283cfe
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak2
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak6
new file mode 100644
index 0000000..3283cfe
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak6
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak7
new file mode 100644
index 0000000..d3a77d3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak7
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak8
new file mode 100644
index 0000000..d3a77d3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak8
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak9
new file mode 100644
index 0000000..d3a77d3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addLiquidity2.js.bak9
@@ -0,0 +1,130 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const ADD_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    228, 162, 78, 28, 70, 219, 116, 115,
+]);
+export function getAddLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getAddLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+        ['minLpAmountOut', getU64Encoder()],
+        ['tokenAmountPreSwap', getOptionEncoder(getU64Encoder())],
+    ]), (value) => ({ ...value, discriminator: ADD_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getAddLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+        ['minLpAmountOut', getU64Decoder()],
+        ['tokenAmountPreSwap', getOptionDecoder(getU64Decoder())],
+    ]);
+}
+export function getAddLiquidity2InstructionDataCodec() {
+    return combineCodec(getAddLiquidity2InstructionDataEncoder(), getAddLiquidity2InstructionDataDecoder());
+}
+export function getAddLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getAddLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getAddLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js b/node_modules/jup-perps-client/dist/instructions/addPool.js
index 9bfcbdc..f0666e8 100644
--- a/node_modules/jup-perps-client/dist/instructions/addPool.js
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
 export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
     115, 230, 212, 211, 175, 49, 39, 169,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak10 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak10
new file mode 100644
index 0000000..05ebd73
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak10
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak2 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak2
new file mode 100644
index 0000000..9bfcbdc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak2
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak6 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak6
new file mode 100644
index 0000000..6c6ad8e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak6
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak7 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak7
new file mode 100644
index 0000000..05ebd73
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak7
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak8 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak8
new file mode 100644
index 0000000..05ebd73
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak8
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/addPool.js.bak9 b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak9
new file mode 100644
index 0000000..05ebd73
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/addPool.js.bak9
@@ -0,0 +1,114 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const ADD_POOL_DISCRIMINATOR = new Uint8Array([
+    115, 230, 212, 211, 175, 49, 39, 169,
+]);
+export function getAddPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(ADD_POOL_DISCRIMINATOR);
+}
+export function getAddPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['limit', getLimitEncoder()],
+        ['fees', getFeesEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: ADD_POOL_DISCRIMINATOR }));
+}
+export function getAddPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['limit', getLimitDecoder()],
+        ['fees', getFeesDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getAddPoolInstructionDataCodec() {
+    return combineCodec(getAddPoolInstructionDataEncoder(), getAddPoolInstructionDataDecoder());
+}
+export function getAddPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getAddPoolInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseAddPoolInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getAddPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js
index 193a3e7..8d24fb0 100644
--- a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
     40, 105, 217, 188, 220, 45, 109, 110,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak10 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak10
new file mode 100644
index 0000000..c6a08ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak10
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak2 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak2
new file mode 100644
index 0000000..193a3e7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak2
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak6 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak6
new file mode 100644
index 0000000..193a3e7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak6
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak7 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak7
new file mode 100644
index 0000000..c6a08ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak7
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak8 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak8
new file mode 100644
index 0000000..c6a08ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak8
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak9 b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak9
new file mode 100644
index 0000000..c6a08ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/closePositionRequest.js.bak9
@@ -0,0 +1,108 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CLOSE_POSITION_REQUEST_DISCRIMINATOR = new Uint8Array([
+    40, 105, 217, 188, 220, 45, 109, 110,
+]);
+export function getClosePositionRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CLOSE_POSITION_REQUEST_DISCRIMINATOR);
+}
+export function getClosePositionRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: CLOSE_POSITION_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getClosePositionRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getClosePositionRequestInstructionDataCodec() {
+    return combineCodec(getClosePositionRequestInstructionDataEncoder(), getClosePositionRequestInstructionDataDecoder());
+}
+export function getClosePositionRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        ownerAta: { value: input.ownerAta ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.ownerAta),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getClosePositionRequestInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseClosePositionRequestInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextOptionalAccount(),
+            owner: getNextAccount(),
+            ownerAta: getNextOptionalAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getClosePositionRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js
index 976c95f..3bb637c 100644
--- a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
 export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
     return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak10 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak10
new file mode 100644
index 0000000..00a8d99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak10
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak2 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak2
new file mode 100644
index 0000000..976c95f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak2
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak6 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak6
new file mode 100644
index 0000000..976c95f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak6
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak7 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak7
new file mode 100644
index 0000000..00a8d99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak7
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak8 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak8
new file mode 100644
index 0000000..00a8d99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak8
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak9 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak9
new file mode 100644
index 0000000..00a8d99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionMarketRequest.js.bak9
@@ -0,0 +1,153 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79]);
+export function getCreateDecreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionMarketRequestInstructionDataEncoder(), getCreateDecreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateDecreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js
index b22cdbb..ff50636 100644
--- a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
 export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
     105, 64, 201, 82, 250, 14, 109, 77,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak10
new file mode 100644
index 0000000..5014945
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak10
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak2
new file mode 100644
index 0000000..b22cdbb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak2
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak6
new file mode 100644
index 0000000..ea7fcc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak6
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak7
new file mode 100644
index 0000000..5014945
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak7
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak8
new file mode 100644
index 0000000..5014945
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak8
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak9
new file mode 100644
index 0000000..5014945
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createDecreasePositionRequest2.js.bak9
@@ -0,0 +1,174 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getRequestTypeDecoder, getRequestTypeEncoder, } from '../types/index.js';
+export const CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    105, 64, 201, 82, 250, 14, 109, 77,
+]);
+export function getCreateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getCreateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['requestType', getRequestTypeEncoder()],
+        ['priceSlippage', getOptionEncoder(getU64Encoder())],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['triggerPrice', getOptionEncoder(getU64Encoder())],
+        ['triggerAboveThreshold', getOptionEncoder(getBooleanEncoder())],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getCreateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['requestType', getRequestTypeDecoder()],
+        ['priceSlippage', getOptionDecoder(getU64Decoder())],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['triggerPrice', getOptionDecoder(getU64Decoder())],
+        ['triggerAboveThreshold', getOptionDecoder(getBooleanDecoder())],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getCreateDecreasePositionRequest2InstructionDataEncoder(), getCreateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getCreateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js
index 1a36a9f..ca8ad29 100644
--- a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getSideDecoder, getSideEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
 export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
 export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
     return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak10 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak10
new file mode 100644
index 0000000..615bf76
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak10
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak2 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak2
new file mode 100644
index 0000000..1a36a9f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak2
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak6 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak6
new file mode 100644
index 0000000..1a590a1
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak6
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak7 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak7
new file mode 100644
index 0000000..615bf76
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak7
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak8 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak8
new file mode 100644
index 0000000..615bf76
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak8
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak9 b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak9
new file mode 100644
index 0000000..615bf76
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createIncreasePositionMarketRequest.js.bak9
@@ -0,0 +1,151 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR = new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56]);
+export function getCreateIncreasePositionMarketRequestDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['jupiterMinimumOut', getOptionEncoder(getU64Encoder())],
+        ['counter', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_INCREASE_POSITION_MARKET_REQUEST_DISCRIMINATOR,
+    }));
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['jupiterMinimumOut', getOptionDecoder(getU64Decoder())],
+        ['counter', getU64Decoder()],
+    ]);
+}
+export function getCreateIncreasePositionMarketRequestInstructionDataCodec() {
+    return combineCodec(getCreateIncreasePositionMarketRequestInstructionDataEncoder(), getCreateIncreasePositionMarketRequestInstructionDataDecoder());
+}
+export function getCreateIncreasePositionMarketRequestInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getCreateIncreasePositionMarketRequestInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateIncreasePositionMarketRequestInstruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getCreateIncreasePositionMarketRequestInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js
index 971b398..337b117 100644
--- a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
     232, 242, 197, 253, 240, 143, 129, 52,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak10 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak10
new file mode 100644
index 0000000..6034de6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak10
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak2 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak2
new file mode 100644
index 0000000..971b398
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak2
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak6 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak6
new file mode 100644
index 0000000..971b398
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak6
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak7 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak7
new file mode 100644
index 0000000..6034de6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak7
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak8 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak8
new file mode 100644
index 0000000..6034de6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak8
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak9 b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak9
new file mode 100644
index 0000000..6034de6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenLedger.js.bak9
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    232, 242, 197, 253, 240, 143, 129, 52,
+]);
+export function getCreateTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getCreateTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getCreateTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getCreateTokenLedgerInstructionDataCodec() {
+    return combineCodec(getCreateTokenLedgerInstructionDataEncoder(), getCreateTokenLedgerInstructionDataDecoder());
+}
+export function getCreateTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        payer: { value: input.payer ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.payer),
+            getAccountMeta(accounts.systemProgram),
+        ],
+        programAddress,
+        data: getCreateTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseCreateTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            payer: getNextAccount(),
+            systemProgram: getNextAccount(),
+        },
+        data: getCreateTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js
index 9ecef61..d793e86 100644
--- a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
     221, 80, 176, 37, 153, 188, 160, 68,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak10 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak10
new file mode 100644
index 0000000..c1ed8b6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak10
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak2 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak2
new file mode 100644
index 0000000..9ecef61
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak2
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak6 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak6
new file mode 100644
index 0000000..9ecef61
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak6
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak7 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak7
new file mode 100644
index 0000000..c1ed8b6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak7
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak8 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak8
new file mode 100644
index 0000000..c1ed8b6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak8
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak9 b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak9
new file mode 100644
index 0000000..c1ed8b6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/createTokenMetadata.js.bak9
@@ -0,0 +1,120 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { addDecoderSizePrefix, addEncoderSizePrefix, combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getUtf8Decoder, getUtf8Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const CREATE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
+    221, 80, 176, 37, 153, 188, 160, 68,
+]);
+export function getCreateTokenMetadataDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_TOKEN_METADATA_DISCRIMINATOR);
+}
+export function getCreateTokenMetadataInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+        ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: CREATE_TOKEN_METADATA_DISCRIMINATOR,
+    }));
+}
+export function getCreateTokenMetadataInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+        ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
+    ]);
+}
+export function getCreateTokenMetadataInstructionDataCodec() {
+    return combineCodec(getCreateTokenMetadataInstructionDataEncoder(), getCreateTokenMetadataInstructionDataDecoder());
+}
+export function getCreateTokenMetadataInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        metadata: { value: input.metadata ?? null, isWritable: true },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+        tokenMetadataProgram: {
+            value: input.tokenMetadataProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenMetadataProgram.value) {
+        accounts.tokenMetadataProgram.value =
+            'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.metadata),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenMetadataProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getCreateTokenMetadataInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseCreateTokenMetadataInstruction(instruction) {
+    if (instruction.accounts.length < 9) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            metadata: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenMetadataProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getCreateTokenMetadataInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js
index 9263301..ae9645e 100644
--- a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
     185, 161, 114, 175, 96, 148, 3, 170,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak10 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak10
new file mode 100644
index 0000000..81b5ed5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak10
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak2 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak2
new file mode 100644
index 0000000..9263301
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak2
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak6 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak6
new file mode 100644
index 0000000..9263301
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak6
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak7 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak7
new file mode 100644
index 0000000..81b5ed5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak7
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak8 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak8
new file mode 100644
index 0000000..81b5ed5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak8
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak9 b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak9
new file mode 100644
index 0000000..81b5ed5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePosition4.js.bak9
@@ -0,0 +1,144 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    185, 161, 114, 175, 96, 148, 3, 170,
+]);
+export function getDecreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION4_DISCRIMINATOR);
+}
+export function getDecreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: DECREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getDecreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePosition4InstructionDataCodec() {
+    return combineCodec(getDecreasePosition4InstructionDataEncoder(), getDecreasePosition4InstructionDataDecoder());
+}
+export function getDecreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 18) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js
index c775e6e..52ab078 100644
--- a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
 export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
     return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak10 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak10
new file mode 100644
index 0000000..21a15f3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak10
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak2 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak2
new file mode 100644
index 0000000..c775e6e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak2
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak6 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak6
new file mode 100644
index 0000000..c775e6e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak6
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak7 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak7
new file mode 100644
index 0000000..21a15f3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak7
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak8 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak8
new file mode 100644
index 0000000..21a15f3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak8
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak9 b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak9
new file mode 100644
index 0000000..21a15f3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/decreasePositionWithInternalSwap.js.bak9
@@ -0,0 +1,169 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38]);
+export function getDecreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: DECREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getDecreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getDecreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getDecreasePositionWithInternalSwapInstructionDataEncoder(), getDecreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getDecreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getDecreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseDecreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            owner: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getDecreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js
index 27713d6..5ace274 100644
--- a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
     109, 157, 55, 169, 8, 81, 4, 118,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak10
new file mode 100644
index 0000000..f2d7546
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak10
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak2
new file mode 100644
index 0000000..27713d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak2
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak6
new file mode 100644
index 0000000..27713d6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak6
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak7
new file mode 100644
index 0000000..f2d7546
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak7
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak8
new file mode 100644
index 0000000..f2d7546
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak8
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak9
new file mode 100644
index 0000000..f2d7546
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAddLiquidityAmountAndFee2.js.bak9
@@ -0,0 +1,94 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([
+    109, 157, 55, 169, 8, 81, 4, 118,
+]);
+export function getGetAddLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['tokenAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ADD_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['tokenAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetAddLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetAddLiquidityAmountAndFee2InstructionDataEncoder(), getGetAddLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetAddLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetAddLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAddLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetAddLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js
index d23b4ca..86707af 100644
--- a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
 export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
     193, 210, 13, 249, 113, 149, 29, 84,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak10
new file mode 100644
index 0000000..9e7d436
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak10
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak2
new file mode 100644
index 0000000..d23b4ca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak2
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak6
new file mode 100644
index 0000000..2810249
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak6
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak7
new file mode 100644
index 0000000..9e7d436
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak7
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak8
new file mode 100644
index 0000000..9e7d436
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak8
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak9
new file mode 100644
index 0000000..9e7d436
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getAssetsUnderManagement2.js.bak9
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPriceCalcModeDecoder, getPriceCalcModeEncoder, } from '../types/index.js';
+export const GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR = new Uint8Array([
+    193, 210, 13, 249, 113, 149, 29, 84,
+]);
+export function getGetAssetsUnderManagement2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR);
+}
+export function getGetAssetsUnderManagement2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['mode', getOptionEncoder(getPriceCalcModeEncoder())],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_ASSETS_UNDER_MANAGEMENT2_DISCRIMINATOR,
+    }));
+}
+export function getGetAssetsUnderManagement2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['mode', getOptionDecoder(getPriceCalcModeDecoder())],
+    ]);
+}
+export function getGetAssetsUnderManagement2InstructionDataCodec() {
+    return combineCodec(getGetAssetsUnderManagement2InstructionDataEncoder(), getGetAssetsUnderManagement2InstructionDataDecoder());
+}
+export function getGetAssetsUnderManagement2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getGetAssetsUnderManagement2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetAssetsUnderManagement2Instruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getGetAssetsUnderManagement2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js
index b663f9e..979d246 100644
--- a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
 export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
     return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak10
new file mode 100644
index 0000000..d099863
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak10
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak2
new file mode 100644
index 0000000..b663f9e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak2
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak6
new file mode 100644
index 0000000..b663f9e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak6
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak7
new file mode 100644
index 0000000..d099863
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak7
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak8
new file mode 100644
index 0000000..d099863
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak8
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak9
new file mode 100644
index 0000000..d099863
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/getRemoveLiquidityAmountAndFee2.js.bak9
@@ -0,0 +1,92 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR = new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142]);
+export function getGetRemoveLiquidityAmountAndFee2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: GET_REMOVE_LIQUIDITY_AMOUNT_AND_FEE2_DISCRIMINATOR,
+    }));
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+    ]);
+}
+export function getGetRemoveLiquidityAmountAndFee2InstructionDataCodec() {
+    return combineCodec(getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder(), getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder());
+}
+export function getGetRemoveLiquidityAmountAndFee2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.lpTokenMint),
+        ],
+        programAddress,
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseGetRemoveLiquidityAmountAndFee2Instruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+        },
+        data: getGetRemoveLiquidityAmountAndFee2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js
index 48e660b..8679432 100644
--- a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
     67, 147, 53, 23, 43, 57, 16, 67,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak10 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak10
new file mode 100644
index 0000000..19b55d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak10
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak2 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak2
new file mode 100644
index 0000000..48e660b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak2
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak6 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak6
new file mode 100644
index 0000000..48e660b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak6
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak7 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak7
new file mode 100644
index 0000000..19b55d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak7
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak8 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak8
new file mode 100644
index 0000000..19b55d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak8
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak9 b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak9
new file mode 100644
index 0000000..19b55d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePosition4.js.bak9
@@ -0,0 +1,135 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION4_DISCRIMINATOR = new Uint8Array([
+    67, 147, 53, 23, 43, 57, 16, 67,
+]);
+export function getIncreasePosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION4_DISCRIMINATOR);
+}
+export function getIncreasePosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: INCREASE_POSITION4_DISCRIMINATOR }));
+}
+export function getIncreasePosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePosition4InstructionDataCodec() {
+    return combineCodec(getIncreasePosition4InstructionDataEncoder(), getIncreasePosition4InstructionDataDecoder());
+}
+export function getIncreasePosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePosition4Instruction(instruction) {
+    if (instruction.accounts.length < 16) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js
index 8e05804..ee8d566 100644
--- a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
     26, 136, 225, 217, 22, 21, 83, 20,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak10 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak10
new file mode 100644
index 0000000..ce31ee3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak10
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak2 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak2
new file mode 100644
index 0000000..8e05804
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak2
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak6 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak6
new file mode 100644
index 0000000..8e05804
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak6
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak7 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak7
new file mode 100644
index 0000000..ce31ee3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak7
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak8 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak8
new file mode 100644
index 0000000..ce31ee3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak8
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak9 b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak9
new file mode 100644
index 0000000..ce31ee3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionPreSwap.js.bak9
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR = new Uint8Array([
+    26, 136, 225, 217, 22, 21, 83, 20,
+]);
+export function getIncreasePositionPreSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionPreSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_PRE_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionPreSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionPreSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionPreSwapInstructionDataEncoder(), getIncreasePositionPreSwapInstructionDataDecoder());
+}
+export function getIncreasePositionPreSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        keeperAta: { value: input.keeperAta ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: false },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: false,
+        },
+        instruction: { value: input.instruction ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.keeperAta),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.instruction),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionPreSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionPreSwapInstruction(instruction) {
+    if (instruction.accounts.length < 11) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            keeperAta: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            instruction: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionPreSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js
index 1287f14..34c57be 100644
--- a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
 export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
     return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak10 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak10
new file mode 100644
index 0000000..2c989d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak10
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak2 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak2
new file mode 100644
index 0000000..1287f14
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak2
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak6 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak6
new file mode 100644
index 0000000..1287f14
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak6
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak7 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak7
new file mode 100644
index 0000000..2c989d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak7
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak8 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak8
new file mode 100644
index 0000000..2c989d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak8
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak9 b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak9
new file mode 100644
index 0000000..2c989d0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/increasePositionWithInternalSwap.js.bak9
@@ -0,0 +1,160 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR = new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112]);
+export function getIncreasePositionWithInternalSwapDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: INCREASE_POSITION_WITH_INTERNAL_SWAP_DISCRIMINATOR,
+    }));
+}
+export function getIncreasePositionWithInternalSwapInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getIncreasePositionWithInternalSwapInstructionDataCodec() {
+    return combineCodec(getIncreasePositionWithInternalSwapInstructionDataEncoder(), getIncreasePositionWithInternalSwapInstructionDataDecoder());
+}
+export function getIncreasePositionWithInternalSwapInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getIncreasePositionWithInternalSwapInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseIncreasePositionWithInternalSwapInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getIncreasePositionWithInternalSwapInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/index-patched.js b/node_modules/jup-perps-client/dist/instructions/index-patched.js
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index-patched.js
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js b/node_modules/jup-perps-client/dist/instructions/index.js
index c4ee374..a746c5a 100644
--- a/node_modules/jup-perps-client/dist/instructions/index.js
+++ b/node_modules/jup-perps-client/dist/instructions/index.js
@@ -5,44 +5,44 @@
  *
  * @see https://github.com/codama-idl/codama
  */
-export * from './addCustody';
-export * from './addLiquidity2';
-export * from './addPool';
-export * from './closePositionRequest';
-export * from './createDecreasePositionMarketRequest';
-export * from './createDecreasePositionRequest2';
-export * from './createIncreasePositionMarketRequest';
-export * from './createTokenLedger';
-export * from './createTokenMetadata';
-export * from './decreasePosition4';
-export * from './decreasePositionWithInternalSwap';
-export * from './getAddLiquidityAmountAndFee2';
-export * from './getAssetsUnderManagement2';
-export * from './getRemoveLiquidityAmountAndFee2';
-export * from './increasePosition4';
-export * from './increasePositionPreSwap';
-export * from './increasePositionWithInternalSwap';
-export * from './init';
-export * from './instantCreateLimitOrder';
-export * from './instantCreateTpsl';
-export * from './instantDecreasePosition';
-export * from './instantIncreasePosition';
-export * from './instantUpdateLimitOrder';
-export * from './instantUpdateTpsl';
-export * from './liquidateFullPosition4';
-export * from './operatorSetCustodyConfig';
-export * from './operatorSetPoolConfig';
-export * from './reallocCustody';
-export * from './reallocPool';
-export * from './refreshAssetsUnderManagement';
-export * from './removeLiquidity2';
-export * from './setCustodyConfig';
-export * from './setPerpetualsConfig';
-export * from './setPoolConfig';
-export * from './setTestTime';
-export * from './setTokenLedger';
-export * from './swap2';
-export * from './testInit';
-export * from './transferAdmin';
-export * from './updateDecreasePositionRequest2';
-export * from './withdrawFees2';
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.backup2 b/node_modules/jup-perps-client/dist/instructions/index.js.backup2
new file mode 100644
index 0000000..c4ee374
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.backup2
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody';
+export * from './addLiquidity2';
+export * from './addPool';
+export * from './closePositionRequest';
+export * from './createDecreasePositionMarketRequest';
+export * from './createDecreasePositionRequest2';
+export * from './createIncreasePositionMarketRequest';
+export * from './createTokenLedger';
+export * from './createTokenMetadata';
+export * from './decreasePosition4';
+export * from './decreasePositionWithInternalSwap';
+export * from './getAddLiquidityAmountAndFee2';
+export * from './getAssetsUnderManagement2';
+export * from './getRemoveLiquidityAmountAndFee2';
+export * from './increasePosition4';
+export * from './increasePositionPreSwap';
+export * from './increasePositionWithInternalSwap';
+export * from './init';
+export * from './instantCreateLimitOrder';
+export * from './instantCreateTpsl';
+export * from './instantDecreasePosition';
+export * from './instantIncreasePosition';
+export * from './instantUpdateLimitOrder';
+export * from './instantUpdateTpsl';
+export * from './liquidateFullPosition4';
+export * from './operatorSetCustodyConfig';
+export * from './operatorSetPoolConfig';
+export * from './reallocCustody';
+export * from './reallocPool';
+export * from './refreshAssetsUnderManagement';
+export * from './removeLiquidity2';
+export * from './setCustodyConfig';
+export * from './setPerpetualsConfig';
+export * from './setPoolConfig';
+export * from './setTestTime';
+export * from './setTokenLedger';
+export * from './swap2';
+export * from './testInit';
+export * from './transferAdmin';
+export * from './updateDecreasePositionRequest2';
+export * from './withdrawFees2';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak10 b/node_modules/jup-perps-client/dist/instructions/index.js.bak10
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak10
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak2 b/node_modules/jup-perps-client/dist/instructions/index.js.bak2
new file mode 100644
index 0000000..c4ee374
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak2
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody';
+export * from './addLiquidity2';
+export * from './addPool';
+export * from './closePositionRequest';
+export * from './createDecreasePositionMarketRequest';
+export * from './createDecreasePositionRequest2';
+export * from './createIncreasePositionMarketRequest';
+export * from './createTokenLedger';
+export * from './createTokenMetadata';
+export * from './decreasePosition4';
+export * from './decreasePositionWithInternalSwap';
+export * from './getAddLiquidityAmountAndFee2';
+export * from './getAssetsUnderManagement2';
+export * from './getRemoveLiquidityAmountAndFee2';
+export * from './increasePosition4';
+export * from './increasePositionPreSwap';
+export * from './increasePositionWithInternalSwap';
+export * from './init';
+export * from './instantCreateLimitOrder';
+export * from './instantCreateTpsl';
+export * from './instantDecreasePosition';
+export * from './instantIncreasePosition';
+export * from './instantUpdateLimitOrder';
+export * from './instantUpdateTpsl';
+export * from './liquidateFullPosition4';
+export * from './operatorSetCustodyConfig';
+export * from './operatorSetPoolConfig';
+export * from './reallocCustody';
+export * from './reallocPool';
+export * from './refreshAssetsUnderManagement';
+export * from './removeLiquidity2';
+export * from './setCustodyConfig';
+export * from './setPerpetualsConfig';
+export * from './setPoolConfig';
+export * from './setTestTime';
+export * from './setTokenLedger';
+export * from './swap2';
+export * from './testInit';
+export * from './transferAdmin';
+export * from './updateDecreasePositionRequest2';
+export * from './withdrawFees2';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak6 b/node_modules/jup-perps-client/dist/instructions/index.js.bak6
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak6
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak7 b/node_modules/jup-perps-client/dist/instructions/index.js.bak7
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak7
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak8 b/node_modules/jup-perps-client/dist/instructions/index.js.bak8
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak8
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/index.js.bak9 b/node_modules/jup-perps-client/dist/instructions/index.js.bak9
new file mode 100644
index 0000000..a746c5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/index.js.bak9
@@ -0,0 +1,48 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './addCustody.js';
+export * from './addLiquidity2.js';
+export * from './addPool.js';
+export * from './closePositionRequest.js';
+export * from './createDecreasePositionMarketRequest.js';
+export * from './createDecreasePositionRequest2.js';
+export * from './createIncreasePositionMarketRequest.js';
+export * from './createTokenLedger.js';
+export * from './createTokenMetadata.js';
+export * from './decreasePosition4.js';
+export * from './decreasePositionWithInternalSwap.js';
+export * from './getAddLiquidityAmountAndFee2.js';
+export * from './getAssetsUnderManagement2.js';
+export * from './getRemoveLiquidityAmountAndFee2.js';
+export * from './increasePosition4.js';
+export * from './increasePositionPreSwap.js';
+export * from './increasePositionWithInternalSwap.js';
+export * from './init.js';
+export * from './instantCreateLimitOrder.js';
+export * from './instantCreateTpsl.js';
+export * from './instantDecreasePosition.js';
+export * from './instantIncreasePosition.js';
+export * from './instantUpdateLimitOrder.js';
+export * from './instantUpdateTpsl.js';
+export * from './liquidateFullPosition4.js';
+export * from './operatorSetCustodyConfig.js';
+export * from './operatorSetPoolConfig.js';
+export * from './reallocCustody.js';
+export * from './reallocPool.js';
+export * from './refreshAssetsUnderManagement.js';
+export * from './removeLiquidity2.js';
+export * from './setCustodyConfig.js';
+export * from './setPerpetualsConfig.js';
+export * from './setPoolConfig.js';
+export * from './setTestTime.js';
+export * from './setTokenLedger.js';
+export * from './swap2.js';
+export * from './testInit.js';
+export * from './transferAdmin.js';
+export * from './updateDecreasePositionRequest2.js';
+export * from './withdrawFees2.js';
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js b/node_modules/jup-perps-client/dist/instructions/init.js
index 11b3e7d..8991274 100644
--- a/node_modules/jup-perps-client/dist/instructions/init.js
+++ b/node_modules/jup-perps-client/dist/instructions/init.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INIT_DISCRIMINATOR = new Uint8Array([
     220, 59, 207, 236, 108, 250, 47, 100,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak10 b/node_modules/jup-perps-client/dist/instructions/init.js.bak10
new file mode 100644
index 0000000..73660cc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak10
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak2 b/node_modules/jup-perps-client/dist/instructions/init.js.bak2
new file mode 100644
index 0000000..11b3e7d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak2
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak6 b/node_modules/jup-perps-client/dist/instructions/init.js.bak6
new file mode 100644
index 0000000..11b3e7d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak6
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak7 b/node_modules/jup-perps-client/dist/instructions/init.js.bak7
new file mode 100644
index 0000000..73660cc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak7
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak8 b/node_modules/jup-perps-client/dist/instructions/init.js.bak8
new file mode 100644
index 0000000..73660cc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak8
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/init.js.bak9 b/node_modules/jup-perps-client/dist/instructions/init.js.bak9
new file mode 100644
index 0000000..73660cc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/init.js.bak9
@@ -0,0 +1,124 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INIT_DISCRIMINATOR = new Uint8Array([
+    220, 59, 207, 236, 108, 250, 47, 100,
+]);
+export function getInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_DISCRIMINATOR);
+}
+export function getInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: INIT_DISCRIMINATOR }));
+}
+export function getInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getInitInstructionDataCodec() {
+    return combineCodec(getInitInstructionDataEncoder(), getInitInstructionDataDecoder());
+}
+export function getInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        perpetualsProgram: {
+            value: input.perpetualsProgram ?? null,
+            isWritable: false,
+        },
+        perpetualsProgramData: {
+            value: input.perpetualsProgramData ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.perpetualsProgram),
+            getAccountMeta(accounts.perpetualsProgramData),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInitInstruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            perpetualsProgram: getNextAccount(),
+            perpetualsProgramData: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js
index da0eda8..bcdc07d 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getSideDecoder, getSideEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
 export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
     194, 37, 195, 123, 40, 127, 126, 156,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak10
new file mode 100644
index 0000000..805f98d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak10
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak2
new file mode 100644
index 0000000..da0eda8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak2
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak6
new file mode 100644
index 0000000..afa0b84
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak6
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak7
new file mode 100644
index 0000000..805f98d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak7
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak8
new file mode 100644
index 0000000..805f98d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak8
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak9
new file mode 100644
index 0000000..805f98d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateLimitOrder.js.bak9
@@ -0,0 +1,173 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    194, 37, 195, 123, 40, 127, 126, 156,
+]);
+export function getInstantCreateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantCreateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getU64Encoder()],
+        ['side', getSideEncoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_CREATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantCreateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getU64Decoder()],
+        ['side', getSideDecoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantCreateLimitOrderInstructionDataEncoder(), getInstantCreateLimitOrderInstructionDataDecoder());
+}
+export function getInstantCreateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: true },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        inputMint: { value: input.inputMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.inputMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            inputMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js
index 5577e5a..c088139 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
     117, 98, 66, 127, 30, 50, 73, 185,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak10
new file mode 100644
index 0000000..23ddee0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak10
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak2
new file mode 100644
index 0000000..5577e5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak2
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak6
new file mode 100644
index 0000000..5577e5a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak6
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak7
new file mode 100644
index 0000000..23ddee0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak7
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak8
new file mode 100644
index 0000000..23ddee0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak8
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak9
new file mode 100644
index 0000000..23ddee0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantCreateTpsl.js.bak9
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_CREATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    117, 98, 66, 127, 30, 50, 73, 185,
+]);
+export function getInstantCreateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_CREATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantCreateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['triggerAboveThreshold', getBooleanEncoder()],
+        ['entirePosition', getBooleanEncoder()],
+        ['counter', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_CREATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantCreateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['triggerAboveThreshold', getBooleanDecoder()],
+        ['entirePosition', getBooleanDecoder()],
+        ['counter', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantCreateTpslInstructionDataCodec() {
+    return combineCodec(getInstantCreateTpslInstructionDataEncoder(), getInstantCreateTpslInstructionDataDecoder());
+}
+export function getInstantCreateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        positionRequestAta: {
+            value: input.positionRequestAta ?? null,
+            isWritable: true,
+        },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: false,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.positionRequestAta),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantCreateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantCreateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            positionRequestAta: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantCreateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js
index 22532ef..8ceb9d5 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
     46, 23, 240, 44, 30, 138, 94, 140,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak10
new file mode 100644
index 0000000..557206c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak10
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak2
new file mode 100644
index 0000000..22532ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak2
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak6
new file mode 100644
index 0000000..22532ef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak6
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak7
new file mode 100644
index 0000000..557206c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak7
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak8
new file mode 100644
index 0000000..557206c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak8
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak9
new file mode 100644
index 0000000..557206c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantDecreasePosition.js.bak9
@@ -0,0 +1,186 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_DECREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    46, 23, 240, 44, 30, 138, 94, 140,
+]);
+export function getInstantDecreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_DECREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantDecreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['collateralUsdDelta', getU64Encoder()],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['entirePosition', getOptionEncoder(getBooleanEncoder())],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_DECREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantDecreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['collateralUsdDelta', getU64Decoder()],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['entirePosition', getOptionDecoder(getBooleanDecoder())],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantDecreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantDecreasePositionInstructionDataEncoder(), getInstantDecreasePositionInstructionDataDecoder());
+}
+export function getInstantDecreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        desiredMint: { value: input.desiredMint ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        associatedTokenProgram: {
+            value: input.associatedTokenProgram ?? null,
+            isWritable: false,
+        },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.desiredMint),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.associatedTokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantDecreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantDecreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 22) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            desiredMint: getNextAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            associatedTokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantDecreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js
index 285bb44..e8c39b3 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getSideDecoder, getSideEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
 export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
     164, 126, 68, 182, 223, 166, 64, 183,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak10
new file mode 100644
index 0000000..c9a06bb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak10
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak2
new file mode 100644
index 0000000..285bb44
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak2
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak6
new file mode 100644
index 0000000..2b26f31
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak6
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak7
new file mode 100644
index 0000000..c9a06bb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak7
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak8
new file mode 100644
index 0000000..c9a06bb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak8
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak9
new file mode 100644
index 0000000..c9a06bb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantIncreasePosition.js.bak9
@@ -0,0 +1,172 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getOptionDecoder, getOptionEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getSideDecoder, getSideEncoder, } from '../types/index.js';
+export const INSTANT_INCREASE_POSITION_DISCRIMINATOR = new Uint8Array([
+    164, 126, 68, 182, 223, 166, 64, 183,
+]);
+export function getInstantIncreasePositionDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_INCREASE_POSITION_DISCRIMINATOR);
+}
+export function getInstantIncreasePositionInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['collateralTokenDelta', getOptionEncoder(getU64Encoder())],
+        ['side', getSideEncoder()],
+        ['priceSlippage', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_INCREASE_POSITION_DISCRIMINATOR,
+    }));
+}
+export function getInstantIncreasePositionInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['collateralTokenDelta', getOptionDecoder(getU64Decoder())],
+        ['side', getSideDecoder()],
+        ['priceSlippage', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantIncreasePositionInstructionDataCodec() {
+    return combineCodec(getInstantIncreasePositionInstructionDataEncoder(), getInstantIncreasePositionInstructionDataDecoder());
+}
+export function getInstantIncreasePositionInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: true },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: false },
+        referral: { value: input.referral ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.referral),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantIncreasePositionInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantIncreasePositionInstruction(instruction) {
+    if (instruction.accounts.length < 20) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    const getNextOptionalAccount = () => {
+        const accountMeta = getNextAccount();
+        return accountMeta.address === PERPETUALS_PROGRAM_ADDRESS
+            ? undefined
+            : accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            tokenLedger: getNextOptionalAccount(),
+            referral: getNextOptionalAccount(),
+            tokenProgram: getNextAccount(),
+            systemProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantIncreasePositionInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js
index faafa99..0997bfa 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
     136, 245, 229, 58, 121, 141, 12, 207,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak10
new file mode 100644
index 0000000..c55098b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak10
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak2
new file mode 100644
index 0000000..faafa99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak2
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak6
new file mode 100644
index 0000000..faafa99
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak6
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak7
new file mode 100644
index 0000000..c55098b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak7
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak8
new file mode 100644
index 0000000..c55098b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak8
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak9
new file mode 100644
index 0000000..c55098b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateLimitOrder.js.bak9
@@ -0,0 +1,110 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
+    136, 245, 229, 58, 121, 141, 12, 207,
+]);
+export function getInstantUpdateLimitOrderDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR);
+}
+export function getInstantUpdateLimitOrderInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
+    }));
+}
+export function getInstantUpdateLimitOrderInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateLimitOrderInstructionDataCodec() {
+    return combineCodec(getInstantUpdateLimitOrderInstructionDataEncoder(), getInstantUpdateLimitOrderInstructionDataDecoder());
+}
+export function getInstantUpdateLimitOrderInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateLimitOrderInstruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js
index 41bfaa6..5fa758f 100644
--- a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
     144, 228, 114, 37, 165, 242, 111, 101,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak10 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak10
new file mode 100644
index 0000000..091257b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak10
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak2 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak2
new file mode 100644
index 0000000..41bfaa6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak2
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak6 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak6
new file mode 100644
index 0000000..41bfaa6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak6
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak7 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak7
new file mode 100644
index 0000000..091257b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak7
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak8 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak8
new file mode 100644
index 0000000..091257b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak8
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak9 b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak9
new file mode 100644
index 0000000..091257b
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/instantUpdateTpsl.js.bak9
@@ -0,0 +1,113 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const INSTANT_UPDATE_TPSL_DISCRIMINATOR = new Uint8Array([
+    144, 228, 114, 37, 165, 242, 111, 101,
+]);
+export function getInstantUpdateTpslDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(INSTANT_UPDATE_TPSL_DISCRIMINATOR);
+}
+export function getInstantUpdateTpslInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+        ['requestTime', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: INSTANT_UPDATE_TPSL_DISCRIMINATOR }));
+}
+export function getInstantUpdateTpslInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+        ['requestTime', getI64Decoder()],
+    ]);
+}
+export function getInstantUpdateTpslInstructionDataCodec() {
+    return combineCodec(getInstantUpdateTpslInstructionDataEncoder(), getInstantUpdateTpslInstructionDataDecoder());
+}
+export function getInstantUpdateTpslInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.apiKeeper),
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getInstantUpdateTpslInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseInstantUpdateTpslInstruction(instruction) {
+    if (instruction.accounts.length < 12) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            apiKeeper: getNextAccount(),
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getInstantUpdateTpslInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js
index f4226c9..80a067d 100644
--- a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
     64, 176, 88, 51, 168, 188, 156, 175,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak10 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak10
new file mode 100644
index 0000000..3840c91
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak10
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak2 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak2
new file mode 100644
index 0000000..f4226c9
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak2
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak6 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak6
new file mode 100644
index 0000000..f4226c9
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak6
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak7 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak7
new file mode 100644
index 0000000..3840c91
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak7
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak8 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak8
new file mode 100644
index 0000000..3840c91
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak8
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak9 b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak9
new file mode 100644
index 0000000..3840c91
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/liquidateFullPosition4.js.bak9
@@ -0,0 +1,121 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const LIQUIDATE_FULL_POSITION4_DISCRIMINATOR = new Uint8Array([
+    64, 176, 88, 51, 168, 188, 156, 175,
+]);
+export function getLiquidateFullPosition4DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(LIQUIDATE_FULL_POSITION4_DISCRIMINATOR);
+}
+export function getLiquidateFullPosition4InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: LIQUIDATE_FULL_POSITION4_DISCRIMINATOR,
+    }));
+}
+export function getLiquidateFullPosition4InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getLiquidateFullPosition4InstructionDataCodec() {
+    return combineCodec(getLiquidateFullPosition4InstructionDataEncoder(), getLiquidateFullPosition4InstructionDataDecoder());
+}
+export function getLiquidateFullPosition4Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        signer: { value: input.signer ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        position: { value: input.position ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustody: {
+            value: input.collateralCustody ?? null,
+            isWritable: true,
+        },
+        collateralCustodyDovesPriceAccount: {
+            value: input.collateralCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyPythnetPriceAccount: {
+            value: input.collateralCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        collateralCustodyTokenAccount: {
+            value: input.collateralCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.signer),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustody),
+            getAccountMeta(accounts.collateralCustodyDovesPriceAccount),
+            getAccountMeta(accounts.collateralCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.collateralCustodyTokenAccount),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getLiquidateFullPosition4InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseLiquidateFullPosition4Instruction(instruction) {
+    if (instruction.accounts.length < 13) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            signer: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            collateralCustody: getNextAccount(),
+            collateralCustodyDovesPriceAccount: getNextAccount(),
+            collateralCustodyPythnetPriceAccount: getNextAccount(),
+            collateralCustodyTokenAccount: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getLiquidateFullPosition4InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js
index 0e454c3..c718451 100644
--- a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
 export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
     166, 137, 92, 204, 145, 224, 24, 218,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak10 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak10
new file mode 100644
index 0000000..65bcedc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak10
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak2 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak2
new file mode 100644
index 0000000..0e454c3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak2
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak6 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak6
new file mode 100644
index 0000000..4c367b1
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak6
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak7 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak7
new file mode 100644
index 0000000..65bcedc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak7
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak8 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak8
new file mode 100644
index 0000000..65bcedc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak8
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak9 b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak9
new file mode 100644
index 0000000..65bcedc
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetCustodyConfig.js.bak9
@@ -0,0 +1,97 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    166, 137, 92, 204, 145, 224, 24, 218,
+]);
+export function getOperatorSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['pricing', getPricingParamsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['pricing', getPricingParamsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getOperatorSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetCustodyConfigInstructionDataEncoder(), getOperatorSetCustodyConfigInstructionDataDecoder());
+}
+export function getOperatorSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js
index 2e1fce9..b70cfed 100644
--- a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
 export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
     76, 201, 80, 18, 199, 92, 246, 105,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak10 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak10
new file mode 100644
index 0000000..8685882
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak10
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak2 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak2
new file mode 100644
index 0000000..2e1fce9
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak2
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak6 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak6
new file mode 100644
index 0000000..6eb79f5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak6
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak7 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak7
new file mode 100644
index 0000000..8685882
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak7
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak8 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak8
new file mode 100644
index 0000000..8685882
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak8
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak9 b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak9
new file mode 100644
index 0000000..8685882
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/operatorSetPoolConfig.js.bak9
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    76, 201, 80, 18, 199, 92, 246, 105,
+]);
+export function getOperatorSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getOperatorSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: OPERATOR_SET_POOL_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getOperatorSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getOperatorSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getOperatorSetPoolConfigInstructionDataEncoder(), getOperatorSetPoolConfigInstructionDataDecoder());
+}
+export function getOperatorSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        operator: { value: input.operator ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.operator),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getOperatorSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseOperatorSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            operator: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getOperatorSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js
index 3d2bb83..f903e1c 100644
--- a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
     123, 58, 109, 139, 133, 7, 225, 200,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak10 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak10
new file mode 100644
index 0000000..3140cd7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak10
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak2 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak2
new file mode 100644
index 0000000..3d2bb83
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak2
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak6 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak6
new file mode 100644
index 0000000..3d2bb83
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak6
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak7 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak7
new file mode 100644
index 0000000..3140cd7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak7
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak8 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak8
new file mode 100644
index 0000000..3140cd7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak8
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak9 b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak9
new file mode 100644
index 0000000..3140cd7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocCustody.js.bak9
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_CUSTODY_DISCRIMINATOR = new Uint8Array([
+    123, 58, 109, 139, 133, 7, 225, 200,
+]);
+export function getReallocCustodyDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_CUSTODY_DISCRIMINATOR);
+}
+export function getReallocCustodyInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_CUSTODY_DISCRIMINATOR }));
+}
+export function getReallocCustodyInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocCustodyInstructionDataCodec() {
+    return combineCodec(getReallocCustodyInstructionDataEncoder(), getReallocCustodyInstructionDataDecoder());
+}
+export function getReallocCustodyInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocCustodyInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocCustodyInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            custody: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocCustodyInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js b/node_modules/jup-perps-client/dist/instructions/reallocPool.js
index 697ec78..0f8764a 100644
--- a/node_modules/jup-perps-client/dist/instructions/reallocPool.js
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
     114, 128, 37, 167, 71, 227, 40, 178,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak10 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak10
new file mode 100644
index 0000000..8a7ff56
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak10
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak2 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak2
new file mode 100644
index 0000000..697ec78
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak2
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak6 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak6
new file mode 100644
index 0000000..697ec78
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak6
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak7 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak7
new file mode 100644
index 0000000..8a7ff56
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak7
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak8 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak8
new file mode 100644
index 0000000..8a7ff56
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak8
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak9 b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak9
new file mode 100644
index 0000000..8a7ff56
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/reallocPool.js.bak9
@@ -0,0 +1,82 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REALLOC_POOL_DISCRIMINATOR = new Uint8Array([
+    114, 128, 37, 167, 71, 227, 40, 178,
+]);
+export function getReallocPoolDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REALLOC_POOL_DISCRIMINATOR);
+}
+export function getReallocPoolInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REALLOC_POOL_DISCRIMINATOR }));
+}
+export function getReallocPoolInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getReallocPoolInstructionDataCodec() {
+    return combineCodec(getReallocPoolInstructionDataEncoder(), getReallocPoolInstructionDataDecoder());
+}
+export function getReallocPoolInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: true },
+        pool: { value: input.pool ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        rent: { value: input.rent ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.rent.value) {
+        accounts.rent.value =
+            'SysvarRent111111111111111111111111111111111';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.rent),
+        ],
+        programAddress,
+        data: getReallocPoolInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseReallocPoolInstruction(instruction) {
+    if (instruction.accounts.length < 4) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            pool: getNextAccount(),
+            systemProgram: getNextAccount(),
+            rent: getNextAccount(),
+        },
+        data: getReallocPoolInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js
index f963866..d6b95a7 100644
--- a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
     162, 0, 215, 55, 225, 15, 185, 0,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak10 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak10
new file mode 100644
index 0000000..1264662
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak10
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak2 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak2
new file mode 100644
index 0000000..f963866
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak2
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak6 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak6
new file mode 100644
index 0000000..f963866
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak6
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak7 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak7
new file mode 100644
index 0000000..1264662
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak7
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak8 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak8
new file mode 100644
index 0000000..1264662
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak8
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak9 b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak9
new file mode 100644
index 0000000..1264662
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/refreshAssetsUnderManagement.js.bak9
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR = new Uint8Array([
+    162, 0, 215, 55, 225, 15, 185, 0,
+]);
+export function getRefreshAssetsUnderManagementDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR);
+}
+export function getRefreshAssetsUnderManagementInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
+        ...value,
+        discriminator: REFRESH_ASSETS_UNDER_MANAGEMENT_DISCRIMINATOR,
+    }));
+}
+export function getRefreshAssetsUnderManagementInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getRefreshAssetsUnderManagementInstructionDataCodec() {
+    return combineCodec(getRefreshAssetsUnderManagementInstructionDataEncoder(), getRefreshAssetsUnderManagementInstructionDataDecoder());
+}
+export function getRefreshAssetsUnderManagementInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getRefreshAssetsUnderManagementInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseRefreshAssetsUnderManagementInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getRefreshAssetsUnderManagementInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js
index 5913f13..22f9b87 100644
--- a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
     230, 215, 82, 127, 241, 101, 227, 146,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak10
new file mode 100644
index 0000000..0643bbf
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak10
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak2
new file mode 100644
index 0000000..5913f13
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak2
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak6
new file mode 100644
index 0000000..5913f13
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak6
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak7
new file mode 100644
index 0000000..0643bbf
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak7
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak8
new file mode 100644
index 0000000..0643bbf
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak8
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak9
new file mode 100644
index 0000000..0643bbf
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/removeLiquidity2.js.bak9
@@ -0,0 +1,131 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const REMOVE_LIQUIDITY2_DISCRIMINATOR = new Uint8Array([
+    230, 215, 82, 127, 241, 101, 227, 146,
+]);
+export function getRemoveLiquidity2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(REMOVE_LIQUIDITY2_DISCRIMINATOR);
+}
+export function getRemoveLiquidity2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['lpAmountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: REMOVE_LIQUIDITY2_DISCRIMINATOR }));
+}
+export function getRemoveLiquidity2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['lpAmountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getRemoveLiquidity2InstructionDataCodec() {
+    return combineCodec(getRemoveLiquidity2InstructionDataEncoder(), getRemoveLiquidity2InstructionDataDecoder());
+}
+export function getRemoveLiquidity2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenAccount: { value: input.lpTokenAccount ?? null, isWritable: true },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        lpTokenMint: { value: input.lpTokenMint ?? null, isWritable: true },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.lpTokenAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.lpTokenMint),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getRemoveLiquidity2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseRemoveLiquidity2Instruction(instruction) {
+    if (instruction.accounts.length < 14) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            lpTokenAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            lpTokenMint: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getRemoveLiquidity2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js
index 0b42b2a..365c1e7 100644
--- a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
 export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
     133, 97, 130, 143, 215, 229, 36, 176,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak10 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak10
new file mode 100644
index 0000000..7844014
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak10
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak2 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak2
new file mode 100644
index 0000000..0b42b2a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak2
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak6 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak6
new file mode 100644
index 0000000..37c223a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak6
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak7 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak7
new file mode 100644
index 0000000..7844014
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak7
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak8 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak8
new file mode 100644
index 0000000..7844014
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak8
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak9 b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak9
new file mode 100644
index 0000000..7844014
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setCustodyConfig.js.bak9
@@ -0,0 +1,105 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getF32Decoder, getF32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getJumpRateStateDecoder, getJumpRateStateEncoder, getOracleParamsDecoder, getOracleParamsEncoder, getPermissionsDecoder, getPermissionsEncoder, getPricingParamsDecoder, getPricingParamsEncoder, } from '../types/index.js';
+export const SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
+    133, 97, 130, 143, 215, 229, 36, 176,
+]);
+export function getSetCustodyConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_CUSTODY_CONFIG_DISCRIMINATOR);
+}
+export function getSetCustodyConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['oracle', getOracleParamsEncoder()],
+        ['pricing', getPricingParamsEncoder()],
+        ['permissions', getPermissionsEncoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+        ['targetRatioBps', getU64Encoder()],
+        ['increasePositionBps', getU64Encoder()],
+        ['decreasePositionBps', getU64Encoder()],
+        ['dovesOracle', getAddressEncoder()],
+        ['maxPositionSizeUsd', getU64Encoder()],
+        ['jumpRate', getJumpRateStateEncoder()],
+        ['priceImpactFeeFactor', getU64Encoder()],
+        ['priceImpactExponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+        ['dovesAgOracle', getAddressEncoder()],
+    ]), (value) => ({ ...value, discriminator: SET_CUSTODY_CONFIG_DISCRIMINATOR }));
+}
+export function getSetCustodyConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['oracle', getOracleParamsDecoder()],
+        ['pricing', getPricingParamsDecoder()],
+        ['permissions', getPermissionsDecoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+        ['targetRatioBps', getU64Decoder()],
+        ['increasePositionBps', getU64Decoder()],
+        ['decreasePositionBps', getU64Decoder()],
+        ['dovesOracle', getAddressDecoder()],
+        ['maxPositionSizeUsd', getU64Decoder()],
+        ['jumpRate', getJumpRateStateDecoder()],
+        ['priceImpactFeeFactor', getU64Decoder()],
+        ['priceImpactExponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+        ['dovesAgOracle', getAddressDecoder()],
+    ]);
+}
+export function getSetCustodyConfigInstructionDataCodec() {
+    return combineCodec(getSetCustodyConfigInstructionDataEncoder(), getSetCustodyConfigInstructionDataDecoder());
+}
+export function getSetCustodyConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: true },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        custody: { value: input.custody ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.custody),
+        ],
+        programAddress,
+        data: getSetCustodyConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetCustodyConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            custody: getNextAccount(),
+        },
+        data: getSetCustodyConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js
index 56f16e6..9a63273 100644
--- a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getPermissionsDecoder, getPermissionsEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
 export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
     80, 72, 21, 191, 29, 121, 45, 111,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak10 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak10
new file mode 100644
index 0000000..73814b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak10
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak2 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak2
new file mode 100644
index 0000000..56f16e6
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak2
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak6 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak6
new file mode 100644
index 0000000..2db0c9f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak6
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak7 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak7
new file mode 100644
index 0000000..73814b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak7
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak8 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak8
new file mode 100644
index 0000000..73814b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak8
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak9 b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak9
new file mode 100644
index 0000000..73814b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPerpetualsConfig.js.bak9
@@ -0,0 +1,77 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getPermissionsDecoder, getPermissionsEncoder, } from '../types/index.js';
+export const SET_PERPETUALS_CONFIG_DISCRIMINATOR = new Uint8Array([
+    80, 72, 21, 191, 29, 121, 45, 111,
+]);
+export function getSetPerpetualsConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_PERPETUALS_CONFIG_DISCRIMINATOR);
+}
+export function getSetPerpetualsConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['permissions', getPermissionsEncoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: SET_PERPETUALS_CONFIG_DISCRIMINATOR,
+    }));
+}
+export function getSetPerpetualsConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['permissions', getPermissionsDecoder()],
+    ]);
+}
+export function getSetPerpetualsConfigInstructionDataCodec() {
+    return combineCodec(getSetPerpetualsConfigInstructionDataEncoder(), getSetPerpetualsConfigInstructionDataDecoder());
+}
+export function getSetPerpetualsConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetPerpetualsConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPerpetualsConfigInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetPerpetualsConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js
index 8bfa9f9..264ca74 100644
--- a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js
@@ -6,9 +6,9 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
-import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
 export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
     216, 87, 65, 125, 113, 110, 185, 120,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak10 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak10
new file mode 100644
index 0000000..a93fd3e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak10
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak2 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak2
new file mode 100644
index 0000000..8bfa9f9
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak2
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak6 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak6
new file mode 100644
index 0000000..9f1f88d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak6
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak7 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak7
new file mode 100644
index 0000000..a93fd3e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak7
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak8 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak8
new file mode 100644
index 0000000..a93fd3e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak8
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak9 b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak9
new file mode 100644
index 0000000..a93fd3e
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setPoolConfig.js.bak9
@@ -0,0 +1,81 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+import { getFeesDecoder, getFeesEncoder, getLimitDecoder, getLimitEncoder, } from '../types/index.js';
+export const SET_POOL_CONFIG_DISCRIMINATOR = new Uint8Array([
+    216, 87, 65, 125, 113, 110, 185, 120,
+]);
+export function getSetPoolConfigDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_POOL_CONFIG_DISCRIMINATOR);
+}
+export function getSetPoolConfigInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['fees', getFeesEncoder()],
+        ['limit', getLimitEncoder()],
+        ['maxRequestExecutionSec', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_POOL_CONFIG_DISCRIMINATOR }));
+}
+export function getSetPoolConfigInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['fees', getFeesDecoder()],
+        ['limit', getLimitDecoder()],
+        ['maxRequestExecutionSec', getI64Decoder()],
+    ]);
+}
+export function getSetPoolConfigInstructionDataCodec() {
+    return combineCodec(getSetPoolConfigInstructionDataEncoder(), getSetPoolConfigInstructionDataDecoder());
+}
+export function getSetPoolConfigInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+        ],
+        programAddress,
+        data: getSetPoolConfigInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetPoolConfigInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+        },
+        data: getSetPoolConfigInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js b/node_modules/jup-perps-client/dist/instructions/setTestTime.js
index f3d6cfa..bce11b7 100644
--- a/node_modules/jup-perps-client/dist/instructions/setTestTime.js
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
     242, 231, 177, 251, 126, 145, 159, 104,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak10 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak10
new file mode 100644
index 0000000..c38e43d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak10
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak2 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak2
new file mode 100644
index 0000000..f3d6cfa
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak2
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak6 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak6
new file mode 100644
index 0000000..f3d6cfa
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak6
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak7 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak7
new file mode 100644
index 0000000..c38e43d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak7
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak8 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak8
new file mode 100644
index 0000000..c38e43d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak8
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak9 b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak9
new file mode 100644
index 0000000..c38e43d
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTestTime.js.bak9
@@ -0,0 +1,73 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TEST_TIME_DISCRIMINATOR = new Uint8Array([
+    242, 231, 177, 251, 126, 145, 159, 104,
+]);
+export function getSetTestTimeDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TEST_TIME_DISCRIMINATOR);
+}
+export function getSetTestTimeInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['time', getI64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SET_TEST_TIME_DISCRIMINATOR }));
+}
+export function getSetTestTimeInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['time', getI64Decoder()],
+    ]);
+}
+export function getSetTestTimeInstructionDataCodec() {
+    return combineCodec(getSetTestTimeInstructionDataEncoder(), getSetTestTimeInstructionDataDecoder());
+}
+export function getSetTestTimeInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getSetTestTimeInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSetTestTimeInstruction(instruction) {
+    if (instruction.accounts.length < 2) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getSetTestTimeInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js
index 212fab3..cc68d8a 100644
--- a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
     228, 85, 185, 112, 78, 79, 77, 2,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak10 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak10
new file mode 100644
index 0000000..1c2804f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak10
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak2 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak2
new file mode 100644
index 0000000..212fab3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak2
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak6 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak6
new file mode 100644
index 0000000..212fab3
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak6
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak7 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak7
new file mode 100644
index 0000000..1c2804f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak7
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak8 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak8
new file mode 100644
index 0000000..1c2804f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak8
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak9 b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak9
new file mode 100644
index 0000000..1c2804f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/setTokenLedger.js.bak9
@@ -0,0 +1,75 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SET_TOKEN_LEDGER_DISCRIMINATOR = new Uint8Array([
+    228, 85, 185, 112, 78, 79, 77, 2,
+]);
+export function getSetTokenLedgerDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SET_TOKEN_LEDGER_DISCRIMINATOR);
+}
+export function getSetTokenLedgerInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: SET_TOKEN_LEDGER_DISCRIMINATOR }));
+}
+export function getSetTokenLedgerInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getSetTokenLedgerInstructionDataCodec() {
+    return combineCodec(getSetTokenLedgerInstructionDataEncoder(), getSetTokenLedgerInstructionDataDecoder());
+}
+export function getSetTokenLedgerInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        tokenLedger: { value: input.tokenLedger ?? null, isWritable: true },
+        tokenAccount: { value: input.tokenAccount ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.tokenLedger),
+            getAccountMeta(accounts.tokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getSetTokenLedgerInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseSetTokenLedgerInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            tokenLedger: getNextAccount(),
+            tokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getSetTokenLedgerInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js b/node_modules/jup-perps-client/dist/instructions/swap2.js
index 9acecef..dd84f69 100644
--- a/node_modules/jup-perps-client/dist/instructions/swap2.js
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const SWAP2_DISCRIMINATOR = new Uint8Array([
     65, 75, 63, 76, 235, 91, 91, 136,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak10
new file mode 100644
index 0000000..04d4996
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak10
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak2
new file mode 100644
index 0000000..9acecef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak2
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak6
new file mode 100644
index 0000000..9acecef
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak6
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak7
new file mode 100644
index 0000000..04d4996
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak7
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak8
new file mode 100644
index 0000000..04d4996
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak8
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/swap2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak9
new file mode 100644
index 0000000..04d4996
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/swap2.js.bak9
@@ -0,0 +1,155 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const SWAP2_DISCRIMINATOR = new Uint8Array([
+    65, 75, 63, 76, 235, 91, 91, 136,
+]);
+export function getSwap2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP2_DISCRIMINATOR);
+}
+export function getSwap2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['amountIn', getU64Encoder()],
+        ['minAmountOut', getU64Encoder()],
+    ]), (value) => ({ ...value, discriminator: SWAP2_DISCRIMINATOR }));
+}
+export function getSwap2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['amountIn', getU64Decoder()],
+        ['minAmountOut', getU64Decoder()],
+    ]);
+}
+export function getSwap2InstructionDataCodec() {
+    return combineCodec(getSwap2InstructionDataEncoder(), getSwap2InstructionDataDecoder());
+}
+export function getSwap2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        fundingAccount: { value: input.fundingAccount ?? null, isWritable: true },
+        receivingAccount: {
+            value: input.receivingAccount ?? null,
+            isWritable: true,
+        },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        receivingCustody: {
+            value: input.receivingCustody ?? null,
+            isWritable: true,
+        },
+        receivingCustodyDovesPriceAccount: {
+            value: input.receivingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyPythnetPriceAccount: {
+            value: input.receivingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingCustodyTokenAccount: {
+            value: input.receivingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        dispensingCustody: {
+            value: input.dispensingCustody ?? null,
+            isWritable: true,
+        },
+        dispensingCustodyDovesPriceAccount: {
+            value: input.dispensingCustodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyPythnetPriceAccount: {
+            value: input.dispensingCustodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        dispensingCustodyTokenAccount: {
+            value: input.dispensingCustodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+        eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
+        program: { value: input.program ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.fundingAccount),
+            getAccountMeta(accounts.receivingAccount),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.receivingCustody),
+            getAccountMeta(accounts.receivingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.receivingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingCustodyTokenAccount),
+            getAccountMeta(accounts.dispensingCustody),
+            getAccountMeta(accounts.dispensingCustodyDovesPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyPythnetPriceAccount),
+            getAccountMeta(accounts.dispensingCustodyTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+            getAccountMeta(accounts.eventAuthority),
+            getAccountMeta(accounts.program),
+        ],
+        programAddress,
+        data: getSwap2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseSwap2Instruction(instruction) {
+    if (instruction.accounts.length < 17) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            fundingAccount: getNextAccount(),
+            receivingAccount: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            receivingCustody: getNextAccount(),
+            receivingCustodyDovesPriceAccount: getNextAccount(),
+            receivingCustodyPythnetPriceAccount: getNextAccount(),
+            receivingCustodyTokenAccount: getNextAccount(),
+            dispensingCustody: getNextAccount(),
+            dispensingCustodyDovesPriceAccount: getNextAccount(),
+            dispensingCustodyPythnetPriceAccount: getNextAccount(),
+            dispensingCustodyTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+            eventAuthority: getNextAccount(),
+            program: getNextAccount(),
+        },
+        data: getSwap2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js b/node_modules/jup-perps-client/dist/instructions/testInit.js
index b615593..22713ca 100644
--- a/node_modules/jup-perps-client/dist/instructions/testInit.js
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
     48, 51, 92, 122, 81, 19, 112, 41,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak10 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak10
new file mode 100644
index 0000000..d4e02c7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak10
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak2 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak2
new file mode 100644
index 0000000..b615593
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak2
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak6 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak6
new file mode 100644
index 0000000..b615593
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak6
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak7 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak7
new file mode 100644
index 0000000..d4e02c7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak7
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak8 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak8
new file mode 100644
index 0000000..d4e02c7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak8
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/testInit.js.bak9 b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak9
new file mode 100644
index 0000000..d4e02c7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/testInit.js.bak9
@@ -0,0 +1,112 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TEST_INIT_DISCRIMINATOR = new Uint8Array([
+    48, 51, 92, 122, 81, 19, 112, 41,
+]);
+export function getTestInitDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TEST_INIT_DISCRIMINATOR);
+}
+export function getTestInitInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]), (value) => ({ ...value, discriminator: TEST_INIT_DISCRIMINATOR }));
+}
+export function getTestInitInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getTestInitInstructionDataCodec() {
+    return combineCodec(getTestInitInstructionDataEncoder(), getTestInitInstructionDataDecoder());
+}
+export function getTestInitInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        upgradeAuthority: {
+            value: input.upgradeAuthority ?? null,
+            isWritable: true,
+        },
+        admin: { value: input.admin ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: true,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    // Resolve default values.
+    if (!accounts.systemProgram.value) {
+        accounts.systemProgram.value =
+            '11111111111111111111111111111111';
+    }
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.upgradeAuthority),
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.systemProgram),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getTestInitInstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseTestInitInstruction(instruction) {
+    if (instruction.accounts.length < 6) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            upgradeAuthority: getNextAccount(),
+            admin: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            systemProgram: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getTestInitInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js
index 2e38c49..0359e14 100644
--- a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
     42, 242, 66, 106, 228, 10, 111, 156,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak10 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak10
new file mode 100644
index 0000000..382440a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak10
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak2 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak2
new file mode 100644
index 0000000..2e38c49
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak2
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak6 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak6
new file mode 100644
index 0000000..2e38c49
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak6
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak7 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak7
new file mode 100644
index 0000000..382440a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak7
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak8 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak8
new file mode 100644
index 0000000..382440a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak8
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak9 b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak9
new file mode 100644
index 0000000..382440a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/transferAdmin.js.bak9
@@ -0,0 +1,70 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const TRANSFER_ADMIN_DISCRIMINATOR = new Uint8Array([
+    42, 242, 66, 106, 228, 10, 111, 156,
+]);
+export function getTransferAdminDiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(TRANSFER_ADMIN_DISCRIMINATOR);
+}
+export function getTransferAdminInstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: TRANSFER_ADMIN_DISCRIMINATOR }));
+}
+export function getTransferAdminInstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getTransferAdminInstructionDataCodec() {
+    return combineCodec(getTransferAdminInstructionDataEncoder(), getTransferAdminInstructionDataDecoder());
+}
+export function getTransferAdminInstruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        admin: { value: input.admin ?? null, isWritable: false },
+        newAdmin: { value: input.newAdmin ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: true },
+    };
+    const accounts = originalAccounts;
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.admin),
+            getAccountMeta(accounts.newAdmin),
+            getAccountMeta(accounts.perpetuals),
+        ],
+        programAddress,
+        data: getTransferAdminInstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseTransferAdminInstruction(instruction) {
+    if (instruction.accounts.length < 3) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            admin: getNextAccount(),
+            newAdmin: getNextAccount(),
+            perpetuals: getNextAccount(),
+        },
+        data: getTransferAdminInstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js
index a2fed90..ef03916 100644
--- a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
     144, 200, 249, 255, 108, 217, 249, 116,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak10
new file mode 100644
index 0000000..1ef436a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak10
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak2
new file mode 100644
index 0000000..a2fed90
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak2
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak6
new file mode 100644
index 0000000..a2fed90
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak6
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak7
new file mode 100644
index 0000000..1ef436a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak7
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak8
new file mode 100644
index 0000000..1ef436a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak8
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak9
new file mode 100644
index 0000000..1ef436a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/updateDecreasePositionRequest2.js.bak9
@@ -0,0 +1,102 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR = new Uint8Array([
+    144, 200, 249, 255, 108, 217, 249, 116,
+]);
+export function getUpdateDecreasePositionRequest2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([
+        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
+        ['sizeUsdDelta', getU64Encoder()],
+        ['triggerPrice', getU64Encoder()],
+    ]), (value) => ({
+        ...value,
+        discriminator: UPDATE_DECREASE_POSITION_REQUEST2_DISCRIMINATOR,
+    }));
+}
+export function getUpdateDecreasePositionRequest2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+        ['sizeUsdDelta', getU64Decoder()],
+        ['triggerPrice', getU64Decoder()],
+    ]);
+}
+export function getUpdateDecreasePositionRequest2InstructionDataCodec() {
+    return combineCodec(getUpdateDecreasePositionRequest2InstructionDataEncoder(), getUpdateDecreasePositionRequest2InstructionDataDecoder());
+}
+export function getUpdateDecreasePositionRequest2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        owner: { value: input.owner ?? null, isWritable: false },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: false },
+        position: { value: input.position ?? null, isWritable: false },
+        positionRequest: { value: input.positionRequest ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: false },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+    };
+    const accounts = originalAccounts;
+    // Original args.
+    const args = { ...input };
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.owner),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.position),
+            getAccountMeta(accounts.positionRequest),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+        ],
+        programAddress,
+        data: getUpdateDecreasePositionRequest2InstructionDataEncoder().encode(args),
+    };
+    return instruction;
+}
+export function parseUpdateDecreasePositionRequest2Instruction(instruction) {
+    if (instruction.accounts.length < 8) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            owner: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            position: getNextAccount(),
+            positionRequest: getNextAccount(),
+            custody: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+        },
+        data: getUpdateDecreasePositionRequest2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js
index f1a1a3a..35b5345 100644
--- a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js
@@ -6,8 +6,8 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
-import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
-import { getAccountMetaFactory } from '../shared';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared/index.js';
 export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
     252, 128, 143, 145, 225, 221, 159, 207,
 ]);
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak10 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak10
new file mode 100644
index 0000000..8631bc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak10
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak2 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak2
new file mode 100644
index 0000000..f1a1a3a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak2
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak6 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak6
new file mode 100644
index 0000000..f1a1a3a
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak6
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak7 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak7
new file mode 100644
index 0000000..8631bc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak7
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak8 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak8
new file mode 100644
index 0000000..8631bc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak8
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak9 b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak9
new file mode 100644
index 0000000..8631bc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/instructions/withdrawFees2.js.bak9
@@ -0,0 +1,111 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, } from '@solana/kit';
+import { PERPETUALS_PROGRAM_ADDRESS } from '../programs/index.js';
+import { getAccountMetaFactory } from '../shared';
+export const WITHDRAW_FEES2_DISCRIMINATOR = new Uint8Array([
+    252, 128, 143, 145, 225, 221, 159, 207,
+]);
+export function getWithdrawFees2DiscriminatorBytes() {
+    return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FEES2_DISCRIMINATOR);
+}
+export function getWithdrawFees2InstructionDataEncoder() {
+    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: WITHDRAW_FEES2_DISCRIMINATOR }));
+}
+export function getWithdrawFees2InstructionDataDecoder() {
+    return getStructDecoder([
+        ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
+    ]);
+}
+export function getWithdrawFees2InstructionDataCodec() {
+    return combineCodec(getWithdrawFees2InstructionDataEncoder(), getWithdrawFees2InstructionDataDecoder());
+}
+export function getWithdrawFees2Instruction(input, config) {
+    // Program address.
+    const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS;
+    // Original accounts.
+    const originalAccounts = {
+        keeper: { value: input.keeper ?? null, isWritable: false },
+        transferAuthority: {
+            value: input.transferAuthority ?? null,
+            isWritable: false,
+        },
+        perpetuals: { value: input.perpetuals ?? null, isWritable: false },
+        pool: { value: input.pool ?? null, isWritable: true },
+        custody: { value: input.custody ?? null, isWritable: true },
+        custodyTokenAccount: {
+            value: input.custodyTokenAccount ?? null,
+            isWritable: true,
+        },
+        custodyDovesPriceAccount: {
+            value: input.custodyDovesPriceAccount ?? null,
+            isWritable: false,
+        },
+        custodyPythnetPriceAccount: {
+            value: input.custodyPythnetPriceAccount ?? null,
+            isWritable: false,
+        },
+        receivingTokenAccount: {
+            value: input.receivingTokenAccount ?? null,
+            isWritable: true,
+        },
+        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
+    };
+    const accounts = originalAccounts;
+    // Resolve default values.
+    if (!accounts.tokenProgram.value) {
+        accounts.tokenProgram.value =
+            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
+    }
+    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
+    const instruction = {
+        accounts: [
+            getAccountMeta(accounts.keeper),
+            getAccountMeta(accounts.transferAuthority),
+            getAccountMeta(accounts.perpetuals),
+            getAccountMeta(accounts.pool),
+            getAccountMeta(accounts.custody),
+            getAccountMeta(accounts.custodyTokenAccount),
+            getAccountMeta(accounts.custodyDovesPriceAccount),
+            getAccountMeta(accounts.custodyPythnetPriceAccount),
+            getAccountMeta(accounts.receivingTokenAccount),
+            getAccountMeta(accounts.tokenProgram),
+        ],
+        programAddress,
+        data: getWithdrawFees2InstructionDataEncoder().encode({}),
+    };
+    return instruction;
+}
+export function parseWithdrawFees2Instruction(instruction) {
+    if (instruction.accounts.length < 10) {
+        // TODO: Coded error.
+        throw new Error('Not enough accounts');
+    }
+    let accountIndex = 0;
+    const getNextAccount = () => {
+        const accountMeta = instruction.accounts[accountIndex];
+        accountIndex += 1;
+        return accountMeta;
+    };
+    return {
+        programAddress: instruction.programAddress,
+        accounts: {
+            keeper: getNextAccount(),
+            transferAuthority: getNextAccount(),
+            perpetuals: getNextAccount(),
+            pool: getNextAccount(),
+            custody: getNextAccount(),
+            custodyTokenAccount: getNextAccount(),
+            custodyDovesPriceAccount: getNextAccount(),
+            custodyPythnetPriceAccount: getNextAccount(),
+            receivingTokenAccount: getNextAccount(),
+            tokenProgram: getNextAccount(),
+        },
+        data: getWithdrawFees2InstructionDataDecoder().decode(instruction.data),
+    };
+}
diff --git a/node_modules/jup-perps-client/dist/programs/index-patched.js b/node_modules/jup-perps-client/dist/programs/index-patched.js
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index-patched.js
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js b/node_modules/jup-perps-client/dist/programs/index.js
index 5827468..a306cca 100644
--- a/node_modules/jup-perps-client/dist/programs/index.js
+++ b/node_modules/jup-perps-client/dist/programs/index.js
@@ -5,4 +5,4 @@
  *
  * @see https://github.com/codama-idl/codama
  */
-export * from './perpetuals';
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.backup b/node_modules/jup-perps-client/dist/programs/index.js.backup
new file mode 100644
index 0000000..5827468
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.backup
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak10 b/node_modules/jup-perps-client/dist/programs/index.js.bak10
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak10
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak2 b/node_modules/jup-perps-client/dist/programs/index.js.bak2
new file mode 100644
index 0000000..5827468
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak2
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak6 b/node_modules/jup-perps-client/dist/programs/index.js.bak6
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak6
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak7 b/node_modules/jup-perps-client/dist/programs/index.js.bak7
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak7
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak8 b/node_modules/jup-perps-client/dist/programs/index.js.bak8
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak8
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/index.js.bak9 b/node_modules/jup-perps-client/dist/programs/index.js.bak9
new file mode 100644
index 0000000..a306cca
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/index.js.bak9
@@ -0,0 +1,8 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './perpetuals.js';
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak10 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak10
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak10
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak2 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak2
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak2
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak6 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak6
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak6
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak7 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak7
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak7
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak8 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak8
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak8
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak9 b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak9
new file mode 100644
index 0000000..59dc3f8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/programs/perpetuals.js.bak9
@@ -0,0 +1,211 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { containsBytes, fixEncoderSize, getBytesEncoder, } from '@solana/kit';
+export const PERPETUALS_PROGRAM_ADDRESS = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
+export var PerpetualsAccount;
+(function (PerpetualsAccount) {
+    PerpetualsAccount[PerpetualsAccount["Custody"] = 0] = "Custody";
+    PerpetualsAccount[PerpetualsAccount["Perpetuals"] = 1] = "Perpetuals";
+    PerpetualsAccount[PerpetualsAccount["Pool"] = 2] = "Pool";
+    PerpetualsAccount[PerpetualsAccount["PositionRequest"] = 3] = "PositionRequest";
+    PerpetualsAccount[PerpetualsAccount["Position"] = 4] = "Position";
+    PerpetualsAccount[PerpetualsAccount["TokenLedger"] = 5] = "TokenLedger";
+})(PerpetualsAccount || (PerpetualsAccount = {}));
+export function identifyPerpetualsAccount(account) {
+    const data = 'data' in account ? account.data : account;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([1, 184, 48, 81, 93, 131, 63, 145])), 0)) {
+        return PerpetualsAccount.Custody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 167, 98, 191, 104, 82, 108, 196])), 0)) {
+        return PerpetualsAccount.Perpetuals;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([241, 154, 109, 4, 17, 177, 109, 188])), 0)) {
+        return PerpetualsAccount.Pool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([12, 38, 250, 199, 46, 154, 32, 216])), 0)) {
+        return PerpetualsAccount.PositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])), 0)) {
+        return PerpetualsAccount.Position;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 247, 9, 188, 54, 108, 85, 77])), 0)) {
+        return PerpetualsAccount.TokenLedger;
+    }
+    throw new Error('The provided account could not be identified as a perpetuals account.');
+}
+export var PerpetualsInstruction;
+(function (PerpetualsInstruction) {
+    PerpetualsInstruction[PerpetualsInstruction["Init"] = 0] = "Init";
+    PerpetualsInstruction[PerpetualsInstruction["AddPool"] = 1] = "AddPool";
+    PerpetualsInstruction[PerpetualsInstruction["AddCustody"] = 2] = "AddCustody";
+    PerpetualsInstruction[PerpetualsInstruction["SetCustodyConfig"] = 3] = "SetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPoolConfig"] = 4] = "SetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["SetPerpetualsConfig"] = 5] = "SetPerpetualsConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TransferAdmin"] = 6] = "TransferAdmin";
+    PerpetualsInstruction[PerpetualsInstruction["WithdrawFees2"] = 7] = "WithdrawFees2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenMetadata"] = 8] = "CreateTokenMetadata";
+    PerpetualsInstruction[PerpetualsInstruction["CreateTokenLedger"] = 9] = "CreateTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocCustody"] = 10] = "ReallocCustody";
+    PerpetualsInstruction[PerpetualsInstruction["ReallocPool"] = 11] = "ReallocPool";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetCustodyConfig"] = 12] = "OperatorSetCustodyConfig";
+    PerpetualsInstruction[PerpetualsInstruction["OperatorSetPoolConfig"] = 13] = "OperatorSetPoolConfig";
+    PerpetualsInstruction[PerpetualsInstruction["TestInit"] = 14] = "TestInit";
+    PerpetualsInstruction[PerpetualsInstruction["SetTestTime"] = 15] = "SetTestTime";
+    PerpetualsInstruction[PerpetualsInstruction["SetTokenLedger"] = 16] = "SetTokenLedger";
+    PerpetualsInstruction[PerpetualsInstruction["Swap2"] = 17] = "Swap2";
+    PerpetualsInstruction[PerpetualsInstruction["AddLiquidity2"] = 18] = "AddLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["RemoveLiquidity2"] = 19] = "RemoveLiquidity2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateIncreasePositionMarketRequest"] = 20] = "CreateIncreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionRequest2"] = 21] = "CreateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["CreateDecreasePositionMarketRequest"] = 22] = "CreateDecreasePositionMarketRequest";
+    PerpetualsInstruction[PerpetualsInstruction["UpdateDecreasePositionRequest2"] = 23] = "UpdateDecreasePositionRequest2";
+    PerpetualsInstruction[PerpetualsInstruction["ClosePositionRequest"] = 24] = "ClosePositionRequest";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePosition4"] = 25] = "IncreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionPreSwap"] = 26] = "IncreasePositionPreSwap";
+    PerpetualsInstruction[PerpetualsInstruction["IncreasePositionWithInternalSwap"] = 27] = "IncreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePosition4"] = 28] = "DecreasePosition4";
+    PerpetualsInstruction[PerpetualsInstruction["DecreasePositionWithInternalSwap"] = 29] = "DecreasePositionWithInternalSwap";
+    PerpetualsInstruction[PerpetualsInstruction["LiquidateFullPosition4"] = 30] = "LiquidateFullPosition4";
+    PerpetualsInstruction[PerpetualsInstruction["RefreshAssetsUnderManagement"] = 31] = "RefreshAssetsUnderManagement";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateTpsl"] = 32] = "InstantCreateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["InstantCreateLimitOrder"] = 33] = "InstantCreateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantIncreasePosition"] = 34] = "InstantIncreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantDecreasePosition"] = 35] = "InstantDecreasePosition";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateLimitOrder"] = 36] = "InstantUpdateLimitOrder";
+    PerpetualsInstruction[PerpetualsInstruction["InstantUpdateTpsl"] = 37] = "InstantUpdateTpsl";
+    PerpetualsInstruction[PerpetualsInstruction["GetAddLiquidityAmountAndFee2"] = 38] = "GetAddLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetRemoveLiquidityAmountAndFee2"] = 39] = "GetRemoveLiquidityAmountAndFee2";
+    PerpetualsInstruction[PerpetualsInstruction["GetAssetsUnderManagement2"] = 40] = "GetAssetsUnderManagement2";
+})(PerpetualsInstruction || (PerpetualsInstruction = {}));
+export function identifyPerpetualsInstruction(instruction) {
+    const data = 'data' in instruction ? instruction.data : instruction;
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])), 0)) {
+        return PerpetualsInstruction.Init;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([115, 230, 212, 211, 175, 49, 39, 169])), 0)) {
+        return PerpetualsInstruction.AddPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([247, 254, 126, 17, 26, 6, 215, 117])), 0)) {
+        return PerpetualsInstruction.AddCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([133, 97, 130, 143, 215, 229, 36, 176])), 0)) {
+        return PerpetualsInstruction.SetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([216, 87, 65, 125, 113, 110, 185, 120])), 0)) {
+        return PerpetualsInstruction.SetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 72, 21, 191, 29, 121, 45, 111])), 0)) {
+        return PerpetualsInstruction.SetPerpetualsConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([42, 242, 66, 106, 228, 10, 111, 156])), 0)) {
+        return PerpetualsInstruction.TransferAdmin;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 128, 143, 145, 225, 221, 159, 207])), 0)) {
+        return PerpetualsInstruction.WithdrawFees2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([221, 80, 176, 37, 153, 188, 160, 68])), 0)) {
+        return PerpetualsInstruction.CreateTokenMetadata;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([232, 242, 197, 253, 240, 143, 129, 52])), 0)) {
+        return PerpetualsInstruction.CreateTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 58, 109, 139, 133, 7, 225, 200])), 0)) {
+        return PerpetualsInstruction.ReallocCustody;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 128, 37, 167, 71, 227, 40, 178])), 0)) {
+        return PerpetualsInstruction.ReallocPool;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([166, 137, 92, 204, 145, 224, 24, 218])), 0)) {
+        return PerpetualsInstruction.OperatorSetCustodyConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([76, 201, 80, 18, 199, 92, 246, 105])), 0)) {
+        return PerpetualsInstruction.OperatorSetPoolConfig;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 51, 92, 122, 81, 19, 112, 41])), 0)) {
+        return PerpetualsInstruction.TestInit;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 231, 177, 251, 126, 145, 159, 104])), 0)) {
+        return PerpetualsInstruction.SetTestTime;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 85, 185, 112, 78, 79, 77, 2])), 0)) {
+        return PerpetualsInstruction.SetTokenLedger;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([65, 75, 63, 76, 235, 91, 91, 136])), 0)) {
+        return PerpetualsInstruction.Swap2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 162, 78, 28, 70, 219, 116, 115])), 0)) {
+        return PerpetualsInstruction.AddLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([230, 215, 82, 127, 241, 101, 227, 146])), 0)) {
+        return PerpetualsInstruction.RemoveLiquidity2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([184, 85, 199, 24, 105, 171, 156, 56])), 0)) {
+        return PerpetualsInstruction.CreateIncreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([105, 64, 201, 82, 250, 14, 109, 77])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([74, 198, 195, 86, 193, 99, 1, 79])), 0)) {
+        return PerpetualsInstruction.CreateDecreasePositionMarketRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 200, 249, 255, 108, 217, 249, 116])), 0)) {
+        return PerpetualsInstruction.UpdateDecreasePositionRequest2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([40, 105, 217, 188, 220, 45, 109, 110])), 0)) {
+        return PerpetualsInstruction.ClosePositionRequest;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([67, 147, 53, 23, 43, 57, 16, 67])), 0)) {
+        return PerpetualsInstruction.IncreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([26, 136, 225, 217, 22, 21, 83, 20])), 0)) {
+        return PerpetualsInstruction.IncreasePositionPreSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([114, 55, 106, 140, 199, 221, 32, 112])), 0)) {
+        return PerpetualsInstruction.IncreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([185, 161, 114, 175, 96, 148, 3, 170])), 0)) {
+        return PerpetualsInstruction.DecreasePosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([131, 17, 153, 110, 119, 100, 97, 38])), 0)) {
+        return PerpetualsInstruction.DecreasePositionWithInternalSwap;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 176, 88, 51, 168, 188, 156, 175])), 0)) {
+        return PerpetualsInstruction.LiquidateFullPosition4;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([162, 0, 215, 55, 225, 15, 185, 0])), 0)) {
+        return PerpetualsInstruction.RefreshAssetsUnderManagement;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([117, 98, 66, 127, 30, 50, 73, 185])), 0)) {
+        return PerpetualsInstruction.InstantCreateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([194, 37, 195, 123, 40, 127, 126, 156])), 0)) {
+        return PerpetualsInstruction.InstantCreateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 126, 68, 182, 223, 166, 64, 183])), 0)) {
+        return PerpetualsInstruction.InstantIncreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([46, 23, 240, 44, 30, 138, 94, 140])), 0)) {
+        return PerpetualsInstruction.InstantDecreasePosition;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([136, 245, 229, 58, 121, 141, 12, 207])), 0)) {
+        return PerpetualsInstruction.InstantUpdateLimitOrder;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([144, 228, 114, 37, 165, 242, 111, 101])), 0)) {
+        return PerpetualsInstruction.InstantUpdateTpsl;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 157, 55, 169, 8, 81, 4, 118])), 0)) {
+        return PerpetualsInstruction.GetAddLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 59, 72, 110, 223, 243, 150, 142])), 0)) {
+        return PerpetualsInstruction.GetRemoveLiquidityAmountAndFee2;
+    }
+    if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([193, 210, 13, 249, 113, 149, 29, 84])), 0)) {
+        return PerpetualsInstruction.GetAssetsUnderManagement2;
+    }
+    throw new Error('The provided instruction could not be identified as a perpetuals instruction.');
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index-patched.js b/node_modules/jup-perps-client/dist/shared/index-patched.js
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index-patched.js
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.backup b/node_modules/jup-perps-client/dist/shared/index.js.backup
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.backup
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak10 b/node_modules/jup-perps-client/dist/shared/index.js.bak10
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak10
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak2 b/node_modules/jup-perps-client/dist/shared/index.js.bak2
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak2
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak6 b/node_modules/jup-perps-client/dist/shared/index.js.bak6
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak6
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak7 b/node_modules/jup-perps-client/dist/shared/index.js.bak7
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak7
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak8 b/node_modules/jup-perps-client/dist/shared/index.js.bak8
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak8
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/shared/index.js.bak9 b/node_modules/jup-perps-client/dist/shared/index.js.bak9
new file mode 100644
index 0000000..312f7a0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/shared/index.js.bak9
@@ -0,0 +1,86 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { AccountRole, isProgramDerivedAddress, isTransactionSigner as kitIsTransactionSigner, upgradeRoleToSigner, } from '@solana/kit';
+/**
+ * Asserts that the given value is not null or undefined.
+ * @internal
+ */
+export function expectSome(value) {
+    if (value == null) {
+        throw new Error('Expected a value but received null or undefined.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PublicKey.
+ * @internal
+ */
+export function expectAddress(value) {
+    if (!value) {
+        throw new Error('Expected a Address.');
+    }
+    if (typeof value === 'object' && 'address' in value) {
+        return value.address;
+    }
+    if (Array.isArray(value)) {
+        return value[0];
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a PDA.
+ * @internal
+ */
+export function expectProgramDerivedAddress(value) {
+    if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
+        throw new Error('Expected a ProgramDerivedAddress.');
+    }
+    return value;
+}
+/**
+ * Asserts that the given value is a TransactionSigner.
+ * @internal
+ */
+export function expectTransactionSigner(value) {
+    if (!value || !isTransactionSigner(value)) {
+        throw new Error('Expected a TransactionSigner.');
+    }
+    return value;
+}
+/**
+ * Get account metas and signers from resolved accounts.
+ * @internal
+ */
+export function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
+    return (account) => {
+        if (!account.value) {
+            if (optionalAccountStrategy === 'omitted')
+                return;
+            return Object.freeze({
+                address: programAddress,
+                role: AccountRole.READONLY,
+            });
+        }
+        const writableRole = account.isWritable
+            ? AccountRole.WRITABLE
+            : AccountRole.READONLY;
+        return Object.freeze({
+            address: expectAddress(account.value),
+            role: isTransactionSigner(account.value)
+                ? upgradeRoleToSigner(writableRole)
+                : writableRole,
+            ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),
+        });
+    };
+}
+export function isTransactionSigner(value) {
+    return (!!value &&
+        typeof value === 'object' &&
+        'address' in value &&
+        kitIsTransactionSigner(value));
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak10 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak10
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak10
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak2 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak2
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak2
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak3 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak3
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak3
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak5 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak5
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak5
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak6 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak6
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak6
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak7 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak7
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak7
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak8 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak8
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak8
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak9 b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak9
new file mode 100644
index 0000000..c99f24f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/amountAndFee.js.bak9
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAmountAndFeeEncoder() {
+    return getStructEncoder([
+        ['amount', getU64Encoder()],
+        ['fee', getU64Encoder()],
+        ['feeBps', getU64Encoder()],
+    ]);
+}
+export function getAmountAndFeeDecoder() {
+    return getStructDecoder([
+        ['amount', getU64Decoder()],
+        ['fee', getU64Decoder()],
+        ['feeBps', getU64Decoder()],
+    ]);
+}
+export function getAmountAndFeeCodec() {
+    return combineCodec(getAmountAndFeeEncoder(), getAmountAndFeeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak10 b/node_modules/jup-perps-client/dist/types/assets.js.bak10
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak10
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak2 b/node_modules/jup-perps-client/dist/types/assets.js.bak2
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak2
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak3 b/node_modules/jup-perps-client/dist/types/assets.js.bak3
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak3
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak5 b/node_modules/jup-perps-client/dist/types/assets.js.bak5
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak5
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak6 b/node_modules/jup-perps-client/dist/types/assets.js.bak6
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak6
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak7 b/node_modules/jup-perps-client/dist/types/assets.js.bak7
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak7
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak8 b/node_modules/jup-perps-client/dist/types/assets.js.bak8
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak8
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/assets.js.bak9 b/node_modules/jup-perps-client/dist/types/assets.js.bak9
new file mode 100644
index 0000000..acf52af
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/assets.js.bak9
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getAssetsEncoder() {
+    return getStructEncoder([
+        ['feesReserves', getU64Encoder()],
+        ['owned', getU64Encoder()],
+        ['locked', getU64Encoder()],
+        ['guaranteedUsd', getU64Encoder()],
+        ['globalShortSizes', getU64Encoder()],
+        ['globalShortAveragePrices', getU64Encoder()],
+    ]);
+}
+export function getAssetsDecoder() {
+    return getStructDecoder([
+        ['feesReserves', getU64Decoder()],
+        ['owned', getU64Decoder()],
+        ['locked', getU64Decoder()],
+        ['guaranteedUsd', getU64Decoder()],
+        ['globalShortSizes', getU64Decoder()],
+        ['globalShortAveragePrices', getU64Decoder()],
+    ]);
+}
+export function getAssetsCodec() {
+    return combineCodec(getAssetsEncoder(), getAssetsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak10 b/node_modules/jup-perps-client/dist/types/fees.js.bak10
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak10
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak2 b/node_modules/jup-perps-client/dist/types/fees.js.bak2
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak2
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak3 b/node_modules/jup-perps-client/dist/types/fees.js.bak3
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak3
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak5 b/node_modules/jup-perps-client/dist/types/fees.js.bak5
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak5
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak6 b/node_modules/jup-perps-client/dist/types/fees.js.bak6
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak6
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak7 b/node_modules/jup-perps-client/dist/types/fees.js.bak7
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak7
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak8 b/node_modules/jup-perps-client/dist/types/fees.js.bak8
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak8
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fees.js.bak9 b/node_modules/jup-perps-client/dist/types/fees.js.bak9
new file mode 100644
index 0000000..bd2c207
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fees.js.bak9
@@ -0,0 +1,37 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFeesEncoder() {
+    return getStructEncoder([
+        ['swapMultiplier', getU64Encoder()],
+        ['stableSwapMultiplier', getU64Encoder()],
+        ['addRemoveLiquidityBps', getU64Encoder()],
+        ['swapBps', getU64Encoder()],
+        ['taxBps', getU64Encoder()],
+        ['stableSwapBps', getU64Encoder()],
+        ['stableSwapTaxBps', getU64Encoder()],
+        ['liquidationRewardBps', getU64Encoder()],
+        ['protocolShareBps', getU64Encoder()],
+    ]);
+}
+export function getFeesDecoder() {
+    return getStructDecoder([
+        ['swapMultiplier', getU64Decoder()],
+        ['stableSwapMultiplier', getU64Decoder()],
+        ['addRemoveLiquidityBps', getU64Decoder()],
+        ['swapBps', getU64Decoder()],
+        ['taxBps', getU64Decoder()],
+        ['stableSwapBps', getU64Decoder()],
+        ['stableSwapTaxBps', getU64Decoder()],
+        ['liquidationRewardBps', getU64Decoder()],
+        ['protocolShareBps', getU64Decoder()],
+    ]);
+}
+export function getFeesCodec() {
+    return combineCodec(getFeesEncoder(), getFeesDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak10 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak10
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak10
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak2 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak2
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak2
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak3 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak3
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak3
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak5 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak5
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak5
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak6 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak6
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak6
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak7 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak7
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak7
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak8 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak8
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak8
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak9 b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak9
new file mode 100644
index 0000000..92cacc7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/fundingRateState.js.bak9
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getFundingRateStateEncoder() {
+    return getStructEncoder([
+        ['cumulativeInterestRate', getU128Encoder()],
+        ['lastUpdate', getI64Encoder()],
+        ['hourlyFundingDbps', getU64Encoder()],
+    ]);
+}
+export function getFundingRateStateDecoder() {
+    return getStructDecoder([
+        ['cumulativeInterestRate', getU128Decoder()],
+        ['lastUpdate', getI64Decoder()],
+        ['hourlyFundingDbps', getU64Decoder()],
+    ]);
+}
+export function getFundingRateStateCodec() {
+    return combineCodec(getFundingRateStateEncoder(), getFundingRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/index-patched.js b/node_modules/jup-perps-client/dist/types/index-patched.js
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index-patched.js
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index-patched.js.bak2 b/node_modules/jup-perps-client/dist/types/index-patched.js.bak2
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index-patched.js.bak2
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index-patched.js.bak3 b/node_modules/jup-perps-client/dist/types/index-patched.js.bak3
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index-patched.js.bak3
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index-patched.js.bak5 b/node_modules/jup-perps-client/dist/types/index-patched.js.bak5
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index-patched.js.bak5
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js b/node_modules/jup-perps-client/dist/types/index.js
index b35b01c..5673d11 100644
--- a/node_modules/jup-perps-client/dist/types/index.js
+++ b/node_modules/jup-perps-client/dist/types/index.js
@@ -1,27 +1,24 @@
 /**
- * This code was AUTOGENERATED using the codama library.
- * Please DO NOT EDIT THIS FILE, instead use visitors
- * to add features, then rerun codama to update it.
- *
- * @see https://github.com/codama-idl/codama
+ * Patched index.js - uses explicit file imports instead of directory imports
  */
-export * from './amountAndFee';
-export * from './assets';
-export * from './fees';
-export * from './fundingRateState';
-export * from './jumpRateState';
-export * from './limit';
-export * from './oracleParams';
-export * from './oraclePrice';
-export * from './oracleType';
-export * from './permissions';
-export * from './poolApr';
-export * from './priceCalcMode';
-export * from './priceImpactBuffer';
-export * from './priceImpactMechanism';
-export * from './priceStaleTolerance';
-export * from './pricingParams';
-export * from './requestChange';
-export * from './requestType';
-export * from './side';
-export * from './tradePoolType';
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.backup b/node_modules/jup-perps-client/dist/types/index.js.backup
new file mode 100644
index 0000000..b35b01c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.backup
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+export * from './amountAndFee';
+export * from './assets';
+export * from './fees';
+export * from './fundingRateState';
+export * from './jumpRateState';
+export * from './limit';
+export * from './oracleParams';
+export * from './oraclePrice';
+export * from './oracleType';
+export * from './permissions';
+export * from './poolApr';
+export * from './priceCalcMode';
+export * from './priceImpactBuffer';
+export * from './priceImpactMechanism';
+export * from './priceStaleTolerance';
+export * from './pricingParams';
+export * from './requestChange';
+export * from './requestType';
+export * from './side';
+export * from './tradePoolType';
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak10 b/node_modules/jup-perps-client/dist/types/index.js.bak10
new file mode 100644
index 0000000..5673d11
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak10
@@ -0,0 +1,24 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak2 b/node_modules/jup-perps-client/dist/types/index.js.bak2
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak2
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak3 b/node_modules/jup-perps-client/dist/types/index.js.bak3
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak3
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak5 b/node_modules/jup-perps-client/dist/types/index.js.bak5
new file mode 100644
index 0000000..cd172a7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak5
@@ -0,0 +1,17 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak6 b/node_modules/jup-perps-client/dist/types/index.js.bak6
new file mode 100644
index 0000000..5673d11
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak6
@@ -0,0 +1,24 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak7 b/node_modules/jup-perps-client/dist/types/index.js.bak7
new file mode 100644
index 0000000..5673d11
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak7
@@ -0,0 +1,24 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak8 b/node_modules/jup-perps-client/dist/types/index.js.bak8
new file mode 100644
index 0000000..5673d11
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak8
@@ -0,0 +1,24 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/index.js.bak9 b/node_modules/jup-perps-client/dist/types/index.js.bak9
new file mode 100644
index 0000000..5673d11
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/index.js.bak9
@@ -0,0 +1,24 @@
+/**
+ * Patched index.js - uses explicit file imports instead of directory imports
+ */
+export * from './amountAndFee.js';
+export * from './assets.js';
+export * from './fees.js';
+export * from './fundingRateState.js';
+export * from './jumpRateState.js';
+export * from './limit.js';
+export * from './oracleParams.js';
+export * from './oraclePrice.js';
+export * from './oracleType.js';
+export * from './permissions.js';
+export * from './poolApr.js';
+export * from './priceCalcMode.js';
+export * from './priceImpactBuffer.js';
+export * from './priceImpactMechanism.js';
+export * from './priceStaleTolerance.js';
+export * from './pricingParams.js';
+export * from './requestChange.js';
+export * from './requestType.js';
+export * from './side.js';
+export * from './tradePoolType.js';
+
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak10 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak10
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak10
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak2 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak2
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak2
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak3 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak3
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak3
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak5 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak5
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak5
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak6 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak6
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak6
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak7 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak7
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak7
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak8 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak8
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak8
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak9 b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak9
new file mode 100644
index 0000000..5e4256f
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/jumpRateState.js.bak9
@@ -0,0 +1,27 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getJumpRateStateEncoder() {
+    return getStructEncoder([
+        ['minRateBps', getU64Encoder()],
+        ['maxRateBps', getU64Encoder()],
+        ['targetRateBps', getU64Encoder()],
+        ['targetUtilizationRate', getU64Encoder()],
+    ]);
+}
+export function getJumpRateStateDecoder() {
+    return getStructDecoder([
+        ['minRateBps', getU64Decoder()],
+        ['maxRateBps', getU64Decoder()],
+        ['targetRateBps', getU64Decoder()],
+        ['targetUtilizationRate', getU64Decoder()],
+    ]);
+}
+export function getJumpRateStateCodec() {
+    return combineCodec(getJumpRateStateEncoder(), getJumpRateStateDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak10 b/node_modules/jup-perps-client/dist/types/limit.js.bak10
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak10
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak2 b/node_modules/jup-perps-client/dist/types/limit.js.bak2
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak2
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak3 b/node_modules/jup-perps-client/dist/types/limit.js.bak3
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak3
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak5 b/node_modules/jup-perps-client/dist/types/limit.js.bak5
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak5
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak6 b/node_modules/jup-perps-client/dist/types/limit.js.bak6
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak6
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak7 b/node_modules/jup-perps-client/dist/types/limit.js.bak7
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak7
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak8 b/node_modules/jup-perps-client/dist/types/limit.js.bak8
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak8
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/limit.js.bak9 b/node_modules/jup-perps-client/dist/types/limit.js.bak9
new file mode 100644
index 0000000..3c642b2
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/limit.js.bak9
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU128Decoder, getU128Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getLimitEncoder() {
+    return getStructEncoder([
+        ['maxAumUsd', getU128Encoder()],
+        ['tokenWeightageBufferBps', getU128Encoder()],
+        ['buffer', getU64Encoder()],
+    ]);
+}
+export function getLimitDecoder() {
+    return getStructDecoder([
+        ['maxAumUsd', getU128Decoder()],
+        ['tokenWeightageBufferBps', getU128Decoder()],
+        ['buffer', getU64Decoder()],
+    ]);
+}
+export function getLimitCodec() {
+    return combineCodec(getLimitEncoder(), getLimitDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js b/node_modules/jup-perps-client/dist/types/oracleParams.js
index 7a64c4c..ce2e3fb 100644
--- a/node_modules/jup-perps-client/dist/types/oracleParams.js
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js
@@ -6,7 +6,7 @@
  * @see https://github.com/codama-idl/codama
  */
 import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
-import { getOracleTypeDecoder, getOracleTypeEncoder, } from '.';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
 export function getOracleParamsEncoder() {
     return getStructEncoder([
         ['oracleAccount', getAddressEncoder()],
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak10 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak10
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak10
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak2 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak2
new file mode 100644
index 0000000..7a64c4c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak2
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from '.';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak3 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak3
new file mode 100644
index 0000000..7a64c4c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak3
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from '.';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak4 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak4
new file mode 100644
index 0000000..7a64c4c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak4
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from '.';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak5 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak5
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak5
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak6 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak6
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak6
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak7 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak7
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak7
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak8 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak8
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak8
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleParams.js.bak9 b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak9
new file mode 100644
index 0000000..ce2e3fb
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleParams.js.bak9
@@ -0,0 +1,28 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+import { getOracleTypeDecoder, getOracleTypeEncoder, } from './oracleType.js';
+export function getOracleParamsEncoder() {
+    return getStructEncoder([
+        ['oracleAccount', getAddressEncoder()],
+        ['oracleType', getOracleTypeEncoder()],
+        ['maxPriceError', getU64Encoder()],
+        ['maxPriceAgeSec', getU32Encoder()],
+    ]);
+}
+export function getOracleParamsDecoder() {
+    return getStructDecoder([
+        ['oracleAccount', getAddressDecoder()],
+        ['oracleType', getOracleTypeDecoder()],
+        ['maxPriceError', getU64Decoder()],
+        ['maxPriceAgeSec', getU32Decoder()],
+    ]);
+}
+export function getOracleParamsCodec() {
+    return combineCodec(getOracleParamsEncoder(), getOracleParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak10 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak10
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak10
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak2 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak2
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak2
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak3 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak3
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak3
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak5 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak5
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak5
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak6 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak6
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak6
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak7 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak7
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak7
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak8 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak8
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak8
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak9 b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak9
new file mode 100644
index 0000000..1891062
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oraclePrice.js.bak9
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getOraclePriceEncoder() {
+    return getStructEncoder([
+        ['price', getU64Encoder()],
+        ['exponent', getI32Encoder()],
+    ]);
+}
+export function getOraclePriceDecoder() {
+    return getStructDecoder([
+        ['price', getU64Decoder()],
+        ['exponent', getI32Decoder()],
+    ]);
+}
+export function getOraclePriceCodec() {
+    return combineCodec(getOraclePriceEncoder(), getOraclePriceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak10 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak10
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak10
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak2 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak2
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak2
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak3 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak3
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak3
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak5 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak5
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak5
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak6 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak6
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak6
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak7 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak7
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak7
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak8 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak8
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak8
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/oracleType.js.bak9 b/node_modules/jup-perps-client/dist/types/oracleType.js.bak9
new file mode 100644
index 0000000..5ac4df0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/oracleType.js.bak9
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var OracleType;
+(function (OracleType) {
+    OracleType[OracleType["None"] = 0] = "None";
+    OracleType[OracleType["Test"] = 1] = "Test";
+    OracleType[OracleType["Pyth"] = 2] = "Pyth";
+})(OracleType || (OracleType = {}));
+export function getOracleTypeEncoder() {
+    return getEnumEncoder(OracleType);
+}
+export function getOracleTypeDecoder() {
+    return getEnumDecoder(OracleType);
+}
+export function getOracleTypeCodec() {
+    return combineCodec(getOracleTypeEncoder(), getOracleTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak10 b/node_modules/jup-perps-client/dist/types/permissions.js.bak10
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak10
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak2 b/node_modules/jup-perps-client/dist/types/permissions.js.bak2
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak2
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak3 b/node_modules/jup-perps-client/dist/types/permissions.js.bak3
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak3
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak5 b/node_modules/jup-perps-client/dist/types/permissions.js.bak5
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak5
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak6 b/node_modules/jup-perps-client/dist/types/permissions.js.bak6
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak6
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak7 b/node_modules/jup-perps-client/dist/types/permissions.js.bak7
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak7
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak8 b/node_modules/jup-perps-client/dist/types/permissions.js.bak8
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak8
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/permissions.js.bak9 b/node_modules/jup-perps-client/dist/types/permissions.js.bak9
new file mode 100644
index 0000000..2c442f7
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/permissions.js.bak9
@@ -0,0 +1,33 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getBooleanDecoder, getBooleanEncoder, getStructDecoder, getStructEncoder, } from '@solana/kit';
+export function getPermissionsEncoder() {
+    return getStructEncoder([
+        ['allowSwap', getBooleanEncoder()],
+        ['allowAddLiquidity', getBooleanEncoder()],
+        ['allowRemoveLiquidity', getBooleanEncoder()],
+        ['allowIncreasePosition', getBooleanEncoder()],
+        ['allowDecreasePosition', getBooleanEncoder()],
+        ['allowCollateralWithdrawal', getBooleanEncoder()],
+        ['allowLiquidatePosition', getBooleanEncoder()],
+    ]);
+}
+export function getPermissionsDecoder() {
+    return getStructDecoder([
+        ['allowSwap', getBooleanDecoder()],
+        ['allowAddLiquidity', getBooleanDecoder()],
+        ['allowRemoveLiquidity', getBooleanDecoder()],
+        ['allowIncreasePosition', getBooleanDecoder()],
+        ['allowDecreasePosition', getBooleanDecoder()],
+        ['allowCollateralWithdrawal', getBooleanDecoder()],
+        ['allowLiquidatePosition', getBooleanDecoder()],
+    ]);
+}
+export function getPermissionsCodec() {
+    return combineCodec(getPermissionsEncoder(), getPermissionsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak10 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak10
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak10
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak2 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak2
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak2
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak3 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak3
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak3
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak5 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak5
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak5
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak6 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak6
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak6
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak7 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak7
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak7
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak8 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak8
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak8
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/poolApr.js.bak9 b/node_modules/jup-perps-client/dist/types/poolApr.js.bak9
new file mode 100644
index 0000000..c138496
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/poolApr.js.bak9
@@ -0,0 +1,25 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPoolAprEncoder() {
+    return getStructEncoder([
+        ['lastUpdated', getI64Encoder()],
+        ['feeAprBps', getU64Encoder()],
+        ['realizedFeeUsd', getU64Encoder()],
+    ]);
+}
+export function getPoolAprDecoder() {
+    return getStructDecoder([
+        ['lastUpdated', getI64Decoder()],
+        ['feeAprBps', getU64Decoder()],
+        ['realizedFeeUsd', getU64Decoder()],
+    ]);
+}
+export function getPoolAprCodec() {
+    return combineCodec(getPoolAprEncoder(), getPoolAprDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak10 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak10
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak10
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak2 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak2
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak2
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak3 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak3
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak3
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak5 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak5
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak5
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak6 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak6
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak6
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak7 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak7
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak7
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak8 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak8
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak8
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak9 b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak9
new file mode 100644
index 0000000..2e95ed0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceCalcMode.js.bak9
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceCalcMode;
+(function (PriceCalcMode) {
+    PriceCalcMode[PriceCalcMode["Min"] = 0] = "Min";
+    PriceCalcMode[PriceCalcMode["Max"] = 1] = "Max";
+    PriceCalcMode[PriceCalcMode["Ignore"] = 2] = "Ignore";
+})(PriceCalcMode || (PriceCalcMode = {}));
+export function getPriceCalcModeEncoder() {
+    return getEnumEncoder(PriceCalcMode);
+}
+export function getPriceCalcModeDecoder() {
+    return getEnumDecoder(PriceCalcMode);
+}
+export function getPriceCalcModeCodec() {
+    return combineCodec(getPriceCalcModeEncoder(), getPriceCalcModeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak10 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak10
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak10
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak2 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak2
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak2
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak3 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak3
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak3
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak5 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak5
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak5
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak6 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak6
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak6
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak7 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak7
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak7
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak8 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak8
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak8
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak9 b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak9
new file mode 100644
index 0000000..53395c8
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactBuffer.js.bak9
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getArrayDecoder, getArrayEncoder, getF32Decoder, getF32Encoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPriceImpactBufferEncoder() {
+    return getStructEncoder([
+        ['openInterest', getArrayEncoder(getI64Encoder(), { size: 60 })],
+        ['lastUpdated', getI64Encoder()],
+        ['feeFactor', getU64Encoder()],
+        ['exponent', getF32Encoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Encoder()],
+        ['maxFeeBps', getU64Encoder()],
+    ]);
+}
+export function getPriceImpactBufferDecoder() {
+    return getStructDecoder([
+        ['openInterest', getArrayDecoder(getI64Decoder(), { size: 60 })],
+        ['lastUpdated', getI64Decoder()],
+        ['feeFactor', getU64Decoder()],
+        ['exponent', getF32Decoder()],
+        ['deltaImbalanceThresholdDecimal', getU64Decoder()],
+        ['maxFeeBps', getU64Decoder()],
+    ]);
+}
+export function getPriceImpactBufferCodec() {
+    return combineCodec(getPriceImpactBufferEncoder(), getPriceImpactBufferDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak10 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak10
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak10
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak2 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak2
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak2
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak3 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak3
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak3
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak5 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak5
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak5
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak6 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak6
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak6
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak7 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak7
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak7
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak8 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak8
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak8
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak9 b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak9
new file mode 100644
index 0000000..255e2f0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceImpactMechanism.js.bak9
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceImpactMechanism;
+(function (PriceImpactMechanism) {
+    PriceImpactMechanism[PriceImpactMechanism["TradeSize"] = 0] = "TradeSize";
+    PriceImpactMechanism[PriceImpactMechanism["DeltaImbalance"] = 1] = "DeltaImbalance";
+})(PriceImpactMechanism || (PriceImpactMechanism = {}));
+export function getPriceImpactMechanismEncoder() {
+    return getEnumEncoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismDecoder() {
+    return getEnumDecoder(PriceImpactMechanism);
+}
+export function getPriceImpactMechanismCodec() {
+    return combineCodec(getPriceImpactMechanismEncoder(), getPriceImpactMechanismDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak10 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak10
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak10
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak2 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak2
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak2
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak3 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak3
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak3
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak5 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak5
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak5
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak6 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak6
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak6
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak7 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak7
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak7
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak8 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak8
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak8
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak9 b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak9
new file mode 100644
index 0000000..1fc8876
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/priceStaleTolerance.js.bak9
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var PriceStaleTolerance;
+(function (PriceStaleTolerance) {
+    PriceStaleTolerance[PriceStaleTolerance["Strict"] = 0] = "Strict";
+    PriceStaleTolerance[PriceStaleTolerance["Loose"] = 1] = "Loose";
+})(PriceStaleTolerance || (PriceStaleTolerance = {}));
+export function getPriceStaleToleranceEncoder() {
+    return getEnumEncoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceDecoder() {
+    return getEnumDecoder(PriceStaleTolerance);
+}
+export function getPriceStaleToleranceCodec() {
+    return combineCodec(getPriceStaleToleranceEncoder(), getPriceStaleToleranceDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak10 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak10
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak10
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak2 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak2
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak2
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak3 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak3
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak3
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak5 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak5
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak5
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak6 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak6
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak6
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak7 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak7
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak7
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak8 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak8
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak8
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/pricingParams.js.bak9 b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak9
new file mode 100644
index 0000000..cd43cdd
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/pricingParams.js.bak9
@@ -0,0 +1,31 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, } from '@solana/kit';
+export function getPricingParamsEncoder() {
+    return getStructEncoder([
+        ['tradeImpactFeeScalar', getU64Encoder()],
+        ['buffer', getU64Encoder()],
+        ['swapSpread', getU64Encoder()],
+        ['maxLeverage', getU64Encoder()],
+        ['maxGlobalLongSizes', getU64Encoder()],
+        ['maxGlobalShortSizes', getU64Encoder()],
+    ]);
+}
+export function getPricingParamsDecoder() {
+    return getStructDecoder([
+        ['tradeImpactFeeScalar', getU64Decoder()],
+        ['buffer', getU64Decoder()],
+        ['swapSpread', getU64Decoder()],
+        ['maxLeverage', getU64Decoder()],
+        ['maxGlobalLongSizes', getU64Decoder()],
+        ['maxGlobalShortSizes', getU64Decoder()],
+    ]);
+}
+export function getPricingParamsCodec() {
+    return combineCodec(getPricingParamsEncoder(), getPricingParamsDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak10 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak10
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak10
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak2 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak2
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak2
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak3 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak3
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak3
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak5 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak5
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak5
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak6 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak6
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak6
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak7 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak7
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak7
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak8 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak8
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak8
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestChange.js.bak9 b/node_modules/jup-perps-client/dist/types/requestChange.js.bak9
new file mode 100644
index 0000000..e81fac0
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestChange.js.bak9
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestChange;
+(function (RequestChange) {
+    RequestChange[RequestChange["None"] = 0] = "None";
+    RequestChange[RequestChange["Increase"] = 1] = "Increase";
+    RequestChange[RequestChange["Decrease"] = 2] = "Decrease";
+})(RequestChange || (RequestChange = {}));
+export function getRequestChangeEncoder() {
+    return getEnumEncoder(RequestChange);
+}
+export function getRequestChangeDecoder() {
+    return getEnumDecoder(RequestChange);
+}
+export function getRequestChangeCodec() {
+    return combineCodec(getRequestChangeEncoder(), getRequestChangeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak10 b/node_modules/jup-perps-client/dist/types/requestType.js.bak10
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak10
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak2 b/node_modules/jup-perps-client/dist/types/requestType.js.bak2
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak2
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak3 b/node_modules/jup-perps-client/dist/types/requestType.js.bak3
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak3
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak5 b/node_modules/jup-perps-client/dist/types/requestType.js.bak5
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak5
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak6 b/node_modules/jup-perps-client/dist/types/requestType.js.bak6
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak6
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak7 b/node_modules/jup-perps-client/dist/types/requestType.js.bak7
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak7
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak8 b/node_modules/jup-perps-client/dist/types/requestType.js.bak8
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak8
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/requestType.js.bak9 b/node_modules/jup-perps-client/dist/types/requestType.js.bak9
new file mode 100644
index 0000000..b8ac3e5
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/requestType.js.bak9
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var RequestType;
+(function (RequestType) {
+    RequestType[RequestType["Market"] = 0] = "Market";
+    RequestType[RequestType["Trigger"] = 1] = "Trigger";
+})(RequestType || (RequestType = {}));
+export function getRequestTypeEncoder() {
+    return getEnumEncoder(RequestType);
+}
+export function getRequestTypeDecoder() {
+    return getEnumDecoder(RequestType);
+}
+export function getRequestTypeCodec() {
+    return combineCodec(getRequestTypeEncoder(), getRequestTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak10 b/node_modules/jup-perps-client/dist/types/side.js.bak10
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak10
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak2 b/node_modules/jup-perps-client/dist/types/side.js.bak2
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak2
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak3 b/node_modules/jup-perps-client/dist/types/side.js.bak3
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak3
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak5 b/node_modules/jup-perps-client/dist/types/side.js.bak5
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak5
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak6 b/node_modules/jup-perps-client/dist/types/side.js.bak6
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak6
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak7 b/node_modules/jup-perps-client/dist/types/side.js.bak7
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak7
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak8 b/node_modules/jup-perps-client/dist/types/side.js.bak8
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak8
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/side.js.bak9 b/node_modules/jup-perps-client/dist/types/side.js.bak9
new file mode 100644
index 0000000..732926c
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/side.js.bak9
@@ -0,0 +1,23 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var Side;
+(function (Side) {
+    Side[Side["None"] = 0] = "None";
+    Side[Side["Long"] = 1] = "Long";
+    Side[Side["Short"] = 2] = "Short";
+})(Side || (Side = {}));
+export function getSideEncoder() {
+    return getEnumEncoder(Side);
+}
+export function getSideDecoder() {
+    return getEnumDecoder(Side);
+}
+export function getSideCodec() {
+    return combineCodec(getSideEncoder(), getSideDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak10 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak10
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak10
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak2 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak2
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak2
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak3 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak3
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak3
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak5 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak5
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak5
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak6 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak6
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak6
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak7 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak7
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak7
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak8 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak8
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak8
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
diff --git a/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak9 b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak9
new file mode 100644
index 0000000..5c18e74
--- /dev/null
+++ b/node_modules/jup-perps-client/dist/types/tradePoolType.js.bak9
@@ -0,0 +1,22 @@
+/**
+ * This code was AUTOGENERATED using the codama library.
+ * Please DO NOT EDIT THIS FILE, instead use visitors
+ * to add features, then rerun codama to update it.
+ *
+ * @see https://github.com/codama-idl/codama
+ */
+import { combineCodec, getEnumDecoder, getEnumEncoder, } from '@solana/kit';
+export var TradePoolType;
+(function (TradePoolType) {
+    TradePoolType[TradePoolType["Increase"] = 0] = "Increase";
+    TradePoolType[TradePoolType["Decrease"] = 1] = "Decrease";
+})(TradePoolType || (TradePoolType = {}));
+export function getTradePoolTypeEncoder() {
+    return getEnumEncoder(TradePoolType);
+}
+export function getTradePoolTypeDecoder() {
+    return getEnumDecoder(TradePoolType);
+}
+export function getTradePoolTypeCodec() {
+    return combineCodec(getTradePoolTypeEncoder(), getTradePoolTypeDecoder());
+}
